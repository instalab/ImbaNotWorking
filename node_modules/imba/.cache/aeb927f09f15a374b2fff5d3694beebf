function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');
var MSG = require('../scrimba/protocol').MSG;
var Resource = require('../store/Resource').Resource;
var LongPromise = require('../util/LongPromise').LongPromise;

function WriteStream(file,api){
	this._file = file;
	this._chunks = [];
	this._uploadQueue = [];
	this._errors = [];
	this._uploaded = -1;
	this._state = 'open';
	this._size = 0;
	this._api = api;
	this._blob = null;
	this._promise = new LongPromise();
	this._uploading = null;
	this;
};

exports.WriteStream = WriteStream; // export class 
WriteStream.prototype.file = function(v){ return this._file; }
WriteStream.prototype.setFile = function(v){ this._file = v; return this; };
WriteStream.prototype.state = function(v){ return this._state; }
WriteStream.prototype.setState = function(v){ this._state = v; return this; };
WriteStream.prototype.promise = function(v){ return this._promise; }
WriteStream.prototype.setPromise = function(v){ this._promise = v; return this; };


// TODO allow uploading continuously to server
WriteStream.prototype.write = function (chunk){
	let nr = len$(this._chunks);
	this._chunks.push(chunk);
	chunk._offset = this._size;
	// @offsets[nr] = @size
	this._size += (chunk.size || chunk.length);
	this._uploadQueue.push(chunk);
	if (!this._uploading) this.uploadChunk();
	return this;
};

WriteStream.prototype.blob = function (){
	return this._blob;
};

WriteStream.prototype.close = function (blob){
	this._file._blob = this._blob = (blob || (blob = new Blob(this._chunks,{type: this._file.type})));
	this.setState('closed');
	this.uploadChunk();
	// if uploading is underway, wait for the last packet
	
	// not saving it locally now
	// var key = @file:id + "_body"
	// var res = await @file.@db.cacheSet(key,{body: blob})
	return this._promise; // @file
};

WriteStream.prototype.uploadChunk = function (){
	var self = this;
	if (self._uploading) { return };
	let chunk = self._chunks[self._uploaded + 1];
	
	if (!chunk) {
		if (self.state() == 'closed') {
			self.setState('uploaded');
			self._promise.resolve(self);
		};
		return;
	};
	
	return self._uploading = new Promise(function(resolve,reject) {
		var req = new XMLHttpRequest();
		
		req.upload.addEventListener('progress',function(e) {
			// console.log 'progress',e:loaded,e:total,e:loaded / e:total
		});
		req.onload = function(e) {
			// console.log "response from server",req:response,req:status
			if (req.status == 200) {
				self._uploading = null;
				self._uploaded++;
				resolve(req);
				return self.uploadChunk();
			} else {
				self._errors.push("failed");
				reject(req);
				return self._uploading = null;
			};
		};
		
		req.onerror = function(e) {
			return true;
			// console.error "error from uploading!!",e,req:status
			// reject(self)
		};
		
		let url = ("/files/" + (self.file().id) + "/append?offset=" + (chunk._offset));
		// console.log "uploadChunk",url
		req.open('POST',url);
		return req.send(chunk);
	});
};

function File(){ return Resource.apply(this,arguments) };

Imba.subclass(File,Resource);
exports.File = File; // export class 
File.prototype.createWriteStream = function (api){
	return this._writer || (this._writer = new WriteStream(this,api));
};

File.prototype.upload = async function (data,state){
	var self = this;
	if(state === undefined) state = {};
	if (self._writer) {
		self._writer.uploadChunk();
		await self._writer.promise();
		return await self.rpc('fileUploaded');
	};
	
	// first save locally
	return self._cache.uploader || (self._cache.uploader = new Promise(async function(resolve,reject) {
		var res = await self.save();
		// console.log "saved to server"
		var blob = await (data || self.fetchLocalBlob());
		var req = new XMLHttpRequest();
		
		req.upload.addEventListener('progress',function(e) {
			var loaded = e.loaded;
			var tot = e.total;
			var progress = loaded / tot;
			state.loaded = e.loaded;
			state.total = e.total;
			state.progress = progress;
			return console.log('progress',e,req.upload.loaded,req.upload.total,loaded,tot,loaded / tot);
		});
		
		req.onload = function(e) {
			console.log("request finished uploading!!",e,req.response);
			return resolve(req.response);
		};
		
		req.open('POST',("/files/" + (self.id) + "/append?offset=0"));
		return req.send(blob);
	}));
};

File.prototype.fetchLocalBlob = async function (){
	if (this._blob) { return Promise.resolve(this._blob) };
	var res = await this._db.cacheGet(this.id + "_body");
	return res ? res.body : null;
};

File.prototype.fetchAsArrayBuffer = function (path){
	var self = this;
	if(path === undefined) path = null;
	return self._fetcher || (self._fetcher = new Promise(async function(resolve) {
		var localBuffer = await self.fetchLocalBlob();
		
		if (localBuffer) {
			var reader = new FileReader();
			reader.onloadend = function(e) {
				self._arraybuffer = e.target.result;
				return resolve(self._arraybuffer);
			};
			return reader.readAsArrayBuffer(localBuffer);
		} else {
			var xhr = new XMLHttpRequest();
			xhr.open('GET',path || ("/cdn/" + (self.id)),true);
			xhr.responseType = 'arraybuffer';
			xhr.onload = function() {
				return resolve(self._arraybuffer = xhr.response);
			};
			return xhr.send();
		};
	}));
};

File.prototype.ext = function (){
	return this.id.split('.').pop();
};

File.prototype.repair = async function (){
	var integrity = await this._db.api().rpc('checkIntegrity',[this.id]);
	// console.log "integrity from server!",integrity
	if (integrity.realSize == 0) {
		var localBlob = await this.fetchLocalBlob();
		if (localBlob) {
			console.log("found local file! - try to upload");
			return this.upload();
		} else {
			return {error: "file not found"};
		};
	} else {
		return this;
	};
};

if (true) {
	var fs = require('fs');
	File.prototype.systemPath = function (){
		return global.FILES_DIR + '/' + this.id;
	};
	
	File.prototype.checkIntegrity = function (){
		var self = this;
		console.log("system path is",self.systemPath());
		
		var health = {
			type: 'file',
			fid: self.id,
			realSize: 0
		};
		
		return new Promise(async function(resolve,reject) {
			await self.fetch(); // ensure we have latest version
			health.size = self.size;
			return fs.stat(self.systemPath(),function(err,stat) {
				if (err) {
					health.error = 404;
				};
				health.realSize = stat && stat.size || 0;
				return resolve(health);
			});
		});
		// change status / update object in db?
	};
};

