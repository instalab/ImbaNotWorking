var Imba = require('imba');
var assigner = function(item,data) {
	for (let v, i = 0, keys = Object.keys(data), l = keys.length, k; i < l; i++){
		k = keys[i];v = data[k];item[k] = v;
	};
	return;
};

var MASK = exports.MASK = {
	NEVER: 0,
	ALWAYS: 1,
	OWN: 2,
	NOTNIL: 4
};

var ACCESS = exports.ACCESS = {
	NONE: 0,
	READ: 1,
	WRITE: 2,
	UPDATE: 2,
	INS: 4,
	PUT: 8,
	DEL: 16,
	ALL: 1 | 2 | 4 | 8 | 16,
	
	read: 1,
	write: 2,
	update: 2,
	ins: 4,
	put: 8,
	edit: 8,
	del: 16
};

function Resource(data,store){
	Object.defineProperty(this,'_cache',{value: {},enumerable: false});
	this._store = store;
	this._data = {};
	this.patch(data,store);
	this;
};

exports.Resource = Resource; // export class 
Resource.canPut = function (data,prev,auth){
	console.log("canPut",data.id,auth && auth.uid());
	// dont let other users update objects
	if (auth && prev.uid && (auth.uid() != prev.uid)) {
		return false;
	};
	return true;
};

Resource.read = function (data,store){
	return new this(data,store);
};

Resource.prototype.notifyChannels = function (data){
	return 'all';
};

Resource.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
Resource.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
Resource.prototype.once = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.once.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
Resource.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

Resource.prototype.inspect = function (){
	return this._data;
};

Resource.prototype.patch = function (data){
	assigner(this,data);
	assigner(this._data,data);
	return this;
};

Resource.prototype.get = function (key){
	return this[key];
};

Resource.prototype.db = function (){
	// global instance of db?
	return this._db || App.api().db();
};

Resource.prototype.api = function (){
	return this._db.api();
};

Resource.prototype.isLocal = function (){
	return this._data.v == -1 || this._data.v == -2;
};

// is this resource local and not even persisted?
Resource.prototype.isPersisted = function (){
	return this._data.v >= -1;
};

Resource.prototype.isInited = function (){
	return this._data.v > -3;
};

Resource.prototype.permissions = function (scope){
	let user = scope && scope.user();
	if (user && (this.uid == user.id)) {
		return ACCESS.ALL;
	} else if (this.privacy == 'private') {
		return ACCESS.NONE;
	} else {
		return ACCESS.READ;
	};
};

Resource.prototype.can = function (api,action){
	return this.permissions(api) & (ACCESS[action] || action);
};

Resource.prototype.update = function (data){
	if (false) {};
	
	data.id = this.id;
	return this._store.put(data);
};

Resource.prototype.save = function (data){
	if (this.isLocal()) {
		// what if we want to keep it local?
		if (data) { this.patch(data) };
		return this._store.ins(this);
	} else {
		return data ? this.update(data) : Promise.resolve(this);
	};
};

Resource.prototype.del = function (hard){
	if(hard === undefined) hard = false;
	if (hard && this.isLocal()) {
		this._store.del(this);
	};
	return this;
};

Resource.prototype.saveLocal = function (){
	return this._store.saveLocal(this);
};

Resource.prototype.fetch = async function (){
	var item = await this._store.fetch(this);
	return item;
};

Resource.prototype.rpc = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	if (false) {} else {
		return console.warn(("Resource#rpc(" + name + ") not supported on server"));
	};
};

Resource.prototype.dependsOn = function (){
	return null;
};

Resource.prototype.toJSON = function (){
	return this.serialize();
};

Resource.prototype.beforeSerialize = function (){
	return null;
};

Resource.prototype.clone = function (){
	return new this.constructor(JSON.parse(JSON.stringify(this)));
};

Resource.prototype.diff = function (other){
	var changes = {};
	for (let v, i = 0, keys = Object.keys(other), l = keys.length, k; i < l; i++){
		k = keys[i];v = other[k];if (k[0] == '_' || v == undefined) { continue; };
		if (JSON.stringify(this[k]) != JSON.stringify(v)) {
			changes[k] = v;
		};
	};
	return changes;
};

// TODO formalize the serializer and the different masks it can
// contain for users
Resource.prototype.serialize = function (scop){
	var s = this.constructor._serializer;
	var obj = {};
	
	var uid;
	
	if (true) {
		scop || (scop = this._db.scope());
		
		if (this.allowed) {
			if (!this.allowed('read',scop)) { return null };
		};
		
		// when this has been included as a result of inclusion
		// we leak the existance of item. Is this okay?
		if (!this.can(scop,ACCESS.READ)) {
			return {v: this.v,id: this.id,CODE: 403};
		};
	};
	
	this.beforeSerialize(obj,uid);
	
	if (false) {};
	
	// what about caching the jsonified version?
	// var s = self:constructor.@serializer
	// var obj = {}
	var id = this.id;
	for (let o = this, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];if (s && s[k] !== undefined) {
			if (v === undefined) {
				v = null;
			};
			if (s[k] == MASK.NEVER) {
				continue;
			};
			if (s[k] & MASK.OWN) {
				if (!(id == uid || (this.uid && this.uid == uid))) {
					continue;
				};
			};
		} else if (k[0] == '_' || v == undefined) {
			continue;
		};
		
		obj[k] = v;
	};
	return obj;
};
