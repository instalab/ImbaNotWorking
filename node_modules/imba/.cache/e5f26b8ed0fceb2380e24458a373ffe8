function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
/*

Helper class that represents the local viewer / agent
Keeps track of the widget options / settings viewer
overrides, and sets up triggers to clear them when
playback resumes etc. Used very little as of yet, but
it seems like a good idea to have an per-space session/client

*/

function Client(space){
	var self = this;
	self._space = space;
	self._options = new Map();
	
	self._space.on('playing',function() {
		// space.agent.options.discardLocals
		return self;
	});
	self;
};

exports.Client = Client; // export class 
Client.prototype.idle = function(v){ return this._idle; }
Client.prototype.setIdle = function(v){ this._idle = v; return this; };
Client.prototype.options = function(v){ return this._options; }
Client.prototype.setOptions = function(v){ this._options = v; return this; };
Client.prototype.space = function(v){ return this._space; }
Client.prototype.setSpace = function(v){ this._space = v; return this; };

Client.prototype.optionsForItem = function (item){
	var params;
	if (!(params = this._options.get(item))) {
		this._options.set(item,params = {});
	};
	return params;
};

Client.prototype.set = function (obj,key,value){
	var params = this.optionsForItem(obj);
	params[key] = value;
	return this;
};

Client.prototype.clearOptions = function (){
	var updates = [];
	this._options.forEach(function(params,widget) {
		var v_;
		if (len$(Object.keys(params))) {
			updates.push(widget);
			let res = [];
			for (let v, i = 0, keys = Object.keys(params), l = keys.length, k; i < l; i++){
				k = keys[i];v = params[k];res.push((((v_ = params[k]),delete params[k], v_)));
			};
			return res;
		};
	});
	return this;
};

Client.prototype.flushLocals = function (){
	return this.options().forEach(function(params,widget) {
		return widget.options().set(params);
	});
	// space.files.forEach do |file|
	// 	file.flushLocals
};
