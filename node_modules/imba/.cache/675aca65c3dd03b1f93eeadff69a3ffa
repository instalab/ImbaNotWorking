function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');
var SCON = require('../protocol').SCON;

// externs;

if (false) {};

var MonacoView = Imba.defineTag('MonacoView', function(tag){
	
	tag.prototype.__model = {watch: 'modelDidSet',name: 'model'};
	tag.prototype.model = function(v){ return this._model; }
	tag.prototype.setModel = function(v){
		var a = this.model();
		if(v != a) { this._model = v; }
		if(v != a) { this.modelDidSet && this.modelDidSet(v,a,this.__model) }
		return this;
	};
	
	tag.prototype.disposables = function (){
		return this._disposables || (this._disposables = []);
	};
	
	tag.prototype.space = function (){
		return this.data().space();
	};
	
	tag.prototype.setup = function (){
		var self = this;
		return self.space().once('dispose',function() {
			return self.dispose();
		});
	};
	
	tag.prototype.getDynamicOptions = function (){
		var opts;
		var fontSize = this.fontSize(); // space.view.fontSize # what about api.fontSize?
		
		return opts = {
			fontSize: (this._fontSize = fontSize),
			lineHeight: this._lineHeight = Math.ceil(this._fontSize * 1.5),
			lineDecorationsWidth: fontSize + 4,
			suggestFontSize: this._fontSize
		};
	};
	
	tag.prototype.nodeLayout = function (){
		return this.space().view().layoutForNode(this,true);
	};
	
	tag.prototype.configuration = function (){
		return this._editor.viewModel.configuration;
	};
	tag.prototype.fontInfo = function (){
		return this.configuration().editor.fontInfo;
	};
	tag.prototype.layoutInfo = function (){
		return this.configuration().editor.layoutInfo;
	};
	
	tag.prototype.top = function (){
		return this.nodeLayout()[0];
	}; // @top ||= dom:offsetTop
	tag.prototype.left = function (){
		return this.nodeLayout()[1];
	}; // @left ||= dom:offsetLeft
	tag.prototype.width = function (){
		return this.nodeLayout()[2];
	};
	tag.prototype.height = function (){
		return this.nodeLayout()[3];
	};
	tag.prototype.contentTop = function (){
		return 0;
	};
	tag.prototype.fontSize = function (){
		return this.space().view().fontSize();
	}; // 
	tag.prototype.lineHeight = function (){
		return Math.ceil(this.fontSize() * 1.5);
	};
	tag.prototype.contentLeft = function (){
		return this._layoutInfo && this._layoutInfo.contentLeft || 16;
	};
	tag.prototype.scrollTop = function (){
		return this._bridge ? this._bridge.getScrollTop() : 0;
	};
	tag.prototype.scrollLeft = function (){
		return this._bridge ? this._bridge.getScrollLeft() : 0;
	};
	
	tag.prototype.modelDidSet = function (model,prev){
		var $1, $2;
		if (prev) { ($1 = prev) && $1.willDetach  &&  $1.willDetach(this) };
		this._editor.setModel(model ? model.monacoModel() : null);
		this._editor.render();
		if (model) { return ($2 = model) && $2.didAttach  &&  $2.didAttach(this) };
	};
	
	tag.prototype.pushLayout = function (){
		if (!(this.space().isEditing() && this._editor)) {
			return;
		};
		
		let layout = this.nodeLayout();
		
		this.data().setTop(layout[0]);
		this.data().setLeft(layout[1]);
		this.data().setWidth(layout[2]);
		this.data().setHeight(layout[3]);
		
		this.data().setContentLeft(this.contentLeft());
		this.data().setContentTop(this.contentTop());
		this.data().setFontSize(this.fontSize());
		this.data().setLineHeight(this.lineHeight());
		
		// if file and @editor
		// 	file.scrollTop = @editor.getScrollTop # :scrollTop
		// 	file.scrollLeft = @editor.getScrollLeft # e:scrollLeft
		return this;
	};
	
	// calculate the local layout for the current file
	tag.prototype.relayout = function (hard){
		if(hard === undefined) hard = false;
		if (hard) {
			this._top = this._left = this._width = this._height = 0;
		};
		
		// this part should only happen on space-resize now
		var w = this._width || (this._width = this.dom().offsetWidth);
		var h = this._height || (this._height = this.dom().offsetHeight);
		
		if (!(w && this._editor)) { return };
		
		this._compositingLayout = true;
		
		if (this._syncedFontSize != this.space().view().fontSize()) {
			this._editor.updateOptions(this.getDynamicOptions());
			this._syncedFontSize = this.space().view().fontSize();
		};
		
		if (w != this._syncedWidth || h != this._syncedHeight) {
			this._syncedWidth = w;
			this._syncedHeight = h;
			this._editor.layout({height: h,width: w});
		};
		this._compositingLayout = false;
		return this;
	};
	
	tag.prototype.batch = function (state,blk){
		if(blk==undefined && typeof state == 'function') blk = state,state = {};
		if(state==undefined) state = {};
		let preFocus = this.hasFocus();
		let prevStack = this._syncing;
		this._syncing = {state: state,focus: this.hasFocus()};
		blk.call(this,this._syncing);
		if (preFocus && !(this.hasFocus())) { this._editor.focus() };
		this._syncing = prevStack;
		return this;
	};
	
	tag.prototype.focus = function (){
		if (this._editor) {
			this._editor.focus();
		} else {
			this.setAttribute('tabindex',-1);
			this.dom().focus();
		};
		return this;
	};
	
	tag.prototype.hasFocus = function (){
		return document.activeElement == this.dom() || (this._editor && this._editor.isFocused());
	};
	
	tag.prototype.setSelections = function (sel){
		if (this._editor) {
			this._monacoSel = this.monacoBridge().opToSelections(sel);
			return this._editor.setSelections(this._monacoSel);
		};
	};
	
	tag.prototype.getSelections = function (){
		var self = this;
		if (self._editor) {
			var sel = self._editor.getSelections().map(function(_0) { return self.monacoBridge().selectionToArray(_0); });
			return (len$(sel) == 1) ? sel[0] : sel;
		};
		return [];
	};
	
	tag.prototype.onDidLayoutChange = function (e){
		this._layoutInfo = e;
		return this;
	};
	
	tag.prototype.onDidFocusEditor = function (e){
		return this;
	};
	
	tag.prototype.onDidBlurEditor = function (e){
		return this;
	};
	
	tag.prototype.onDidChangeCursorSelection = function (e){
		return this;
	};
	
	tag.prototype.onDidScrollChange = function (e){
		return this;
	};
	
	tag.prototype.loaded = function (){
		var self = this;
		self.disposables().push(self._editor.onDidLayoutChange(self.onDidLayoutChange.bind(self)));
		self.disposables().push(self._editor.onDidFocusEditor(self.onDidFocusEditor.bind(self)));
		self.disposables().push(self._editor.onDidBlurEditor(self.onDidBlurEditor.bind(self)));
		self.disposables().push(self._editor.onDidChangeCursorSelection(self.onDidChangeCursorSelection.bind(self)));
		self.disposables().push(self._editor.onDidScrollChange(self.onDidScrollChange.bind(self)));
		
		self.space().on('reflow',function(dirty) { return self.relayout(true); });
		self._layoutInfo = self._editor.getLayoutInfo();
		return self;
	};
	
	tag.prototype.load = async function (){
		if (this._editor || this._loading) {
			return this;
		};
		
		this._loading = true;
		this._syncing = null;
		await this.monacoBridge().load();
		
		var opts = Object.assign(SCON.clone(window.MonacoEnvironment.defaults),this.getDynamicOptions());
		
		this._timeouts = [];
		
		this._editor = this._bridge = monaco.editor.create(this.dom(),opts);
		this._loading = false;
		this.loaded();
		this.flag('loaded');
		this.render();
		if (document.activeElement == this.dom()) {
			this._editor.focus();
		};
		return this;
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self._mounted = true;
		self.load();
		self.render();
		setTimeout(function() { return self.relayout(); },20);
		return self;
	};
	
	tag.prototype.unmount = function (){
		return this;
	};
	
	tag.prototype.dispose = function (){
		var $1;
		for (let i = 0, items = iter$(this._disposables), len = items.length; i < len; i++) {
			($1 = items[i]) && $1.dispose  &&  $1.dispose();
		};
		this._disposables = [];
		
		if (this._model) {
			// dispose all file-models?
			this._model.dispose();
			this._model = null;
		};
		
		if (this._editor) {
			this._editor.FILE = null;
			this._editor.setModel(null);
			this._editor.dispose();
			try {
				this._editor.domElement.innerHTML = '';
			} catch (e) { };
			// try
			// 	@editor:domElement:innerHTML = ''
			this._editor.domElement = null;
			this._editor = null;
		};
		
		this._editor = null;
		this._dom._tag = null;
		this._dom.innerHTML = null;
		
		this._data = null;
		this._owner = null;
		this._dom.parentNode.removeChild(this._dom);
		return this;
	};
})
exports.MonacoView = MonacoView;
