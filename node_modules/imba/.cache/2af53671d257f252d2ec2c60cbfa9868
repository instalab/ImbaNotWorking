function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var self = {};
var protocol$ = require('../protocol'), WIDGET = protocol$.WIDGET, SCON = protocol$.SCON, ACTION = protocol$.ACTION, KEYS = protocol$.KEYS;


self.isEqual = function (a,b){
	if (a === b) {
		return true;
	};
	
	if ((a instanceof Array) && (b instanceof Array)) {
		var l = a.length;
		if (l == b.length) {
			while (l > 0){
				if (a[--l] != b[l]) { return false };
			};
			return true;
		};
	};
	
	return false;
};

// TODO Finegrained overridable configuration
// to be able to declare whether option should naturally
// clear from locals when new value is same as stream value etc

function Option(){ };

Option.compare = function (a,b){
	return a == b;
};

function WidgetOptions(widget){
	this._widget = widget;
	this._changes = {};
	this._dirty = false;
	this._v = 0;
};

exports.WidgetOptions = WidgetOptions; // export class 
WidgetOptions.prototype.widget = function(v){ return this._widget; }
WidgetOptions.prototype.setWidget = function(v){ this._widget = v; return this; };

WidgetOptions.prototype.raw = function (){
	return this._widget._data;
};

WidgetOptions.prototype.schema = function (){
	return this._widget._schema_ || (this._widget._schema_ = {});
};

WidgetOptions.prototype.version = function (){
	return this._v;
};

WidgetOptions.prototype.api = function (){
	return this._widget.api();
};

WidgetOptions.prototype.space = function (){
	return this._widget.space();
};

WidgetOptions.prototype.touch = function (params){
	this._v++;
	// unless we are syncing
	if (!this._widget.space().isSyncing()) {
		this._widget && this._widget.optionsDidUpdate  &&  this._widget.optionsDidUpdate(params);
	};
	return this;
};

WidgetOptions.prototype.locals = function (){
	return this._locals || (this._locals = this._widget.space().client().optionsForItem(this._widget));
};

WidgetOptions.prototype.get = function (key,locals){
	if(locals === undefined) locals = this._locals;
	if (locals == true || locals === undefined) { locals = this._locals };
	var local = locals ? locals[key] : undefined;
	var val = (local != undefined) ? local : this.raw()[key];
	return this.deserializedValueFor(this.schema()[key],val);
};

WidgetOptions.prototype.reset = function (key){
	var v_;
	if (this.locals()[key]) {
		(((v_ = this.locals()[key]),delete this.locals()[key], v_));
		this.space().touch('locals');
	};
	return this;
};

WidgetOptions.prototype.set = function (key,value){
	// support multiple
	var v_;
	if (key instanceof Object) {
		for (let v, i = 0, keys = Object.keys(key), l = keys.length, k; i < l; i++){
			k = keys[i];v = key[k];this.set(k,v);
		};
		return this;
	};
	
	let o = this.schema()[key] || {};
	let type = o.type;
	let equals = type && type.equals || Option.compare;
	var plain = (value && value.valueOf) ? value.valueOf('option') : this.serializedValueFor(this.schema()[key],value);
	var old = this.raw()[key];
	var local = this._locals ? this._locals[key] : undefined;
	let diff;
	
	if (!this.space().isEditing()) {
		let override = o && o.overridable || o.override;
		if (override) {
			if (!equals(local,plain)) {
				this.locals()[key] = plain;
				this.touch();
				this.space().touch('locals');
				if (override == 'pause' && this.space().isPlaying()) {
					this.space().timeline().pause();
				};
			};
			return this;
		};
	};
	
	if (local != undefined) {
		(((v_ = this.locals()[key]),delete this.locals()[key], v_));
	};
	
	if (equals(plain,old)) {
		return this;
	};
	
	if (type && type.diff) {
		diff = type.diff(old,plain);
		if (!diff) {
			return this;
		};
	};
	
	let akey = SCON.keyToRef(key);
	if (o.action && (plain instanceof Array)) {
		this._widget.push_(o.action,plain);
	} else if (old && diff) {
		this._widget.push_(ACTION.PATCH,[this.widget().__uid(),akey,diff]);
	} else {
		this._widget.push_(ACTION.SET,[this.widget().__uid(),akey,plain]);
	};
	return this;
};

WidgetOptions.prototype.proxy = function (key){
	var self = this;
	self._proxies || (self._proxies = {});
	return self._proxies[key] || (self._proxies[key] = {
		name: key,
		schema: self.schema()[key],
		value: function(v) { return self.get(key,v); },
		setValue: function(v) { return self.set(key,v); }
	});
};

WidgetOptions.prototype.discardLocals = function (keys){
	var v_;
	if (!this._locals) { return };
	var dirty = {};
	
	for (let o = this._locals, v, i = 0, keys1 = Object.keys(o), l = keys1.length, k; i < l; i++){
		k = keys1[i];v = o[k];if (keys && keys.indexOf(k) == -1) {
			continue;
		};
		
		if (v != this.raw()[k]) {
			dirty[k] = v;
		};
		(((v_ = this._locals[k]),delete this._locals[k], v_));
	};
	
	if (len$(Object.keys(dirty))) { this.touch(dirty) };
	return this;
	return this;
};

WidgetOptions.prototype.synced_ = function (){
	if (!this._dirty) { return this };
	this._widget.optionsDidUpdate(this._changes);
	this._changes = {};
	this._dirty = false;
	return this;
};

WidgetOptions.prototype.flush = function (){
	return this;
};

WidgetOptions.prototype.serializedValueFor = function (schema,value){
	// console.log 'serialize value',value,schema
	if (schema && schema.type == 'widget') {
		return (value && value.__uid) ? value.__uid() : value;
	} else {
		return value;
	};
};

WidgetOptions.prototype.deserializedValueFor = function (schema,value){
	// if schema
	// 	if schema:type
	
	if (schema && schema.type == 'widget') {
		return this._widget.space().__lookup(value);
	} else if (value === undefined && schema.default != undefined) {
		return schema.default;
	} else {
		return value;
	};
};
