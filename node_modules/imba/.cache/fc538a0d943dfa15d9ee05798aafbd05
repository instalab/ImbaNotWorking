function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');
var protocol$ = require('../protocol'), WIDGET = protocol$.WIDGET, CAST = protocol$.CAST, SCON = protocol$.SCON;
var TimelineCues = require('../util/TimelineCues').TimelineCues;
var AudioManager = require('../util/AudioManager').AudioManager;
var MediaGroup = require('../util/MediaGroup').MediaGroup;

var Delay = require('../../util/Delay').Delay;

var tracking = require('../tracking');
var ALLOW_BUFFERING_DELAY = 250;
var LOCAL_REF_COUNTER = 0;

/*

Responsible for keeping track of playState, timeOffset, duration etc
for a branch. A branch can have cues indicating stream-segments that
should be skipped or plated through at 10x speed etc. The real time offsets
according to the stream will never change though. The timeline takes care
of converting between relative time and timeOffsets in stream.

paused
======

playing
=======

seeking
=======

watching
========

editing
=======

recording
=========

*/


function Timeline(branch,data,options){
	this._shouldScheduleAudio = 0;
	this._branch = branch;
	this._data = data;
	this._options = options;
	this._localRef = LOCAL_REF_COUNTER++;
	this._cues = new TimelineCues(data);
	data.start || (data.start = this._cues.timeToOffset(0));
	
	if (data.end || branch.isLocked() || !branch.model().isLive()) { // no more changes
		this._initialOffset = data.start;
		this.anchorTime(this._initialOffset);
		this.setState('paused');
	} else {
		this._initialOffset = this.endOffset();
		this.anchorTime(this.endOffset());
		this.setState('watching');
	};
	// go live immediately unless the data has an end
	this;
};

exports.Timeline = Timeline; // export class 
Timeline.prototype.branch = function(v){ return this._branch; }
Timeline.prototype.setBranch = function(v){ this._branch = v; return this; };
Timeline.prototype.data = function(v){ return this._data; }
Timeline.prototype.setData = function(v){ this._data = v; return this; };
Timeline.prototype.__active = {'default': false,name: 'active'};
Timeline.prototype.active = function(v){ return this._active; }
Timeline.prototype.setActive = function(v){ this._active = v; return this; }
Timeline.prototype._active = false;
Timeline.prototype.__isAnnotating = {'default': false,name: 'isAnnotating'};
Timeline.prototype.isAnnotating = function(v){ return this._isAnnotating; }
Timeline.prototype.setIsAnnotating = function(v){ this._isAnnotating = v; return this; }
Timeline.prototype._isAnnotating = false;
Timeline.prototype.__isBuffering = {'default': false,watch: 'isBufferingDidSet',name: 'isBuffering'};
Timeline.prototype.isBuffering = function(v){ return this._isBuffering; }
Timeline.prototype.setIsBuffering = function(v){
	var a = this.isBuffering();
	if(v != a) { this._isBuffering = v; }
	if(v != a) { this.isBufferingDidSet && this.isBufferingDidSet(v,a,this.__isBuffering) }
	return this;
}
Timeline.prototype._isBuffering = false;
Timeline.prototype.__liveLatency = {'default': 0,name: 'liveLatency'};
Timeline.prototype.liveLatency = function(v){ return this._liveLatency; }
Timeline.prototype.setLiveLatency = function(v){ this._liveLatency = v; return this; }
Timeline.prototype._liveLatency = 0;
Timeline.prototype.__playbackRate = {watch: 'playbackRateDidSet','default': 1,name: 'playbackRate'};
Timeline.prototype.playbackRate = function(v){ return this._playbackRate; }
Timeline.prototype.setPlaybackRate = function(v){
	var a = this.playbackRate();
	if(v != a) { this._playbackRate = v; }
	if(v != a) { this.playbackRateDidSet && this.playbackRateDidSet(v,a,this.__playbackRate) }
	return this;
}
Timeline.prototype._playbackRate = 1;
Timeline.prototype.__loopSegment = {watch: 'loopSegmentDidSet',name: 'loopSegment'};
Timeline.prototype.loopSegment = function(v){ return this._loopSegment; }
Timeline.prototype.setLoopSegment = function(v){
	var a = this.loopSegment();
	if(v != a) { this._loopSegment = v; }
	if(v != a) { this.loopSegmentDidSet && this.loopSegmentDidSet(v,a,this.__loopSegment) }
	return this;
};
Timeline.prototype.__state = {watch: 'stateDidSet',name: 'state'};
Timeline.prototype.state = function(v){ return this._state; }
Timeline.prototype.setState = function(v){
	var a = this.state();
	if(v != a) { this._state = v; }
	if(v != a) { this.stateDidSet && this.stateDidSet(v,a,this.__state) }
	return this;
};
Timeline.prototype.cues = function(v){ return this._cues; }
Timeline.prototype.setCues = function(v){ this._cues = v; return this; };
Timeline.prototype.initialOffset = function(v){ return this._initialOffset; }
Timeline.prototype.setInitialOffset = function(v){ this._initialOffset = v; return this; };

Timeline.prototype.space = function (){
	var branch_;
	return (branch_ = this.branch()) && branch_.space  &&  branch_.space();
};

Timeline.prototype.api = function (){
	return this.space() && this.space().api();
};

Timeline.prototype.isBufferingDidSet = function (bool,prev){
	var self = this;
	self.space().dirty();
	// reanchor time now?
	self.log("isBuffering",bool,prev,prev && self.bufferingDuration());
	
	if (true) {
		// anchor time to what it was immediately before buffering changed
		self._isBuffering = prev;
		self.anchorTime();
		self._isBuffering = bool;
	};
	
	if (bool) {
		let prevDate = self._bufferingSince;
		self._bufferingSince = Date.now();
		if (!prevDate) { self._bufferingSince -= (ALLOW_BUFFERING_DELAY + 10) };
		// set and clear delay here as well?
		return setTimeout(function() { return self.space().dirty(); },ALLOW_BUFFERING_DELAY + 2);
	};
};

Timeline.prototype.isStalled = function (){
	return this.state() == 'playing' && this.isBuffering() && this.bufferingDuration() > ALLOW_BUFFERING_DELAY;
};

Timeline.prototype.timeline = function (){
	return this;
};

Timeline.prototype.log = function (){
	var api_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	if (this.api()) { return (api_ = this.api()).log.apply(api_,[].concat(['timeline'], [].slice.call(params))) };
};

Timeline.prototype.mode = function (){
	return this.state();
};

Timeline.prototype.isPlaying = function (){
	return this.playState() == 'playing';
}; // state == 'playing' or state == 'seeking'
Timeline.prototype.isPaused = function (){
	return this.playState() == 'paused';
};
Timeline.prototype.isSeeking = function (){
	return this.state() == 'seeking';
};
Timeline.prototype.isWatching = function (){
	return this.state() == 'watching';
};
Timeline.prototype.isRecording = function (){
	return this.state() == 'recording';
};
Timeline.prototype.isEditing = function (){
	return this.state() == 'editing' || this.isRecording();
};
Timeline.prototype.isLive = function (){
	return this.isWatching() || this.isEditing();
};

Timeline.prototype.play = function (){
	this.log('play',this.currentTime(),this.endTime());
	if (!(this.isPlaying()) && this.currentTime() >= this.endTime()) {
		this.seek(this.startOffset());
	};
	
	return this.setState('playing').enter();
};

Timeline.prototype.pause = function (){
	return this.setState('paused');
};
Timeline.prototype.goLive = function (){
	return this.setState('live').enter();
};

Timeline.prototype.ended = function (){
	// TODO implement 'ended' as a separate state
	this.pause();
	if (this.space()) { return this.space().view().trigger('spaceend') };
};

Timeline.prototype.playState = function (){
	return (this.state() == 'seeking') ? this._prevState : this.state();
};

Timeline.prototype.enter = function (){
	if (this.space()) {
		this.space().setTimeline(this);
	};
	return this;
};

Timeline.prototype.setState = function (state){
	// console.log "setState",state,@state
	var space_;
	var prev = this._state;
	if (prev == state) {
		return this;
	};
	
	// TODO if we try to go live - but are not allowed
	// return without changing state
	
	var offset = this.currentOffset();
	var time = this.currentTime();
	this.anchorTime(offset,time);
	this._wasLive = this.isLive();
	this._prevState = prev;
	this._state = state;
	
	this.trackPlayState();
	
	this.enterState(state,prev,offset);
	(space_ = this.space()) && space_.emit  &&  space_.emit(state,this,prev,offset,time);
	return this;
};

Timeline.prototype.enterState = function (state,prev,offset){
	this.log(("" + prev + "->" + state));
	if (this._wasLive && !(this.isLive())) this.liveLeave();
	
	if (this[("" + prev + "Leave")]) {
		this[("" + prev + "Leave")](state,offset);
	};
	
	if (this.isLive() && !this._wasLive) this.liveEnter();
	
	if (this[("" + state + "Enter")]) {
		this[("" + state + "Enter")](prev,offset);
	};
	return this;
};

Timeline.prototype.liveEnter = function (){
	return this;
};

Timeline.prototype.liveLeave = function (){
	return this;
};

Timeline.prototype.compute = function (){
	this._cues.compute();
	return this;
};

Timeline.prototype.trackPlayState = function (){
	return this.api().sendTracking(tracking.TYPES.PLAYSTATE,[this._state,this.currentTime(),this.playbackRate()]);
};

// fix addMarker and removeMarker
Timeline.prototype.addMarker = function (marker){
	this._data.cues.push(marker);
	return this.compute();
};

Timeline.prototype.removeMarker = function (marker){
	var idx = this._data.cues.indexOf(marker);
	if (idx >= 0) { this._data.cues.splice(idx,1) };
	this.compute();
	return this;
};

Timeline.prototype.span = function (){
	return this.data().end || this.branch().stream().duration();
};

Timeline.prototype.duration = function (){
	return this.endTime() - this.startTime();
};

Timeline.prototype.progress = function (){
	return this.currentTime() / this.duration();
};

Timeline.prototype.bufferingDuration = function (){
	return this._bufferingSince ? (Date.now() - this._bufferingSince) : 0;
};

Timeline.prototype.timeToOffset = function (time){
	// time += @converter.offsetToTime(data:start) if data:start
	return Math.round(this.cues().timeToOffset(time + this.startTime()));
};

Timeline.prototype.offsetToTime = function (offset){
	return Math.round(this.cues().offsetToTime(offset) - this.startTime());
};

Timeline.prototype.startOffset = function (){
	return this.data().start || 0;
};

Timeline.prototype.endOffset = function (){
	return Math.max(this.data().end || 0,this.span());
};

Timeline.prototype.startTime = function (){
	return this.data().start ? this.cues().offsetToTime(this.data().start) : 0;
};

Timeline.prototype.endTime = function (){
	return this.cues().offsetToTime(this.endOffset());
};

Timeline.prototype.clampOffset = function (offset){
	return Math.max(0,Math.min(offset,this.endOffset()));
};

Timeline.prototype.deactivate = function (){
	this.setActive(false);
	if (this.isPlaying()) this.pause();
	return this;
};

Timeline.prototype.activate = function (){
	this.anchorTime();
	this.setActive(true);
	return this;
};

Timeline.prototype.anchorTime = function (offset,time,pbr){
	if (offset == undefined) {
		offset = this.referenceOffset();
	};
	
	if (time == undefined) {
		time = this.offsetToTime(offset);
	};
	
	this._anchor = {
		ts: Date.now(),
		offset: Math.round(offset),
		elapsed: Math.round(time),
		speed: (pbr != undefined) ? pbr : this.referencePlaybackRate()
	};
	return this;
};

// the current time relative to this timeline
Timeline.prototype.currentTime = function (){
	// unless active
	// 	return offsetToTime(branch.currentOffset)
	if (this.isLive()) {
		return this.offsetToTime(this.currentOffset());
	} else if (this.state() == 'playing' && !(this.isBuffering())) {
		return this._anchor.elapsed + Math.round((Date.now() - this._anchor.ts) * this._anchor.speed);
	} else {
		return this._anchor.elapsed; // rather convert from offset?
	};
};

Timeline.prototype.currentOffset = function (){
	// unless active
	// 	return branch.currentOffset
	if (this.state() == 'scrubbing') {
		return this._scrubOffset;
	} else if (this.state() == 'watching') {
		return this.branch().stream().liveDuration() - this.liveLatency();
	} else if (this.isLive()) {
		return this.branch().stream().duration();
	} else if (this.state() == 'playing') {
		// cap based in max duration
		return Math.round(Math.min(this.timeToOffset(this.currentTime()),this.endOffset()));
	} else {
		return this._anchor.offset;
	};
};

Timeline.prototype.referenceTime = function (){
	return this.currentTime();
};

Timeline.prototype.referenceOffset = function (){
	return this.currentOffset();
};

Timeline.prototype.referencePlaybackRate = function (){
	return this.playbackRate();
};

Timeline.prototype.scrub = function (offset){
	return this.seek(offset,true);
};

Timeline.prototype.skip = function (ms){
	let time = Math.max(this.currentTime() + ms,0);
	return this.seek(this.timeToOffset(time));
};

Timeline.prototype.seek = function (offset,scrubbing){
	
	if(scrubbing === undefined) scrubbing = false;
	offset = this.clampOffset(offset);
	
	if (offset == this._seekOffset && (Date.now() - this._seekAt) < 200 && scrubbing == this._seekScrub) {
		return this;
	};
	
	this._seekScrub = scrubbing;
	this._seekOffset = offset;
	this._seekAt = Date.now();
	
	this.syncSeek(offset,scrubbing);
	this.unscheduleAudio(); // should automatically be offset
	this.branch().setCurrentOffset(offset); // hmm
	this.enter();
	if (this.isPlaying()) {
		this.scheduleAudio();
	};
	return this;
};

Timeline.prototype.seekToEnd = function (){
	var tail;
	if (tail = this.branch().stream().tail()) {
		this.seek(tail.timeOffset());
	};
	return this;
};

Timeline.prototype.syncSeek = function (offset,scrubbing){
	return this.anchorTime(offset);
};

Timeline.prototype.unscheduleAudio = function (){
	if (this._scheduledAudio) {
		AudioManager.instance().unscheduleClips(this._scheduledAudio);
		return this._scheduledAudio = null;
	};
};

Timeline.prototype.scheduleAudio = function (){
	return this;
};

Timeline.prototype.tick = function (){
	var offset = this.currentOffset();
	if (this.isPlaying() && offset >= this.endOffset()) {
		this.anchorTime(offset = this.endOffset());
		this.ended();
		// force currentOffset no?
		// branch.isLive and !isAnnotating ? goLive : pause
	};
	
	this.branch().setCurrentOffset(offset);
	// console.log "setOffset",offset
	this.space().cursor().target(this.targetEvent());
	// console.log "set target",targetEvent
	return this;
};

Timeline.prototype.targetEvent = function (){
	if (this.isLive() && !(this.isWatching())) {
		this.branch().stream().sync();
		return this.branch().head();
	} else {
		if (this.isWatching()) { this.branch().stream().sync() };
		return this.branch().stream().actionAtOffset(this.currentOffset());
	};
};

Timeline.prototype.editingLeave = function (to){
	if (to != 'recording') {
		this.space().browser().stop();
		this.space().browser().node().resetLayout();
		this.space().emit('watch');
	};
	return this;
};

Timeline.prototype.recordingLeave = function (){
	this.space().browser().stop();
	this.space().browser().node().resetLayout();
	return this.space().emit('watch');
};

Timeline.prototype.editingEnter = function (){
	return this.branch().forceToEnd();
	// TODO make sure local agent is added?
	// space.client.flushLocals
};

Timeline.prototype.recordingEnter = function (){
	return this.branch().forceToEnd();
};

Timeline.prototype.watchingEnter = function (){
	return this;
};

Timeline.prototype.pausedEnter = function (from){
	if (from == 'playing') this.registerProgress();
	return this;
};

Timeline.prototype.registerProgress = function (){
	var progress;
	let offset = this.currentOffset();
	return progress = this.currentTime() / this.duration();
};

Timeline.prototype.stats = function (){
	return {
		cid: this._branch.id(),
		state: this.playState(),
		localref: this._localRef,
		played: 0
	};
};

function AbsTimeline(){ return Timeline.apply(this,arguments) };

Imba.subclass(AbsTimeline,Timeline);
exports.AbsTimeline = AbsTimeline; // export class 
AbsTimeline.prototype.loadAudio = function (){
	let res = [];
	for (let i = 0, items = iter$(this.branch().stream().media()), len = items.length; i < len; i++) {
		res.push(AudioManager.instance().loadBufferForId(items[i].fid));
	};
	return res;
	
	// for item in cues.audio
	// 	AudioManager.instance.loadBufferForId(item[3])
};

// for WebAudio
AbsTimeline.prototype.clips = async function (){
	var self = this;
	let isLoaded = false;
	
	setTimeout(function() {
		if (!isLoaded) {
			console.log("forced buffering!");
			return (self.setIsBuffering(true),true);
		};
	},20);
	var buffers = await Promise.all(self.loadAudio());
	isLoaded = true;
	self.setIsBuffering(false);
	
	// cues.@data:audio = 
	let res = [];
	for (let i = 0, items = iter$(self.branch().stream().media()), len = items.length, item; i < len; i++) {
		item = items[i];
		let buf = buffers[i];
		let clip = [0,item.offset,Math.round(buf.duration * 1000),item.fid];
		res.push(clip);
		// AudioManager.instance.loadBufferForId(item:fid)
	};
	self.cues()._data.audio = res;
	console.log("did set audio",self.cues()._data.audio);
	return self.cues().audioclips(self.data().start,0);
};

// def setPlaybackRate val
// 	return self

AbsTimeline.prototype.buffered = function (){
	return this._buffered || (this._buffered = [[0,1]]);
};

AbsTimeline.prototype.scheduleAudio = async function (){
	let counter = ++this._shouldScheduleAudio;
	var audio = await this.clips();
	if (this._shouldScheduleAudio == counter) {
		AudioManager.instance().scheduleClips(this._scheduledAudio = audio,this.currentTime(),this.playbackRate());
	};
	return this;
};

AbsTimeline.prototype.unscheduleAudio = function (){
	++this._shouldScheduleAudio;
	if (this._scheduledAudio) {
		AudioManager.instance().unscheduleClips(this._scheduledAudio);
		this._scheduledAudio = null;
	};
	return this;
};

AbsTimeline.prototype.enterState = function (state,prev,offset){
	this.unscheduleAudio();
	return AbsTimeline.prototype.__super__.enterState.apply(this,arguments);
};

AbsTimeline.prototype.playingEnter = function (){
	if (this.space()) {
		this.space().setTimeline(this); // what if it is not active? who cares
	};
	if (!(this.isPlaying())) { return };
	this.unscheduleAudio();
	return this.scheduleAudio();
};

function PlainTimeline(){ return Timeline.apply(this,arguments) };

Imba.subclass(PlainTimeline,Timeline);
exports.PlainTimeline = PlainTimeline; // export class 
PlainTimeline.prototype.mediaGroup = function (){
	return this._mediaGroup || (this._mediaGroup = new MediaGroup(this));
};

PlainTimeline.prototype.buffered = function (){
	return this._buffered || (this._buffered = [[0,1]]);
};

PlainTimeline.prototype.playbackRateDidSet = function (rate){
	if (false) {};
	
	this.anchorTime(this.currentOffset(),this.currentTime(),rate);
	this.mediaGroup().setPlaybackRate(rate);
	return this;
};

PlainTimeline.prototype.playingEnter = function (){
	var self = this;
	if (self.space()) {
		self.space().setTimeline(self); // what if it is not active? who cares
	};
	
	if (!(self.isPlaying())) { return };
	
	for (let i = 0, items = iter$(self.branch().stream().media()), len = items.length, item; i < len; i++) {
		item = items[i];
		self.mediaGroup().addMedia(item.fid,item.offset);
	};
	
	self.setIsBuffering(true);
	let offset = self.currentOffset();
	let time = self.currentTime();
	self.anchorTime(offset,time,0);
	
	// what if we are past the audio clips?
	return self.mediaGroup().play(self.currentTime()).then(function() {
		console.log("returned from mediaGroup.play");
		self.anchorTime(offset,time,self.playbackRate());
		return (self.setIsBuffering(false),false);
	});
};

PlainTimeline.prototype.playingLeave = function (){
	return this.mediaGroup().pause();
};


function PubTimeline(branch,data,options){
	PubTimeline.prototype.__super__.constructor.apply(this,arguments);
	
	this._audioIsPlaying = false;
	this._audioIsPaused = true;
	this._audioWasPaused = 0;
	
	if (false) {};
	this;
};

Imba.subclass(PubTimeline,Timeline);
exports.PubTimeline = PubTimeline; // export class 
PubTimeline.prototype.stats = function (){
	// seconds
	var stats = {
		localref: this._localRef,
		cid: this._branch.id(),
		state: this.playState(),
		played: 0, // total number of seconds
		ranges: [] // segments played - seconds
	};
	
	var l = this._audio.played.length;
	var i = 0;
	while (i < l){
		let a = Math.round(this._audio.played.start(i));
		let b = Math.round(this._audio.played.end(i));
		if ((b - a) > 1) {
			stats.ranges.push(a,b);
			stats.played += (b - a);
		};
		i++;
	};
	
	return stats;
};

PubTimeline.prototype.playbackRateDidSet = function (rate){
	if (false) {};
	
	if (this._audio) {
		var offset = this.currentOffset();
		this._audio.playbackRate = rate;
		this.anchorTime(offset);
	};
	return this;
};

PubTimeline.prototype.isAnnotating = function (){
	return false;
};

PubTimeline.prototype.audioSrc = function (){
	return this._data.audio && AudioManager.instance().urlForId(this._data.audio);
};

PubTimeline.prototype.tick = function (){
	var offset = this.currentOffset();
	this.branch().setCurrentOffset(offset);
	this.space().cursor().target(this.targetEvent());
	return this;
};

PubTimeline.prototype.buffered = function (){
	if (this._buffered) {
		return this._buffered;
	};
	
	var parts = [];
	var dur = this.duration() / 1000;
	var ranges = this.audio().buffered;
	var len = len$(ranges);
	var i = 0;
	
	while (i < len){
		let a = ranges.start(i);
		let b = ranges.end(i);
		parts.push([a / dur,b / dur]);
		i++;
	};
	
	return this._buffered = parts;
};


PubTimeline.prototype.referenceTime = function (){
	return this._audio ? Math.round(this._audio.currentTime * 1000) : 0;
};

PubTimeline.prototype.referenceOffset = function (){
	return this.timeToOffset(this.referenceTime());
};

PubTimeline.prototype.referencePlaybackRate = function (){
	return (!this._audio || this._audio.paused) ? 0 : this._audio.playbackRate;
};

PubTimeline.prototype.audio = function (){
	if (this._audio) { return this._audio };
	this._audio = document.createElement('audio');
	this.bindAudio(this._audio);
	this._audio.src = this.audioSrc(); // + "?{Math.random}"
	this._audio.load();
	this._audio.currentTime = (this.currentTime() / 1000) || 0;
	this._audio.playbackRate = this.playbackRate();
	// should not schedule until we start playing
	return this._audio;
};

PubTimeline.prototype.enterState = function (state,prev,offset){
	this.log(("enterState " + prev + "->" + state));
	if (state != 'playing' && this._audio && !this.audio().paused && this._audioIsPlaying) {
		// if we pause - 
		this._ignorePauseEvent = true;
		this._audioWasPaused = Date.now();
		this.audio().pause();
	};
	
	return PubTimeline.prototype.__super__.enterState.apply(this,arguments);
};

// def pausedEnter
PubTimeline.prototype.playingEnter = function (from,offset){
	this.api().analytics().castPlay(this._branch.model().id);
	
	// track while playing?
	
	this.branch().enter();
	this.space().setTimeline(this);
	this.anchorTime(offset);
	
	// isBuffering will be turned off by timeupdate for now
	this.setIsBuffering(true);
	
	if (this.audio().paused) {
		AudioManager.instance().registerMedia(this.audio());
		
		if (!this._audioIsPlaying) {
			let ms = Math.round(this._anchor.elapsed || 0);
			this.setAudioTime(ms);
			return this.audio().play();
		} else {
			return this._audioShouldPlay = true;
		};
	};
};

PubTimeline.prototype.syncSeek = function (offset,scrubbing){
	var time = this.offsetToTime(offset);
	if (scrubbing) {
		return this.anchorTime(offset);
	} else {
		this.anchorTime(offset);
		// should pause the audio while seeking?
		return this.setAudioTime(time);
	};
};

PubTimeline.prototype.setAudioTime = function (ms){
	let curr = Math.round(this.audio().currentTime * 1000);
	if (curr != Math.round(ms)) {
		this.audio().currentTime = ms / 1000;
	};
	return ms;
};

PubTimeline.prototype.activate = function (){
	return PubTimeline.prototype.__super__.activate.apply(this,arguments);
};

PubTimeline.prototype.deactivate = function (){
	PubTimeline.prototype.__super__.deactivate.apply(this,arguments);
	
	if (this._audio) {
		if (!this._audio.paused) { this._audio.pause() };
		AudioManager.instance().deregisterMedia(this._audio);
	};
	
	return this;
};

PubTimeline.prototype.bindAudio = function (el){
	var self = this;
	el.widget = self;
	el.preload = 'auto';
	
	var handler = function(e) { return true; }; // console.log(e:type)
	
	el.onpause = function(e) {
		self.log(("onpause @" + self.state()));
		self._audioIsPlaying = false;
		self._audioIsPaused = true;
		
		let fromInteraction = (Date.now() - self._audioWasPaused) > 300;
		// FIXME this causes playback to pause when seeking 
		if (self.state() == 'playing' && fromInteraction) {
			if (el.currentTime == el.duration) {
				return self.ended();
			} else {
				return self.pause();
			};
		} else if (self.state() == 'playing' && !fromInteraction) {
			// log "audio should replay?"
			return el.play();
		};
	};
	
	el.onplaying = function(e) {
		// log 'onplaying'
		self._audioIsPlaying = true;
		self._audioIsPaused = false;
		self.setIsBuffering(true);
		if (self.isPaused()) { return el.pause() };
	};
	
	el.oncanplay = function() {
		// log 'oncanplay'
		return self;
	};
	
	el.onprogress = function(e) {
		// log 'onprogress'
		self._buffered = null;
		return self.space().dirty();
	};
	
	el.oncanplaythrough = function() {
		// log 'oncanplaythrough'
		// done buffering?
		return self;
	};
	
	el.onwaiting = function() {
		return self.log('onwaiting');
		// isBuffering = yes
	};
	
	el.onplay = function() {
		self.log('onplay');
		// isBuffering = yes
		if (!(self.isPlaying())) {
			return self.play();
		};
	};
	
	let tu = self._lastTimeUpdate = {
		threshold: 0,
		elapsed: [],
		timestamps: []
	};
	
	el.ontimeupdate = function(e) {
		// log "ontimeupdate {el:paused} {Math.round(el:currentTime * 1000)}"
		clearTimeout(tu.timeout);
		
		if (el.paused) {
			tu.elapsed = [];
			return tu.timestamps = [];
			// log 'timeupdate paused'
		} else {
			self.anchorTime();
			let e1 = el.currentTime * 1000;
			let t1 = Date.now();
			
			let e0 = tu.elapsed[0];
			let t0 = tu.timestamps[0];
			
			tu.elapsed.unshift(e1);
			tu.timestamps.unshift(t1);
			
			// log "ontimeupdate {Math.round((e1 - e0))} {isBuffering} {t1 - t0}",playbackRate
			
			tu.timeout = setTimeout(function() {
				// log "timed out?"
				return (self.setIsBuffering(true),true);
			},tu.threshold || 500);
			
			if (t0) {
				let elapsedRatio = (e1 - e0) / ((t1 - t0) * self.playbackRate());
				if (elapsedRatio > 0.8 && elapsedRatio < 1.2) {
					// log "progress",elapsedRatio,(e1 - e0),(t1 - t0)
					tu.threshold = Math.max(tu.threshold,20 + t1 - t0);
					return (self.setIsBuffering(false),false);
				};
			};
		};
	};
	
	el.onseeked = function(e) {
		return true;
	};
	
	el.onended = function(e) {
		if (self.state() == 'playing') {
			return self.ended();
		};
	};
	
	el.onstalled = function(e) {
		return self.log('onstalled');
	};
	
	el.onerror = handler; // what if we cannot load
	
	el.onloadedmetadata = handler;
	
	return el;
};

PubTimeline.prototype.dispose = function (){
	return this;
};

