function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
/*

The format for storing events is a highly minified msgpack array in
the following format:

[OFFSET,AGENT,TARGET,TYPE, [PARAM1,PARAM2,...] ]

1 OFFSET  Milliseconds since the previous event in the stream
2 AGENT   Session id of the actor responsible for the event
3 TARGET  Widget/File/Object target of the event
4 TYPE    An integer event code
5 PARAMS  Supplied to the event

Whenever an event has the same AGENT,TARGET,TYPE as the previous event
it will be compacted to [OFFSET,[PARAM1,PARAM2,...]]

Every type of widget can define their own custom event-codes from int 60 and up
Every widget shares event-codes 30-49

Event codes >= 100 will be trigger append

*/


var VERSION = exports.VERSION = 2;
var SPIV = exports.SPIV = 2;

// export var ROLES =
// 	GUEST: 1
// 	FOLLOWER: 2
// 	APPLICANT: 3
// 	MEMBER: 4
// 	PATRON: 6
// 	DEVELOPER: 8
// 	MODERATOR: 8
// 	MASTER: 10
// 	LEADER: 10
// 	ADMIN: 10
// 	OWNER: 12

var PEERFLAGS = exports.PEERFLAGS = {
	CONNECTED: 1
};

var ROLEFLAGS = exports.ROLEFLAGS = {
	INVITED: 1,
	ACCEPTED: 2,
	DECLINED: 4,
	GUEST: 8,
	REPORTER: 16,
	DEVELOPER: 32,
	MAINTAINER: 64,
	OWNER: 128,
	FOLLOWER: 256,
	AGENT: 512, // set when user has actually joined stream
	GOD: 1024, // FLYING SPAGHETTI MONSTER
	
	ANY: 8 + 16 + 32 + 64 + 128,
	PRIVATE: 16 + 32 + 64 + 128

// READ: 8
// WRITE: 8 + 16
// ADMIN: 8 + 16 + 32
// OWNER: 8 + 16 + 32 + 64
// BLOCKED: 1024
};

var ROLES = exports.ROLES = ROLEFLAGS;

var R = ROLEFLAGS;
var PERMISSIONS = exports.PERMISSIONS = {
	READ: R.GUEST | R.REPORTER | R.DEVELOPER | R.MAINTAINER | R.OWNER,
	WRITE: R.DEVELOPER | R.MAINTAINER | R.OWNER,
	INVITE: R.MAINTAINER | R.OWNER,
	UPDATE: R.MAINTAINER | R.OWNER,
	
	GUEST: R.GUEST | R.REPORTER | R.DEVELOPER | R.MAINTAINER | R.OWNER,
	REPORTER: R.REPORTER | R.DEVELOPER | R.MAINTAINER | R.OWNER,
	DEVELOPER: R.DEVELOPER | R.MAINTAINER | R.OWNER,
	MAINTAINER: R.MAINTAINER | R.OWNER,
	OWNER: R.OWNER,
	
	ADD_SCRIM: R.ANY
// ADD_REPO: R.ANY
};

/* MSG

Messages can be sent to and from the socket server with the following format:

[MSGCODE,PARAMS(Array),MSGREF,TIME++]

*/

var MSG = exports.MSG = {
	PING: 4,
	PONG: 5,
	RELAY: 9, // [toPeer,packet]
	RELAYED: 10, // [fromPeer,packet]
	CONNECTED: 13, // [peerObject,serverTime]
	
	FIND: 15,
	FOUND: 16,
	
	JOIN: 20,
	LEAVE: 21,
	SYNC: 22,
	SYNCED: 23,
	ERROR: 24,
	ALERT: 25,
	TRACKING: 27,
	VIEWSTATE: 28,
	
	// RTC EVENTS 50 - 99
	RTC: 49,
	ICE: 51,
	SDP: 52,
	SPECTATE: 53, // Ask to spectate a certain scrim
	CONTACT: 54, // Initiate a request 
	INVITE: 57,
	
	// all message codes from 100 > are directly mapping to a model
	// streamappend should maybe not happen that way?
	
	STREAMAPPEND: 100, // [CODE,CID,OFFSET](BYTES)
	STREAMSTATE: 101, // [CODE,CID,LENGTH]
	STREAMRANGE: 102, // [CODE,CID,OFFSET])(BYTES)
	STREAMGETRANGE: 103, // [CODE,CID,START,END]
	STREAMTRIM: 104, // [CODE,STREAMID(with version?),END]
	STREAMERROR: 105,
	STREAMFLATTEN: 106,
	STREAMEND: 107,
	
	SCRIMHOST: 110,
	SCRIMSTART: 111,
	SCRIMSTOP: 112,
	SCRIMPERSIST: 113,
	SCRIMDISPOSE: 114,
	
	AGENTPUSH: 120,
	AGENTJOIN: 121,
	AGENTLIVE: 122,
	AGENTSAVE: 123, // [fileid]
	
	ENTITYENTER: 141,
	ENTITYLEAVE: 142,
	
	GET: 150,
	
	OK: 200,
	UNAUTHORIZED: 401,
	ERR_NOTFOUND: 404,
	REQUEST_TIMEOUT: 408,
	ERR_PAYLOAD_TOO_LARGE: 413,
	ERR_LOCKED: 423,
	ERR_OUT_OF_RANGE: 416,
	ERR_OUT_OF_SYNC: 417,
	
	RELOAD_STYLES: 1000,
	UPDATES_AVAILABLE: 1001
};

// Action classes can register in this map
// as handlers for specific types
var ACTION_MAP = exports.ACTION_MAP = {};

var WIDGET_TYPE_MAP = exports.WIDGET_TYPE_MAP = {};

var GRANT = exports.GRANT = {
	SHOW: 1,
	EDIT: 2
};

var DIRTY = exports.DIRTY = {
	SIZE: 1,
	LAYOUT: 2
};

var FS = exports.FS = {
	UNSAVED: 1,
	UNTRACKED: 2,
	STAGED: 4,
	LAZY: 8,
	BINARY: 16,
	SYMLINK: 32
};

// global actions
var ACTION = exports.ACTION = {};

if (false) {};

/* WIDGET
*/

var WIDGET = exports.WIDGET = {
	CREATE: 15,
	FLAG: 17,
	UNFLAG: 18,
	UPDATE: 20,
	APPEND: 21, // Appending nested events for widget [offset,[events]]
	CONFIGURE: 25,
	BATCH: 27,
	LAYOUT: 28
};

WIDGET.FLAGS = {
	Created: 1,
	Enabled: 2,
	Deleted: 4
};

var CAST = exports.CAST = Object.create(WIDGET);
var FILE = exports.FILE = Object.create(WIDGET);
var LAYOUT = exports.LAYOUT = Object.create(WIDGET);
var AGENT = exports.AGENT = Object.create(WIDGET);
var POINTER = exports.POINTER = Object.create(WIDGET);
var SIMULATOR = exports.SIMULATOR = Object.create(WIDGET);
var CONSOLE = exports.CONSOLE = Object.create(WIDGET);
var STREAM = exports.STREAM = {};
var DOM = exports.DOM = {};

// AGENT SWITCH

AGENT.COLORS = ['blue','yellow','magenta','cyan','orange','green','red'];

// WARN only append - never change!
var KEYS = exports.KEYS = ACTION.KEY_TYPES = [
	'state', // 0
	'pointer', // 1
	'layout', // 2
	'selection', // 3
	'file', // 4
	'focus', // 5
	'hover',
	'active',
	'enabled',
	'visible',
	'busy',
	'fontSize',
	'width', // 2
	'height', // 3
	'resizing',
	'baseStyle',
	'area',
	'externaljs',
	'colspan',
	'hoverEntry',
	'viewbox', // legacy
	'class',
	'style',
	'title',
	'log',
	'info',
	'warn',
	'error',
	'alert',
	'meta',
	'function',
	'element',
	'instance',
	'udef',
	'more',
	'array',
	'div',
	'p',
	'h1',
	'h2',
	'h3',
	'h4',
	'h5',
	'h6',
	'span',
	'b',
	'i',
	'u',
	'get',
	'post',
	'put',
	'options',
	'left',
	'top',
	'contentLeft',
	'contentTop',
	'contentWidth',
	'contentheight',
	'scrollTop',
	'scrollLeft',
	'scrollWidth',
	'scrollHeight',
	'lineHeight',
	'maxWidth',
	'maxHeight',
	'head',
	'body',
	'script',
	'stylesheet',
	'href',
	'link',
	'flags'
];

for (let i = 0, items = iter$(KEYS), len = items.length; i < len; i++) {
	KEYS[items[i].toUpperCase()] = i;
};

// SCRIMBA OBJECT NOTATION
var SCON = exports.SCON = {
	parsedURICache: {},
	clone: function(item) {
		if (typeof item == 'object') {
			return JSON.parse(JSON.stringify(item));
		} else {
			return item;
		};
		// typeitem == undefined JSON.parse(JSON.stringify(item))
	},
	
	compare: function(a,b) { return JSON.stringify(a) == JSON.stringify(b); },
	keyToRef: function(k) { return (KEYS.indexOf(k) >= 0) ? KEYS.indexOf(k) : k; },
	refToKey: function(k) { return (typeof k == 'number') ? ((KEYS[k] || k)) : k; },
	paths: {},
	strToPath: function(str) {
		if (this[str]) { return this[str] };
		let parts = str.split(".");
		parts = parts.map(function(part) {
			if ((/^\-?\d+$/).test(part)) {
				return parseInt(part);
			};
			return part;
		});
		return this[str] = (len$(parts) == 1) ? parts[0] : parts;
	},
	
	pathToStr: function(path) {
		return (path instanceof Array) ? path.join(".") : String(path);
	},
	
	decodeURI: function(str) {
		var ary;
		if (!((typeof str=='string'||str instanceof String))) {
			return null;
		};
		
		let cached = this.parsedURICache[str];
		
		if (cached) {
			return cached;
		};
		
		let m = str.match(/(scrimba\:\/\/)?([\w\-]+)(\@(\d+)(\.(\d+))?)?/);
		let obj = {id: m[2],uri: str};
		if (obj.id[0] != 'e') { obj.id = ("es" + obj.id.slice(1)) };
		if (m[4]) { obj.index = parseInt(m[4]) };
		if (m[6]) { obj.offset = parseInt(m[6]) };
		
		var ary = iter$(str.substr(m[0].length).split("#"));let path = ary[0],sel = ary[1];
		
		obj.path = path;
		if (sel) {
			obj.rangeString = sel;
			obj.selection = this.decodeRangeString(sel);
		};
		
		return this.parsedURICache[str] = obj;
	},
	
	decodeRangeString: function(str) {
		let m = str.match(/L(\d+)(\:(\d+))?(-L?(\d+)(\:(\d+))?)?/).map(function(part) {
			return part ? parseInt(part) : null;
		});
		
		let l0 = m[1],c0 = m[3],l1 = m[5],c1 = m[7];
		
		// the 5th argument is a boolean that declares whether range is whole line
		
		if (!l1) {
			// a single 
			return [l0,c0 || 1,l0,c0 || 1,!c0];
		};
		
		return [l0,c0 || 1,l1,c1 || 1,!c0 && !c1];
	}
};



/* LCRange
[LINE, COL, COL_MOVE, LINE_MOVE]
*/

function LCRange(){ };

exports.LCRange = LCRange; // export class 
LCRange.lclcToArray = function (l1,c1,l2,c2){
	if (l2 == l1 && c2 == c1 || (l2 == null && c2 == null)) {
		return [l1,c1];
	} else if (l2 == l1) {
		return [l1,c1,c2 - c1];
	} else {
		return [l1,c1,c2 - c1,l2 - l1];
	};
};

LCRange.rangeToArray = function (range){
	var ary = [
		range.startLineNumber,
		range.startColumn,
		range.endColumn - range.startColumn,
		range.endLineNumber - range.startLineNumber
	];
	if (ary[3] == 0) {
		ary.pop();
		if (ary[2] == 0) { ary.pop() };
	};
	
	return ary;
	// return ary[2] == ary[3] == 0 ? ary.slice(0,2) : ary
};

LCRange.equals = function (a,b){
	return a[0] == b[0] && a[1] == b[1] && (a[2] || 0) == (b[2] || 0) && (a[3] || 0) == (b[3] || 0);
};

LCRange.optimize = function (ary){
	if (ary[3] == 0) {
		ary.pop();
		if (ary[2] == 0) { ary.pop() };
	};
	return ary;
};

LCRange.selectionToArray = function (val){
	var ary = [
		val.selectionStartLineNumber,
		val.selectionStartColumn,
		val.positionColumn - val.selectionStartColumn,
		val.positionLineNumber - val.selectionStartLineNumber
	];
	
	if (ary[3] == 0) {
		ary.pop();
		if (ary[2] == 0) { ary.pop() };
	};
	
	return ary;
	// return ary[2] == ary[3] == 0 ? ary.slice(0,2) : ary
};

ACTION.SET = 1;
ACTION.PATCH = 2;
ACTION.WIDGET_CREATE = WIDGET.CREATE = 3;

/* LCINSERT

[ int_TARGETID, int_LINE, int_COL, str_TEXT, sel_CARET? ]
Dropping CARET if CARET == [ LINE, COL + TEXT.length ]
*/

ACTION.LCINSERT = FILE.LCINSERT = 4;

/* LCDELETE
[ int_TARGETID, int_LINE, int_COL, int_LINEDELTA, int_COLDELTA, sel_CARET?]
Dropping CARET if CARET == [LINE,COL]
*/

ACTION.LCDELETE = FILE.LCDELETE = 5;

ACTION.LCEDIT = FILE.LCEDIT = 6;
ACTION.LCSELECTION = FILE.LCSELECTION = 7;

/* LAYOUT
[target: WidgetRef, ]
*/

ACTION.LAYOUT = 8;
ACTION.BROWSER_LAYOUT = 9;
ACTION.NODE_LAYOUT = 10;

ACTION.LCSELECTIONSYNC = 11; // [AgentId,Sel,[AgentId,Sel]..]
ACTION.POINTER_UPDATE = 12;

// ACTION.JOIN = 13 # agent 
// ACTION.LEAVE = 14

ACTION.CONSOLE_LOG = CONSOLE.LOG = 16;
ACTION.CONSOLE_CLEAR = CONSOLE.CLEAR = 17;
ACTION.CONSOLE_VAL_EXPAND = CONSOLE.VAL_EXPAND = 18;

ACTION.TERMINAL_SESSION_PATCH = 19;

ACTION.DOM_MUTATE = DOM.MUTATE = 21;
ACTION.DOM_EVENT = DOM.EVENT = 22;
ACTION.DOM_SCROLL = DOM.SCROLL = 23;
ACTION.DOM_SELECTION = DOM.SELECTION = 24; // [anchor: NodeRef, anchorOffset: Index, focusOffset: Index, focusNode: NodeRef]
ACTION.DOM_FOCUSIN = DOM.FOCUSIN = 25; // [NodeRef]
ACTION.DOM_HOVERIN = DOM.HOVERIN = 26; // [NodeRef]
ACTION.DOM_ACTIVEIN = DOM.ACTIVEIN = 27; // [NodeRef]

ACTION.PAGE_LOAD = 28;
ACTION.PAGE_LOADED = 29;
ACTION.PAGE_LOG = 30;
ACTION.PAGE_REQUEST = 31;
ACTION.PAGE_RESOURCE = 32;

ACTION.RECSTART = CAST.RECSTART = 33;
ACTION.RECSTOP = CAST.RECSTOP = 34;
ACTION.PING = CAST.PING = 35;
ACTION.SNAPSHOT = CAST.SNAPSHOT = 36; // [snapshot]
ACTION.FORK = CAST.FORK = 37; // [parent_id,parent_index,snapshot]
ACTION.BRANCH = CAST.BRANCH = 38;

ACTION.TRIM = 39;

ACTION.PAGE_UNLOAD = 50;

ACTION.LOCK = 100; // [socketId, userId, serverTime, agentTime]
ACTION.UNLOCK = 101;
ACTION.FREEZE = 102;

ACTION.FS_RENAME = 110;
ACTION.FS_REMOVE = 111;
ACTION.FS_MOVE = 112;
ACTION.FS_LOAD = 113;

ACTION.POINTER_HIDE = 120;


ACTION.WIDGET_FLAG = WIDGET.FLAG = 126; // deprecated
ACTION.WIDGET_UNFLAG = WIDGET.UNFLAG = 127; // deprecated
ACTION.WIDGET_APPEND = WIDGET.APPEND = 128; // deprecated

ACTION.SIM_BUILD = SIMULATOR.BUILD = 200; // deprecated
ACTION.SIM_RESULT = SIMULATOR.RESULT = 201; // deprecated
ACTION.DOM_FOCUSOUT = DOM.FOCUSOUT = 202; // [path]
ACTION.DOM_HOVEROUT = DOM.HOVEROUT = 203;
ACTION.DOM_ACTIVEOUT = DOM.ACTIVEOUT = 204;
ACTION.DOM_INSERT = DOM.INSERT = 206;
ACTION.DOM_RESET = DOM.RESET = 207; // dom reset deprecated

ACTION.LCSCROLL = FILE.SCROLL = 210; // deprecated

ACTION.REJECT = 400;

// subcomponents
CAST.WORKSPACE = -1;
CAST.CONSOLE = -2;
CAST.SIMULATOR = -3;
CAST.INSPECTOR = -4;
CAST.AGENT = -5;
CAST.STREAM = -6;
CAST.BROWSER = -7;
CAST.FS = -8;
CAST.PRIMARY_EDITOR = -9;
CAST.EXPLORER_PANEL = -10;
CAST.DEPENDENCIES_PANEL = -11;
CAST.SLIDES = -12;
CAST.SIDEBAR = -13;
CAST.PRIMARY_TERMINAL = -14;

STREAM.TRIM = 50;


CONSOLE.LOG_TYPES = {
	LOG: 60,
	WARN: 61,
	ERROR: 62,
	RESULT: 63,
	INFO: 71,
	META: 72,
	META_ERROR: 73
};

CONSOLE.TYPES = {
	MARKER: '~',
	NULL: 1,
	UNDEFINED: 2,
	ELEMENT: 3,
	FUNCTION: 4,
	INSTANCE: 5,
	ERROR: 6
};

POINTER.STATEFLAGS = {
	LEFT_BUTTON: 1, // : Left button
	RIGHT_BUTTON: 2, // : Right button
	MIDDLE_BUTTON: 4, // : Wheel button or middle button
	HIDDEN: 8,
	TRANSITION: 16,
	HIGHLIGHT: 32,
	CTRL: 64,
	ALT: 128,
	SHIFT: 256
};

POINTER.FLAGS = {
	Created: 1,
	Enabled: 2,
	Deleted: 4,
	Visible: 8
};

POINTER.STYLES = {
	DEFAULT: 0,
	ROW: 1,
	SMALL_FLIPPED: 2
};


var POINTERMASK = exports.POINTERMASK = {
	LEFT_BUTTON: 1, // : Left button
	RIGHT_BUTTON: 2, // : Right button
	MIDDLE_BUTTON: 4 // : Wheel button or middle button
};

var LAYOUTMASK = exports.LAYOUTMASK = {
	SCALED: 1,
	BOUNDLESS: 2,
	SCALEX: 4,
	SCALEY: 8,
	STICKY: 16
};

/* FILE
*/


DOM.MUTS = {
	RESET: 1, // []
	INSERT: 2, // [parent: NodeRef, insertAt: Index, node: Node]
	// INSERT is deprecated, but still implemented in player
	
	REMOVE: 3, // [node: NodeRef]
	INIT: 4, // [body: Node]
	
	INSERT_AFTER: 5, // deprecated
	INSERT_ADJACENT: 6, // [rel: NodeRef, pos: Pos, node: Node]
	
	SETATTR: 10, // [node: NodeRef, key: KeySymbol, value: string]
	SETPROP: 11, // [node: NodeRef, key: KeySymbol, value: string]
	SETTEXT: 12, // [node: NodeRef, content: TextPatch]
	
	// Node:
	// - number: exisiting node index
	// - string: serialized node (can be multiple elements)
	// - {text: ""}: plain text
	// - array: nested
	
	// KeySymbol:
	// - string: literal key
	// - integer: entry in M.NAME_MAP
	
	POS: ['beforebegin','afterbegin','beforeend','afterend'],
	
	NAMES: {
		class: 1,
		value: 2,
		checked: 3,
		style: 4
	},
	
	NAME_MAP: {
		1: 'class',
		2: 'value',
		3: 'checked',
		4: 'style'
	}
};


var msgpack = require('msgpack-lite');
var Bufferish = exports.Bufferish = msgpack.Decoder.prototype.bufferish;

var pack = (function($mod$){
	$mod$.concat = function (buffers){
		"use strict";
		var self = this || $mod$;
		return Bufferish.concat(buffers);
	};
	
	$mod$.encode = function (){
		"use strict";
		var self = this || $mod$;
		var $0 = arguments, i = $0.length;
		var chunks = new Array(i>0 ? i : 0);
		while(i>0) chunks[i-1] = $0[--i];
		var encoder = new (msgpack.Encoder)({});
		for (let i = 0, items = iter$(chunks), len = items.length; i < len; i++) {
			encoder.write(items[i]);
		};
		return encoder.read();
	};
	
	$mod$.isBinary = function (value){
		"use strict";
		var self = this || $mod$;
		if (true && (value instanceof Buffer)) {
			return true;
		};
		
		if ((value instanceof ArrayBuffer) || (value instanceof Uint8Array)) {
			return true;
		};
		
		return false;
	};
	return $mod$;
})({})
exports.pack = pack;
