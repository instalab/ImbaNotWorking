function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };

var db$ = require("./db"), db = db$.db, rdb = db$.rdb;
var API = require('./api').API;
var Resource = require('../store/Resource').Resource;


	
	API.prototype.preload = function (item,collection){
		if(collection === undefined) collection = this._preloads;
		if (item instanceof Array) {
			// should it be a map instead?
			for (let j = 0, items = iter$(item), len = items.length, i; j < len; j++) {
				i = items[j];
				if (i) { this.preload(i,collection) };
			};
			return collection;
		};
		
		if (collection.indexOf(item) < 0) {
			if (item instanceof Resource) {
				collection.push(item);
				if (item.dependsOn) {
					this.preload(item.dependsOn(),collection);
				};
			};
		};
		return collection;
	};
	
	API.prototype.syncFind = async function (query,versions){
		if(versions === undefined) versions = {};
		var t = Date.now();
		var models = [];
		var selects = [];
		var sdb = this.db();
		var uid = this.uid();
		var newVersions = {};
		var mainModel;
		
		// check if we have the same last-version as server?
		// could be cached - or only check v for the relevant tables per query
		var getSeq = async function(name) {
			var seq = await db.table(("" + name + "_v_seq")).select('last_value').first();
			return newVersions[name] = parseInt(seq.last_value);
		};
		
		// load last sequence ids
		// should be enough to just return the local last-version according to serverdb
		await Promise.all((function() {
			let res = [];
			for (let v, i = 0, keys = Object.keys(versions), l = keys.length, k; i < l; i++){
				k = keys[i];v = versions[k];res.push(getSeq(k));
			};
			return res;
		})());
		
		var q = function(table,o) {
			if(o === undefined) o = {};
			let v = versions[table];
			let sel = db.table(table);
			sel = o.full ? sel.select() : sel.select('id','v');
			if (v > 0) { sel = sel.where('v','>',v) };
			selects.push(sel);
			return sel;
		};
		
		if (query == 'home') {
			// q('spaces',db.where(privacy: 'public', type: 'tutorial'))
			q('playlists').where({privacy: 'public'}).whereNotNull('featured_at').orderBy('featured_at','desc').limit(8);
			q('spaces').where({type: 'tutorial',privacy: 'public'}).whereNotNull('published_at').orderBy('published_at','desc').limit(16);
			q('groups').where({type: 'course'}).orderBy('created_at','desc').limit(16); // .whereNotNull('published_at')
			q('users').where('karma','>',100).limit(16);
			uid && q('viewings').where({uid: uid}).orderBy('updated_at','desc').limit(16);
			// should include spaces for these viewings no?
			// q(:spaces).where(type: 'tutorial', privacy: 'public').whereNotNull('published_at').whereNotNull('featured_at').orderBy('published_at','desc').limit(16)
			// if uid # not needed on frontpage anymore
			//	q(:spaces).where(uid: uid).whereNotNull('archived_at')
			//	q(:playlists).where(uid: uid)
		} else if (query == 'viewings') {
			if (!uid) {
				return [];
			};
			
			q('viewings').where({uid: uid}); // .orderBy('updated_at','desc')
		} else if (query == 'templates') {
			q('spaces').where({type: 'template',privacy: 'public'}).whereNull('archived_at');
		} else if (query[0] == 'user') {
			let val = query[1];
			let field;
			if (val[0] == '@') {
				field = 'username';
				val = val.slice(1);
			} else {
				field = 'id';
			};
			
			// sdb.get(userId)
			
			let user = mainModel = sdb.users().first(function(item) { return item[field] == val; });
			
			if (!user) {
				console.log("return without user");
				return [];
			};
			
			// models.push(sdb.get(query[1]))
			q('users').where({id: user.id});
			q('spaces').where({uid: user.id});
			q('playlists').where({uid: user.id});
			q('groups').where({creator_id: user.id});
		} else if (query[0] == 'cast') {
			let pid = query[2];
			let cast = mainModel = sdb.spaces().get(query[1]);
			
			if (!cast || cast.CODE != 200) {
				return [];
			};
			
			if (cast.type != 'template') {
				// should only fetch public subcasts, or our own
				if (this.isMod()) {
					q('spaces').where({parent_id: cast.id,archived_at: null});
				} else {
					uid && q('spaces').where({parent_id: cast.id,uid: uid});
					q('spaces').where({parent_id: cast.id,privacy: 'public',archived_at: null});
				};
			};
			
			q('messages').where({cid: cast.id});
			
			if (cast.gid) {
				q('groups').where({id: cast.gid});
				
				if (uid) {
					q('memberships').where({gid: cast.gid,uid: uid});
				};
			};
			
			// always prefetch the parent as well
			q('spaces').where({id: cast.parent_id});
			
			if (cast.type == 'note') {
				q('spaces').where({parent_id: cast.parent_id,uid: uid});
				q('messages').where({cid: cast.parent_id});
			};
			
			// maybe include playlists where this is a member?
			
			if (pid) {
				q('playlists').where({id: pid});
			};
			
			if (cast.pid) {
				q('playlists').where({id: cast.pid});
			};
		} else if (query[0] == 'playlist') {
			mainModel = sdb.playlists().get(query[1]);
		} else if (query[0] == 'topic') {
			mainModel = sdb.topics().get(query[1]);
			// q(:spaces).where(gid: query[1])
		} else if (query[0] == 'group') {
			// loading everything while developing
			mainModel = sdb.get(query[1]);
			q('spaces').where({gid: query[1]});
			q('playlists').where({gid: query[1]});
			q('groups').where({type: 'course'}).whereNotNull('coverart').orderBy('created_at','desc').limit(16);
			
			// TODO all users should not get all memberships(!)
			if (uid) {
				q('memberships').where({gid: query[1],uid: uid});
			};
			// console.log "fetching group!"
		};
		
		if (mainModel) {
			// console.log "preload for mainModel",mainModel.CODE,mainModel:id
			this.preload(mainModel,models);
		};
		
		var fetches = await Promise.all(selects);
		
		for (let i = 0, ary = iter$(fetches), len = ary.length, items; i < len; i++) {
			items = ary[i];
			for (let j = 0, array = iter$(items), len = array.length; j < len; j++) {
				let model = sdb.get(array[j].id);
				this.preload(model,models);
			};
		};
		
		// after preloading - fetch the linked resources as well?
		// should be able to do multiple levels of fetching?
		await this.db().autofetch();
		
		console.log("prefetched",query,Date.now() - t);
		return [(mainModel ? mainModel.id : null),models,newVersions];
	};
	
	API.prototype.syncQuery = function (ns,query,v){
		var q = db.table(ns);
		
		if (query instanceof Object) {
			q = q.where(query);
		} else if (query == 'all') {
			if (ns == 'users') {
				q = q.where({s: 1});
			} else if (ns == 'spaces') {
				q = q.whereNotNull('published_at');
			};
		};
		
		return q;
	};
	
	API.prototype.sync = async function (stores){
		var self = this;
		var time = Date.now();
		console.warn("Api#sync is deprecated",stores);
		// should be able to update the request.session with latest sync-info
		// should sync directly with self.db instead?
		
		var filters = {};
		var uid = self.uid() || 'anon';
		var sdb = self.db();
		
		var models = [];
		
		var queries = {
			users: 'v > ? AND (s = 1  or id = ?)'
		// spaces: "v > ?"
		};
		
		filters.spaces = function(item) {
			return item.privacy == 'public' || item.uid == uid;
		};
		
		filters.users = function(item) {
			// delete item:github_profile
			// delete item:github_user_id
			// delete item:email
			return item.s || item.id == uid;
		};
		
		var getSeq = function(name) {
			return db.table(("" + name + "_v_seq")).select('sequence_name','last_value').first();
		};
		
		var promises = stores.map(async function(req) {
			// dont sync branches in the future
			// if name == 'branches'
			var name = req[0];
			
			if (name == 'mediafiles' || name == 'actions' || name == 'files') {
				return Promise.resolve(0);
			};
			
			var query = req[1];
			var type = (((typeof query=='string'||query instanceof String)) ? query : JSON.stringify(query));
			
			var v0 = req[2] || 0;
			var seq = await getSeq(name);
			
			var v1 = parseInt(seq && seq.last_value);
			
			if (v0 == v1) {
				return v1;
			};
			
			var dbq = self.syncQuery(name,query,v0,v1);
			
			// var q = db.table(name)
			// if queries[name]
			//	q = q.whereRaw(queries[name],[v,uid])
			// else
			dbq = dbq.andWhere('v','>',v0);
			
			return dbq.orderBy('v','desc').then(function(res) { // here we go
				res = res.map(function(res) { return sdb.get(res.id); });
				models.push.apply(models,res);
				// if filters[name]
				// 	res = res.filter(filters[name])
				// res = res.map do ||
				// SELECT sequence_name, last_value FROM table_v_seq;
				return v1;
				// [name,query,v1,res]
				// {store: name, data: res, v: v1, type: type}
			});
		});
		
		var versions = await Promise.all(promises);
		
		// Remove duplicates first
		var uniques = models.filter(function(item,i) {
			return models.indexOf(item) == i;
		});
		
		// now preload related items for models - could be many?
		var allItems = self.preload(uniques,[]);
		
		var patch = [allItems,versions];
		console.log("sync took",Date.now() - time,versions);
		
		return patch;
	};

