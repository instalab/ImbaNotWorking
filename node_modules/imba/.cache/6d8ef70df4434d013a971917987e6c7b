function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var protocol$ = require('../protocol'), ACTION = protocol$.ACTION, FS = protocol$.FS;
var semver = require('semver');
var LongPromise = require('../../util/LongPromise').LongPromise;

// Wrapper for communicating with a scrimba host (spawned by CLI)
// on a machine, reachable through websocket - usually ws://localhost:port

// This is the actual host representing the real connection
// In playback, host is not a concept - the terminal, files etc are synced
// through the stream
function Machine(branch,o){
	if(o === undefined) o = {};
	this._branch = branch;
	this._options = Object.assign(o,branch.model().cli() || {});
	this._port = o.port || 48001;
	this._proxyPort = o.proxy || (this._port + 1);
	this._url = ("ws://127.0.0.1:" + (this._port) + "/socket");
	this._terminals = {};
	this._promise = new LongPromise();
	this.connect();
	this;
};

exports.Machine = Machine; // export class 
Machine.prototype.handling = function(v){ return this._handling; }
Machine.prototype.setHandling = function(v){ this._handling = v; return this; };
Machine.prototype.branch = function(v){ return this._branch; }
Machine.prototype.setBranch = function(v){ this._branch = v; return this; };
Machine.prototype.state = function(v){ return this._state; }
Machine.prototype.setState = function(v){ this._state = v; return this; };
Machine.prototype.version = function(v){ return this._version; }
Machine.prototype.setVersion = function(v){ this._version = v; return this; };
Machine.prototype.ws = function(v){ return this._ws; }
Machine.prototype.setWs = function(v){ this._ws = v; return this; };
Machine.prototype.port = function(v){ return this._port; }
Machine.prototype.setPort = function(v){ this._port = v; return this; };
Machine.prototype.proxyPort = function(v){ return this._proxyPort; }
Machine.prototype.setProxyPort = function(v){ this._proxyPort = v; return this; };

Machine.prototype.proxyPort = function (){
	
};

Machine.prototype.space = function (){
	return this.branch().space();
};

Machine.prototype.api = function (){
	return this.space().api();
};

Machine.prototype.fs = function (){
	return this.space().fs();
};

Machine.prototype.model = function (){
	return this.branch().model();
};

Machine.prototype.log = function (){
	var api_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (api_ = this.api()).log.apply(api_,[].concat(['machine'], [].slice.call(params)));
};

Machine.prototype.alert = function (msg,type){
	if(type === undefined) type = 'error';
	return this.space().view().uxa().flash(msg,type);
};

Machine.prototype.connect = function (){
	var self = this;
	if (self.ws()) { return self._promise };
	self.setWs(new WebSocket(self._url));
	console.log("connecting to machine!!");
	
	self.ws().onerror = function(e) {
		self.log('onerror',e);
		return self.alert('Error when connecting to CLI');
	};
	
	self.ws().onmessage = function(e) {
		// console.log 'Host.onmessage',e
		try {
			let message = JSON.parse(e.data);
			return self.handle(message);
		} catch (e) {
			return self.log("error",e);
		};
		// some default format for communicating
	};
	
	self.ws().onclose = function(e) {
		return self.log('onclose',e);
	};
	
	self.ws().onopen = function(e) {
		return self.log('onopen',e);
	};
	return self._promise;
};

Machine.prototype.send = function (params){
	params = JSON.stringify(params);
	return this.ws().send(params);
};

Machine.prototype.handle = function (message){
	this._handling = message;
	let ev = message.type;
	let data = message.data;
	// console.log "host {ev}"
	// if ev == 'walk'
	//	syncEntries(message:entries,space.fs)
	// el
	if (ev == 'connect') {
		this.connected(message);
	} else if (ev == 'fs.change') {
		this.syncEntry(message.entry,message);
	} else if (ev == 'fs.add') {
		this.syncEntry(message.entry,message);
	} else if (ev == 'fs.read') {
		this.syncEntry(message.entry,message);
	} else if (ev == 'terminal.open') {
		this;
	} else if (ev == 'terminal.change') {
		let widget = this.space().__lookup(message.ref);
		if (widget && data) {
			// should make sure all of these happens with same timestamp in stream
			widget.setReadyState('open');
			widget.setScreenIndex(data.screenIndex);
			widget.setWidth(data.width);
			widget.setHeight(data.height);
			widget.setCaretRow(data.row);
			widget.setCaretCol(data.column);
			
			if (data.patch) {
				let patch = [widget.id(),data.patch];
				widget.push_(ACTION.TERMINAL_SESSION_PATCH,patch);
				widget.setScrollTop(widget.autoScrollTop());
			};
		};
	} else if (ev == 'proxy.resource') {
		this.space().browser().push_(ACTION.PAGE_RESOURCE,[data]);
	};
	return this._handling = null;
};

Machine.prototype.connected = async function (data){
	this.model().set({title: data.project,git: data.git});
	
	// get proxyPort etc?
	this.setVersion(data.version || '0.1.0');
	var minVersion = this.api().manifest().cliDependency;
	
	if (!semver.satisfies(this.version(),minVersion)) {
		// space.view.alert("Please update scrimba cli (npm -g update scrimba) to 0.2.0")
		this.alert(("Please update scrimba cli to " + minVersion + " (npm -g update scrimba)"));
		return;
	};
	
	this.syncEntries(data.entries,this.space().fs());
	
	// we always create one terminal-session after connecting
	let session = this.space().terminal().createSession();
	this.space().inspector().setCurrentPane(session);
	this.space().inspector().setVisible(true);
	
	if (data.proxy) {
		this.space().browser().setProxy(data.proxy);
	};
	
	// add git details for testing
	
	
	// just for testing
	// let agentData = SCON.clone(space.me.@data)
	// let agentData = {}
	// agentData:pid = space.api.pid
	// agentData:host = yes
	// agentData:machine = yes
	// agentData:token = space.spectator.token
	// agentData:offline = no
	
	// why create the agent from the machine?
	// seems natural to create in space/branch
	// let agent = space.createAgent(agentData)
	// space.trunk.me = agent
	// space.agent.follows = agent
	// space.me = agent
	
	this.space().emit('connected',this);
	this._promise.resolve(this);
	
	if (this.space().model().isLocal() && false) {
		console.log("saving from machine(!)");
		await this.space().model().save();
		return App.router().replace(this.space().model().url());
	};
};


Machine.prototype.syncEntries = function (entries,par){
	// console.log "sync files",entries
	// add syncer directly to the directories no?
	if(par === undefined) par = this.space().fs();
	for (let i = 0, items = iter$(entries), len = items.length, entry; i < len; i++) {
		entry = items[i];
		if (entry.type == 'dir') {
			let dir = par.mkdir(entry.name,entry);
			this.syncEntries(entry.entries,dir);
		} else {
			let file = par.mkfile(entry.name,entry);
			// console.log 'made file!',file
		};
	};
	return;
};

Machine.prototype.syncEntry = function (data){
	var dir;
	let entry = this.fs().find(data.path);
	let par;
	console.log('syncing file',entry,data);
	if (data.type == 'dir') {
		if (entry) {
			if (data.entries) { return this.syncEntries(data.entries,entry) };
		} else {
			// need the full path?!?
			return dir = this.fs().mkdirp(data.path,data);
		};
	} else if (data.type == 'file') {
		if (entry) {
			if (data.body) { return entry.syncEntry(data) };
		} else {
			let dir = data.path.split('/').slice(0,-1).join("/");
			console.log('sync new file',dir,data);
			par = dir ? this.fs().mkdirp(dir) : this.fs();
			return entry = par.mkfile(data.name,data);
		};
	};
};

Machine.prototype.pushEntry = function (entry){
	if (this.handling()) { return };
	this.send({type: 'fs.change',entry: entry});
	return this;
};

Machine.prototype.mkdir = function (entry){
	if (this.handling()) { return };
	return this.send({type: 'fs.mkdir',entry: entry});
};

Machine.prototype.mkfile = function (entry){
	if (this.handling()) { return };
	return this.send({type: 'fs.mkfile',entry: entry});
};

Machine.prototype.mv = function (from,to){
	if (this.handling()) { return };
	return this.send({type: 'fs.mv',src: from,dest: to});
};

Machine.prototype.fetch = function (entry,widget){
	console.log("fetchPath",entry,widget);
	this.send({type: 'fs.fetch',entry: entry});
	return this;
};

Machine.prototype.connectTerminalSession = function (session){
	this.send(
		{type: 'terminal.open',
		ref: session.id(),
		data: {
			id: session.id(),
			width: session.width(),
			height: session.height()
		}}
	);
	return this;
};

Machine.prototype.terminalSessionWrite = function (terminal,write){
	let msg = {
		type: 'terminal.write',
		ref: terminal.id(),
		data: write
	};
	return this.send(msg);
};

Machine.prototype.gitCommit = function (options){
	return this.send({type: 'git.commit',data: options});
};
