var assigner = function(item,data) {
	for (let v, i = 0, keys = Object.keys(data), l = keys.length, k; i < l; i++){
		k = keys[i];v = data[k];item[k] = v;
	};
	return;
};

var MASK = exports.MASK = {
	NEVER: 0,
	ALWAYS: 1,
	OWN: 2,
	NOTNIL: 4
};

var ACCESS = exports.ACCESS = {
	NONE: 0,
	READ: 1,
	WRITE: 2,
	INS: 4,
	PUT: 8,
	DEL: 16,
	ALL: 1 | 2 | 4 | 8 | 16,
	
	read: 1,
	write: 2,
	ins: 4,
	put: 8,
	edit: 8,
	del: 16
};

function Resource(data){
	Object.defineProperty(this,'_cache',{value: {},enumerable: false});
	assigner(this,data);
	this;
};

exports.Resource = Resource; // export class 
Resource.canPut = function (data,prev,auth){
	console.log("canPut",data.id,auth && auth.uid);
	// dont let other users update objects
	if (auth && prev.uid && (auth.uid != prev.uid) && !auth.isMod) {
		return false;
	};
	
	return true;
};

Resource.prototype.notifyChannels = function (data){
	return 'all';
};

Resource.prototype.patch = function (data){
	assigner(this,data);
	return this;
};

Resource.prototype.db = function (){
	// global instance of db?
	return this._db || App.api().db();
};

Resource.prototype.api = function (){
	return this._db.api();
};

Resource.prototype.isLocal = function (){
	return this.v == -1 || this.v == -2;
};

// is this resource local and not even persisted?
Resource.prototype.isPersisted = function (){
	return this.v >= -1;
};

Resource.prototype.permissions = function (user){
	if (user && (this.uid == user.id || user.isMod())) {
		return ACCESS.ALL;
	} else if (this.privacy == 'private') {
		return ACCESS.NONE;
	} else {
		return ACCESS.READ;
	};
};

Resource.prototype.can = function (user,action){
	return this.permissions(user) & (ACCESS[action] || action);
};

Resource.prototype.update = function (data){
	if (false) {};
	
	data.id = this.id;
	return this._store.put(data);
};

Resource.prototype.save = function (data){
	if (this.isLocal()) {
		// what if we want to keep it local?
		if (data) { assigner(this,data) };
		return this._store.ins(this);
	} else {
		return data ? this.update(data) : Promise.resolve(this);
	};
};

Resource.prototype.del = function (hard){
	if(hard === undefined) hard = false;
	if (hard && this.isLocal()) {
		this._store.del(this);
	};
	return this;
};

Resource.prototype.saveLocal = function (){
	return this._store.saveLocal(this);
};

Resource.prototype.fetch = async function (){
	var item = await this._store.fetch(this);
	return item;
};

Resource.prototype.dependsOn = function (){
	return null;
};

Resource.prototype.toJSON = function (){
	return this.serialize();
};

Resource.prototype.beforeSerialize = function (){
	return null;
};

// TODO formalize the serializer and the different masks it can
// contain for users
Resource.prototype.serialize = function (scop){
	var s = this.constructor._serializer;
	this.beforeSerialize();
	var uid;
	
	if (true) {
		scop || (scop = this._db.scope());
		uid = scop.uid;
		
		if (scop.action && s) {
			s = s[scop.action] || s;
		};
		
		if (!this.can(scop.user,ACCESS.READ)) {
			return {v: this.v,id: this.id,CODE: 403};
		};
	};
	
	if (false) {};
	
	// what about caching the jsonified version?
	// var s = self:constructor.@serializer
	var obj = {};
	var id = this.id;
	for (let o = this, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];if (s && s[k] !== undefined) {
			if (v === undefined) {
				v = null;
			};
			if (s[k] == MASK.NEVER) {
				continue;
			};
			if (s[k] & MASK.OWN) {
				if (!(id == uid || (this.uid && this.uid == uid))) {
					continue;
				};
			};
		} else if (k[0] == '_' || v == undefined) {
			continue;
		};
		
		obj[k] = v;
	};
	return obj;
};
