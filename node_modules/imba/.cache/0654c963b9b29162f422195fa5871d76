function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var protocol$ = require('../protocol'), ACTION = protocol$.ACTION, POINTERMASK = protocol$.POINTERMASK;
var PointerUpdate = require('../core/StreamAction').PointerUpdate;

function PointerTracker(space){
	var self = this;
	self._space = space;
	self._handler = function(e) { return self.onevent(e); };
	self._intercept = ['mousemove','mousedown','mouseup'];
	self._last = Date.now();
	self._captures = false;
	self._evoptions = {passive: true,capture: false};
	self._mask = 0;
	self._hover = null;
	space.on('browserevent',function(e) { return self.onbrowserevent(e); });
	self;
};

exports.PointerTracker = PointerTracker; // export class 
PointerTracker.prototype.space = function(v){ return this._space; }
PointerTracker.prototype.setSpace = function(v){ this._space = v; return this; };
PointerTracker.prototype.hover = function(v){ return this._hover; }
PointerTracker.prototype.setHover = function(v){ this._hover = v; return this; };

PointerTracker.prototype.lockedOnTarget = function(v){ return this._lockedOnTarget; }
PointerTracker.prototype.setLockedOnTarget = function(v){ this._lockedOnTarget = v; return this; };

PointerTracker.prototype.agent = function (){
	return this.space().agent();
};

PointerTracker.prototype.isActive = function (){
	return this._active;
};

PointerTracker.prototype.start = function (){
	if (this._active) { return }; // or !agent.isRecording
	for (let i = 0, items = iter$(this._intercept), len = items.length; i < len; i++) {
		this.space().view().dom().addEventListener(items[i],this._handler,this._evoptions);
	};
	this._active = this._ts = Date.now();
	return this;
};

PointerTracker.prototype.stop = function (){
	if (!this._active) { return };
	for (let i = 0, items = iter$(this._intercept), len = items.length; i < len; i++) {
		this.space().view().dom().removeEventListener(items[i],this._handler,this._evoptions);
	};
	this._active = false;
	return this;
};

PointerTracker.prototype.targetForElement = function (el){
	var hover = null;
	var isInside = false;
	var origTarget = el;
	// if simulator is front and center - the pointer should
	// stay with it. Hardcoded exception - should generalize?
	// if sim and (e:simX != undefined or sim.node.shouldCapturePointer)
	//	targetNode = sim.node
	while (el){
		if (el._tag && el._tag.targetForPointer) {
			if (hover = el._tag.targetForPointer(origTarget)) {
				break;
			};
		};
		el = el.parentNode;
	};
	return hover;
};

PointerTracker.prototype.onbrowserevent = function (e){
	var browser = this.space().browser()._node;
	
	var layout = this.space().view().layoutForNode(browser);
	
	var data = {
		type: e.type,
		buttons: e.buttons,
		spaceX: layout[1] + e.clientX * (layout[2] / e.windowWidth), // browser.dom:offsetLeft
		spaceY: layout[0] + e.clientY * (layout[3] / e.windowHeight), // browser.dom:offsetTop
		spaceTarget: browser,
		shiftKey: e.shiftKey
	};
	return this.onevent(data);
};

PointerTracker.prototype.onevent = function (e){
	var rec = this.space().recording();
	
	// if !rec or rec.state != 'started'
	// 	# only track when recording
	// 	return
	
	var now = Date.now();
	var elapsed = now - this._last;
	// console.log "PointerTracker.{e:type}",elapsed
	var vp = this.space().view().box();
	var x = (e.spaceX != null) ? ((e.spaceX)) : ((e.clientX - vp.left));
	var y = (e.spaceY != null) ? ((e.spaceY)) : ((e.clientY - vp.top));
	var hover = this.lockedOnTarget() || e.spaceTarget || this.targetForElement(e.target);
	
	x = Math.round(x);
	y = Math.round(y);
	
	var trigger = (x != this._x || y != this._y);
	
	if (!rec && !e.shiftKey) {
		return;
	};
	
	if (e.type != 'mousemove') {
		// space.api.log :mouse, e:type, e
		trigger = true;
	};
	
	this._mask = e.buttons;
	
	if (hover != this._hover) {
		this.setHover(hover);
		trigger = true;
	};
	
	if (trigger) {
		this._x = x;
		this._y = y;
		this.stamp();
		return this._last = now;
	};
	// @last = now
};

PointerTracker.prototype.stamp = function (){
	var frame = {
		x: this._x,
		y: this._y,
		flags: this._mask,
		hover: (this._hover ? this._hover.sref() : null)
	};
	this.push(frame,this._hover);
	return this;
};

PointerTracker.prototype.push = function (frame,target){
	// console.log "push pointerFrame",frame
	// return self
	if (this.space().isEditing()) {
		// space.branch.stream.pointer.addFrame(frame)
		// now ensure layout tracking
		if (target) {
			this.space().view().pushNodeLayout(target);
		};
		var action = PointerUpdate.build(frame);
		action._branch = this.space().branch();
		this.space().branch().addLocalEvent(action);
		// space.view.@pointer.keyframe = action
		this.space().view()._pointer.render();
		// agent.push_(ACTION.POINTER,null,frame)
	};
	return this;
};

PointerTracker.prototype.tick = function (){
	return this;
};
