function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');

// use Struct?

function Segment(data,owner){
	this._data = data;
	this._data._cue = this;
	this._owner = owner;
	this._version = 0;
};

exports.Segment = Segment; // export class 
Segment.deserialize = function (data,owner){
	return new this(data,owner);
};

Segment.prototype.version = function(v){ return this._version; }
Segment.prototype.setVersion = function(v){ this._version = v; return this; };
Segment.prototype.data = function(v){ return this._data; }
Segment.prototype.setData = function(v){ this._data = v; return this; };
Segment.prototype.__disabled = {watch: 'dirty',name: 'disabled'};
Segment.prototype.disabled = function(v){ return this._disabled; }
Segment.prototype.setDisabled = function(v){
	var a = this.disabled();
	if(v != a) { this._disabled = v; }
	if(v != a) { this.dirty && this.dirty(v,a,this.__disabled) }
	return this;
};

Segment.prototype.span = function (){
	return this.end() - this.start();
};

Segment.prototype.start = function (){
	return this._data[1];
};

Segment.prototype.span = function (){
	return this._data[2];
};

Segment.prototype.end = function (){
	return this.start() + this._data[2];
};

Segment.prototype.duration = function (){
	return this._data[3] || 0;
};

Segment.prototype.options = function (){
	return this._data[4];
};

Segment.prototype.setOptions = function (o){
	this._data[4] = o;
	return this.dirty();
};

Segment.prototype.dirty = function (){
	this._version++;
	this._owner && this._owner.dirty  &&  this._owner.dirty();
	return this;
};

Segment.prototype.moveTo = function (value,anchor){
	// let start = value + span * anchor
	// let end = value + span * (1 - anchor)
	if(anchor === undefined) anchor = 0;
	this._data[1] = Math.round(value - this.span() * anchor);
	// @data[2] = Math.round(end) - 
	return this.dirty();
};

Segment.prototype.anchor = function (anchor){
	if(anchor === undefined) anchor = 0;
	return this.start() + this.span() * anchor;
};

Segment.prototype.contains = function (offset){
	if ((typeof offset=='number'||offset instanceof Number)) {
		return offset >= this.start() && this.end() >= offset;
	} else if (offset instanceof Segment) {
		return offset.start() >= this.start() && this.end() >= offset.end();
	} else {
		return false;
	};
};

Segment.prototype.setStart = function (value,move){
	if(move === undefined) move = false;
	if (this.start() != value) {
		let change = (this.start() - value);
		this._data[1] = value;
		if (!move) { this._data[2] += change };
		this.dirty();
	};
	return this;
};

Segment.prototype.setEnd = function (value,move){
	if(move === undefined) move = false;
	if (this.end() != value) {
		this._data[2] = Math.max(0,value - this.start());
		this.dirty();
	};
	return this;
};

Segment.prototype.setSpan = function (value){
	if (this.span() != value) {
		this._data[2] = value;
		this.dirty();
	};
	this;
	return this;
};

Segment.prototype.setDuration = function (value){
	if (this.duration() != value) {
		this._data[3] = value;
		this.dirty();
	};
	return this;
};

function Cue(){ return Segment.apply(this,arguments) };

Imba.subclass(Cue,Segment);
exports.Cue = Cue; // export class 


function Media(){ return Segment.apply(this,arguments) };

Imba.subclass(Media,Segment);
exports.Media = Media; // export class 



function TimelineCues(data){
	var self = this;
	self._data = data;
	self._ranges = [];
	self._cues = (data.cues || []).map(function(item) { return new Cue(item,self); }).sort(function(a,b) { return a.start() - b.start(); });
	// @media = (data:audio or []).map(do |item,i| Media.new(item,self))
	self._version = 0;
	self._dirty = true;
	// normalizeMedia
	self.compute();
	self;
};

exports.TimelineCues = TimelineCues; // export class 
TimelineCues.prototype.data = function(v){ return this._data; }
TimelineCues.prototype.setData = function(v){ this._data = v; return this; };
TimelineCues.prototype.cues = function(v){ return this._cues; }
TimelineCues.prototype.setCues = function(v){ this._cues = v; return this; };
TimelineCues.prototype.ranges = function(v){ return this._ranges; }
TimelineCues.prototype.setRanges = function(v){ this._ranges = v; return this; };
TimelineCues.prototype.version = function(v){ return this._version; }
TimelineCues.prototype.setVersion = function(v){ this._version = v; return this; };
TimelineCues.prototype.media = function(v){ return this._media; }
TimelineCues.prototype.setMedia = function(v){ this._media = v; return this; };

TimelineCues.prototype.normalizeMedia = function (){
	// sort by when it starts
	this.media().sort(function(a,b) { return a.start() - b.start(); });
	
	for (let i = 0, items = iter$(this.media()), len = items.length; i < len; i++) {
		let next = this.media()[i + 1];
	};
	return this;
};

TimelineCues.prototype.markers = function (){
	return this._data.markers || [];
};

TimelineCues.prototype.audio = function (){
	return this._data.audio || this.markers().filter(function(_0) { return _0.type == 'audio'; });
};

TimelineCues.prototype.lastAudioMarkerOffset = function (){
	var Math_;
	var ends = this.audio().map(function(item) {
		return item[1] + item[2];
	});
	return Math.max.apply(Math,ends);
};

TimelineCues.prototype.dirty = function (){
	this._dirty = true;
	this._version++;
	this._data.cues = this._cues.map(function(cue) { return cue.data(); });
	return this;
};

TimelineCues.prototype.ranges = function (){
	this.compute();
	return this._ranges;
};

TimelineCues.prototype.addCue = function (data){
	let cue = Cue.deserialize(data,this);
	this._cues.push(cue);
	this._cues.sort(function(a,b) { return a.start() - b.start(); });
	this.dirty();
	return cue;
};

TimelineCues.prototype.removeCue = function (item){
	this._cues = this._cues.filter(function(cue) { return cue != item && cue.data() != item; });
	return this.dirty();
};

TimelineCues.prototype.trimCuesAndAudio = function (offset){
	
	// handle cues
	this._cues = this._cues.filter(function(item) { return item.start() < offset; });
	
	for (let i = 0, items = iter$(this._cues), len = items.length, cue; i < len; i++) {
		cue = items[i];
		if (cue.end() <= offset) { continue; };
		cue.setEnd(offset);
	};
	
	// handle audio
	this._data.audio = this._data.audio.filter(function(item) { return item[1] < offset; });
	this._data.end = offset;
	
	this.dirty();
	
	return this._data;
};


TimelineCues.prototype.compute = function (){
	var time = 0;
	
	if (!this._dirty) { return this._ranges };
	this._dirty = false;
	
	// @cues = @data:cues # markers.filter do $1:type == 'cue'
	// if @data:cues
	// 	@cues = @data:cues.map do |cue|
	// 		{offset: cue[1], span: cue[2], duration: cue[3]}
	
	// could support timeMultiplier instead of duration?
	
	var prev = {o0: 0,o1: 0,t0: 0,t1: 0};
	this._ranges = [];
	
	// first sort them
	var cues = this._cues.slice(0).filter(function(item) { return item.span() > 0 && !item.disabled(); });
	cues = cues.map(function(item) { return item.data().slice(0); }).sort(function(a,b) { return a[1] - b[1]; });
	
	// only include filters with positive span
	// cues = cues.filter do |cue|
	//	cue[2] > 0 and cue
	
	let i = 0;
	var cue;
	while (cue = cues[i]){
		let prev = cues[i - 1];
		
		if (prev) {
			let po1 = prev[1] + prev[2];
			let co1 = cue[1] + cue[2];
			// the previous cue fully wraps this
			if ((cue[1] >= prev[1]) && po1 >= co1) {
				cues.splice(i,1);
				continue;
			} else if (po1 > cue[1]) {
				let delta = (po1 - cue[1]);
				cue[1] += delta;
				cue[2] -= delta;
			};
			// previous starts somewhere into the current one
		};
		
		i++;
	};
	
	// drop cues that are contained by others
	
	for (let i = 0, items = iter$(cues), len = items.length, item; i < len; i++) {
		item = items[i];
		var next = cues[i + 1];
		let dur = item[3];
		
		// if the next one is contained by the current
		if (dur < 0) {
			dur = item[2] * -dur;
		};
		
		var range = {
			o0: Math.max(item[1],0),
			o1: Math.max(item[1] + item[2],0),
			duration: dur,
			options: item[4]
		};
		
		if ((range.o1 - range.o0) <= 0) {
			continue;
		};
		
		if (next) {
			range.o1 = Math.min(range.o1,next[1]);
		};
		
		// add gaps between?
		var gap = range.o0 - prev.o1;
		range.t0 = prev.t1 + gap;
		range.t1 = range.t0 + (range.duration || 0);
		this._ranges.push(range);
		prev = range;
	};
	
	return this._ranges;
};

TimelineCues.prototype.timeToOffset = function (t){
	this.compute();
	var i = 0,l = this._ranges.length,r = null;
	
	if (l == 0) {
		return t;
	};
	
	while (i < l){
		r = this._ranges[i++];
		if (t < r.t0) {
			return r.o0 - (r.t0 - t);
		} else if (t < r.t1) {
			return r.o0 + (r.o1 - r.o0) * ((t - r.t0) / (r.t1 - r.t0));
		};
	};
	
	return r.o1 + (t - r.t1);
};


TimelineCues.prototype.offsetToTime = function (t){
	this.compute();
	var i = 0,l = this._ranges.length,r = null;
	
	if (l == 0) {
		return t;
	};
	
	while (i < l){
		r = this._ranges[i++];
		if (t < r.o0) {
			return r.t0 - (r.o0 - t);
		} else if (t < r.o1) {
			return r.t0 + (r.t1 - r.t0) * ((t - r.o0) / (r.o1 - r.o0));
		};
	};
	
	return r.t1 + (t - r.o1);
};

TimelineCues.prototype.duration = function (){
	return this.offsetToTime(this._data.end || this.lastAudioMarkerOffset()) - this.offsetToTime(this._data.start || 0);
};

TimelineCues.prototype.endOffset = function (){
	return this._data.end || this.lastAudioMarkerOffset();
};

TimelineCues.prototype.compileFunction = function (flip){
	if(flip === undefined) flip = false;
	var str = "return EXPR";
	
	var tpl = "( v<o0 ? (t0-(o0-v)) : (v<o1? t0 + (t1-t0)*((v-o0)/(o1-o0)) : EXPR ) )";
	var ltpl = "(t1+(v-o1))";
	
	var repl = function(str,item) {
		return str.replace(/([ot]\d)/g,function(m,v) {
			if (flip) {
				if (v[0] == 't') {
					v = 'o' + v[1];
				} else {
					v = 't' + v[1];
				};
			};
			return item[v];
		});
	};
	
	var last = null;
	for (let i = 0, items = iter$(this._ranges), len = items.length, r; i < len; i++) {
		r = items[i];
		last = r;
		str = str.replace("EXPR",repl(tpl,r));
	};
	str = str.replace("EXPR",repl(ltpl,last));
	
	return new Function('v',str);
};

TimelineCues.prototype.audioclips = function (startOffset,endOffset,includeGaps){
	// var tracks = markers.filter do $1:type == 'audio'
	if(startOffset === undefined) startOffset = 0;
	if(endOffset === undefined) endOffset = 0;
	if(includeGaps === undefined) includeGaps = false;
	return this.sliceClips(this.audio(),startOffset,endOffset,includeGaps);
};

TimelineCues.prototype.sliceClips = function (tracks,startOffset,endOffset,includeGaps){
	if(startOffset === undefined) startOffset = 0;
	if(endOffset === undefined) endOffset = 0;
	if(includeGaps === undefined) includeGaps = false;
	this.compute();
	// var dur = tl:endOffset - tl:startOffset
	// what if this does not work?
	// tracks = tracks ||= JSON.parse(JSON.stringify(tracks))
	
	var clips = [];
	
	for (let i = 0, items = iter$(tracks), len = items.length, track; i < len; i++) {
		track = items[i];
		let next = tracks[i + 1];
		let offset = track[1];
		let span = track[2]; // should be span
		
		// WARN Not correct for multi-track sessions
		if (next && (offset + span) > next[1] && false) {
			span = next[1] - offset;
		};
		
		var clip = {
			source: track,
			skip: 0,
			fid: track[3],
			o0: offset,
			o1: offset + span,
			t0: this.offsetToTime(offset),
			t1: this.offsetToTime(offset + span)
		};
		// offsetToTime already calibrates here?
		// if we start in the middle of a clip - the offset would be strange?
		clip.duration = clip.o1 - clip.o0;
		if (span) { clips.push(clip) };
	};
	
	// console.log clips
	// loop through the ranges to 
	// CA0 = JSON.parse(JSON.stringify(clips))
	// console.log "clips before slicing",CA0,@ranges
	// console.log @cues,audio
	
	var sliced = [];
	var t;
	var offsets = 0;
	var ki = 0;
	clip;
	
	while (clip = clips[ki++]){
		var mediaTime0 = clip.t0;
		var mediaTime1 = clip.t1;
		
		for (let i = 0, items = iter$(this._ranges), len = items.length, range; i < len; i++) {
			range = items[i];
			let rangeTime0 = range.t0;
			let rangeTime1 = range.t1;
			let specialGap = range.duration > 0 && (range.options instanceof Array);
			// skip if range starts after clip
			// skip if range ends before clip
			
			// if specialGap
			// 	console.log "gap is special!!",range
			
			if (rangeTime0 > mediaTime1 || mediaTime0 > rangeTime1) {
				continue;
			};
			
			// if the clip is fully encapsulated
			if (mediaTime0 >= rangeTime0 && rangeTime1 >= mediaTime1) {
				// --ki
				clip.disabled = range;
				// clips.splice(ki,1)
				// mark clip as encapsulated
				// calculate the new timings for this clip?
				break;
			};
			
			if (range.o0 > clip.o0) {
				// collapse starts into the clip
				
				// we can first create 
				if (includeGaps || specialGap) {
					// create a clip representing the cue
					let insideCue = {
						cue: range,
						source: clip.source,
						fid: clip.fid,
						o0: range.o0,
						t0: range.t0,
						o1: Math.min(clip.o1,range.o1),
						t1: Math.min(clip.t1,range.t1), // this is wrong
						skip: clip.skip + (range.o0 - clip.o0)
					};
					
					if (specialGap) {
						insideCue.realSkip = insideCue.skip;
						insideCue.skip += (range.options[0] - range.o0);
					};
					// console.log "added specialGap"
					clips.splice(ki++,0,insideCue);
				};
				
				if (range.o1 < clip.o1) {
					// clip is actually longer
					// so we should split it up
					let clone = {
						source: clip.source,
						fid: clip.fid,
						o0: range.o1,
						t0: range.t1,
						o1: clip.o1,
						t1: clip.t1,
						skip: clip.skip + (range.o1 - clip.o0) // maybe
					};
					
					clips.splice(ki,0,clone);
				};
				
				// this clip should stop where the range started
				clip.o1 = range.o0;
				clip.t1 = range.t0;
				break;
			} else if (range.o1 > clip.o0) {
				// we are starting somewhere inside the clip
				// console.log "move start of media",range:o1 - clip:o0
				
				// create a representation of the gap inside and insert before
				if (includeGaps) {
					let insideCue = {
						cue: range,
						source: clip.source,
						fid: clip.fid,
						o0: clip.o0,
						t0: clip.t0,
						o1: Math.min(clip.o1,range.o1),
						t1: Math.min(clip.t1,range.t1), // this is wrong
						skip: clip.skip
					};
					
					if (specialGap) {
						// this is wrong - for sure
						console.log("special gap will be wrong");
						insideCue.skip += (range.options[0] - range.o0);
					};
					
					clips.splice(ki++,0,insideCue);
				};
				
				clip.skip = clip.skip + (range.o1 - clip.o0);
				clip.t0 = range.t1;
				clip.o0 = range.o1; // this is the actual fix(!)
				// update o0 now as well?
			};
			
			// elif (mediaTime1 > rangeTime1)
			// 	clip:t0 = rangeTime1
			// 	# is it correct to skip offset?
			// 	clip:skip = clip:skip + (range:o1 - clip:o0)
			// 	# change duration as well, no?
		};
	};
	
	clips.map(function(clip) {
		return clip.duration = clip.t1 - clip.t0;
	});
	
	if (includeGaps) {
		clips = clips.sort(function(a,b) { return a.o0 - b.o0; });
	} else {
		clips = clips.filter(function(clip) { return !clip.disabled; });
		clips = clips.sort(function(a,b) { return a.t0 - b.t0; });
	};
	
	if (endOffset) {
		var endTime = this.offsetToTime(endOffset);
		for (let i = 0, items = iter$(clips), len = items.length, clip; i < len; i++) {
			clip = items[i];
			if (clip.t0 > endTime) {
				// console.log "clip starts after end!"
				clip.outOfBounds = true;
			};
			if (clip.t1 > endTime) {
				// console.log "end clip here"
				clip.t1 = endTime;
			};
		};
	};
	
	
	if (startOffset) {
		let startTime = this.offsetToTime(startOffset);
		for (let i = 0, items = iter$(clips), len = items.length, clip; i < len; i++) {
			clip = items[i];
			clip.t0 -= startTime;
			clip.t1 -= startTime;
			
			if (clip.t0 < 0) {
				clip.skip += Math.abs(clip.t0);
				clip.t0 = 0;
			};
		};
	};
	
	if (!includeGaps) {
		clips = clips.filter(function(clip) { return clip.t1 > 0 && !clip.outOfBounds && (clip.t1 - clip.t0) > 0; });
	};
	
	return clips;
};
