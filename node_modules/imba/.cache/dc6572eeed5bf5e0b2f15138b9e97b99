function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var LongPromise = require('../../util/LongPromise').LongPromise;
var AudioManager = require('./AudioManager').AudioManager;

var AV = AudioManager.instance();

var WARMUP = {
	READY: 0,
	STARTING: 1,
	STARTED: 2,
	PLAYING: 3,
	PAUSING: 4
};


function MediaGroup(timeline){
	this._timeline = timeline;
	this._media = [];
	this._latencies = [];
	this._playbackRate = 1;
	this.anchorTime(0,0,0);
	this;
};

exports.MediaGroup = MediaGroup; // export class 
MediaGroup.prototype.timeline = function(v){ return this._timeline; }
MediaGroup.prototype.setTimeline = function(v){ this._timeline = v; return this; };
MediaGroup.prototype.waiting = function(v){ return this._waiting; }
MediaGroup.prototype.setWaiting = function(v){ this._waiting = v; return this; };
MediaGroup.prototype.__playbackRate = {watch: 'playbackRateDidSet',name: 'playbackRate'};
MediaGroup.prototype.playbackRate = function(v){ return this._playbackRate; }
MediaGroup.prototype.setPlaybackRate = function(v){
	var a = this.playbackRate();
	if(v != a) { this._playbackRate = v; }
	if(v != a) { this.playbackRateDidSet && this.playbackRateDidSet(v,a,this.__playbackRate) }
	return this;
};

MediaGroup.prototype.isSafari = function (){
	return (this._isSafari == null) ? (this._isSafari = (/Apple/).test(window.navigator.vendor)) : this._isSafari;
};

MediaGroup.prototype.volume = function (){
	return 1;
};

MediaGroup.prototype.addMedia = function (item,offset){
	var self = this;
	if ((typeof item=='string'||item instanceof String)) {
		item = AV.elementForId(item);
	};
	
	if (self._media.indexOf(item) >= 0) {
		return item;
	};
	
	let idx = item._trackIndex = len$(self._media);
	item._startOffset = offset;
	item._maxDelay = 0;
	
	self._media.push(item);
	
	item.ontimeupdate = function(e) {
		let last = item._lastTime;
		let curr = item._lastTime = [Date.now(),item.currentTime * 1000];
		let clockDelta = last ? ((curr[0] - last[0])) : 0;
		let audioDelta = last ? ((curr[1] - last[1])) : 0;
		let playbackRate = item.playbackRate;
		let isReady = false;
		
		// safari specific cumbersome FSM to discover when we are truly ready to play
		if (item._warmup == WARMUP.STARTING) {
			let elapsedRatio = (audioDelta / (clockDelta * playbackRate));
			console.log(("" + idx + ".warmup starting " + (item.currentTime - item._startTime) + " " + elapsedRatio));
			if (audioDelta && elapsedRatio > 0.2 && elapsedRatio < 2) {
				isReady = true;
			};
		};
		
		if (item._warmup == WARMUP.STARTED) {
			console.log(("" + idx + ".warmup started " + (item.currentTime - item._startTime)));
			item._warmup = WARMUP.PLAYING;
		} else if (item._warmup == WARMUP.PLAYING) {
			console.log(("" + idx + ".warmup playing " + (item.currentTime - item._startTime)));
		};
		
		if (isReady) {
			item._warmup = WARMUP.READY;
			// if we were scheduled to be played later - pause the element
			if (item._playDelay) {
				self.pauseItem(item);
				// item:playbackRate = 0
			};
			return self.checkCanPlayThrough();
		} else if (!item._warmup && !item.paused && item.playbackRate > 0 && (self._anchor && self._anchor.speed != 0)) {
			return self.ontimeupdate(e,item);
		};
	};
	
	// Should never be used in safari right?
	item.onpause = function(e) {
		console.log(("" + idx + " finally paused"));
		if (item._warmup == WARMUP.PAUSING) {
			item._warmup = WARMUP.READY;
			item.currentTime = item._startTime;
			return self.checkCanPlayThrough();
		};
	};
	
	
	item.onseeking = function(e) {
		// whenever this is triggered, it means we will need to wait for a new
		// canplaythrough before we know that we are allowed to stop buffering
		console.log(("" + idx + ".seeking"));
		if (!(self.isSafari())) {
			item._waiting = true;
		};
		return self;
	};
	
	item.oncanplaythrough = function(e) {
		// if item.@waiting
		console.log(("" + idx + " ready to play"));
		item._waiting = false;
		return self.checkCanPlayThrough();
	};
	
	return self;
};

MediaGroup.prototype.checkCanPlayThrough = function (){
	if (this._playPromise) {
		if (this._media.every(function(item) { return !item._waiting && !item._warmup; })) {
			this._playPromise.resolve(this);
		};
	};
	return this;
};

MediaGroup.prototype.anchorTime = function (offset,time,speed){
	if(speed === undefined) speed = 0;
	this._anchor = {
		ts: Date.now(),
		offset: Math.round(offset),
		elapsed: Math.round(time),
		speed: speed
	};
	return this;
};



MediaGroup.prototype.ontimeupdate = function (e,item){
	var self = this;
	if (item._preplaying) {
		item._preplaying = false;
		item.pause();
	};
	
	let idx = item._trackIndex;
	let tlTime = self.currentTime();
	let actualTime = item.currentTime * 1000;
	let expectedTime = self.currentTime() - item._startOffset;
	let delay = expectedTime - actualTime;
	let pbr = item.playbackRate;
	
	if (item._resyncing) {
		return;
	};
	
	console.log(("ontimeupdate " + (item._trackIndex) + " " + (item.playbackRate) + " " + (expectedTime - actualTime)));
	
	if (pbr < self.playbackRate() && delay > -10) {
		console.warn(("syncing " + idx));
		return item.playbackRate = self.playbackRate();
	} else if (pbr > self.playbackRate() && delay < 10) {
		console.warn(("syncing " + idx));
		return item.playbackRate = self.playbackRate();
	} else if (!item._resyncing && Math.abs(delay) > 20 && delay > -1000) {
		// slightly adjusting playbackRate to eventually sync timings
		
		// TODO take playbackRate into account?
		let adjustmentWindow = 500;
		let rate = (adjustmentWindow + delay) / adjustmentWindow;
		
		if (self.isSafari() || rate > 4 || rate < 0.25) {
			// TODO take baseline playbackRate into account
			item.playbackRate = self.playbackRate() + ((delay > 0) ? 0.05 : (-0.05));
			return;
		};
		// The following solution seems to work very well for chrome
		// TODO try adjusting with fixed playbackRate - variable time
		console.log("changing playbackRate",rate,adjustmentWindow);
		item.playbackRate = rate;
		return item._resyncing = setTimeout(function() {
			item._resyncing = null;
			item.playbackRate = self.playbackRate();
			return item.volume = self.volume();
		},adjustmentWindow);
	};
};


MediaGroup.prototype.currentTime = function (){
	return this._anchor.elapsed + Math.round((Date.now() - this._anchor.ts) * this._anchor.speed);
};

MediaGroup.prototype.playItem = function (item){
	item.playbackRate = this.playbackRate();
	if (item.paused) { return item.play() };
};

MediaGroup.prototype.pauseItem = function (item){
	if (this.isSafari()) {
		item.playbackRate = 0;
	} else {
		item.pause();
	};
	clearTimeout(item._scheduler);
	return this;
};

MediaGroup.prototype.playbackRateDidSet = function (rate){
	if (this._anchor.speed != 0) {
		this.anchorTime(this.currentTime(),this.currentTime(),rate);
	};
	
	for (let i = 0, items = iter$(this._media), len = items.length, item; i < len; i++) {
		item = items[i];
		if (item.playbackRate != 0) {
			item.playbackRate = rate;
		};
	};
	// we also need to reschedule upcoming clips?
	return this;
};

MediaGroup.prototype.play = function (offset){
	var self = this;
	if(offset === undefined) offset = self.currentTime();
	var items = self._media;
	self._playPromise = new LongPromise();
	self.anchorTime(offset,offset,0);
	self.setWaiting(true);
	
	for (let i = 0, ary = iter$(self._media), len = ary.length, item; i < len; i++) {
		item = ary[i];
		clearTimeout(item._scheduler);
		let start = offset - item._startOffset;
		console.log(("start at " + start));
		
		if (start >= 0) {
			item.currentTime = start / 1000;
			item._playDelay = 0;
			self.pauseItem(item);
		} else {
			item.currentTime = 0;
			self.pauseItem(item);
			item._playDelay = (-start / self.playbackRate());
			
			if (!item._preplayed && !(self.isSafari())) {
				item._preplayed = true;
				item._preplaying = true;
				item.play();
			};
		};
	};
	
	if (self.isSafari()) {
		// do dry run
		for (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
			item = ary[i];
			item._warmup = WARMUP.STARTING;
			item._startTime = item.currentTime;
			// item:volume = 0.05
			self.playItem(item);
			// item.play
		};
	};
	
	self._playPromise.then(function() {
		console.log("now we are actually ready to play");
		self.setWaiting(false);
		
		// we do expect a delay of about 200 ms?
		setTimeout(function() { return self.anchorTime(offset,offset,self.playbackRate()); },self.isSafari() ? 0 : 0);
		
		let res = [];
		for (let i = 0, ary = iter$(self._media), len = ary.length, item; i < len; i++) {
			item = ary[i];
			res.push(item._playDelay ? (
				item._scheduler = setTimeout(function() { return self.playItem(item); },item._playDelay)
			) : (
				item.paused && (
					console.log(("play item now " + (item.paused))),
					setTimeout(function() { return self.playItem(item); },self.isSafari() ? 100 : 0)
				)
			));
		};
		return res;
	});
	
	
	return self._playPromise;
};

MediaGroup.prototype.pause = function (){
	this.anchorTime(this.currentTime(),this.currentTime(),0);
	
	for (let i = 0, items = iter$(this._media), len = items.length; i < len; i++) {
		this.pauseItem(items[i]);
		// item.pause
		// clearTimeout(item.@scheduler)
	};
	
	return this;
};
