function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _3 = Imba.createTagList, _2 = Imba.createTagMap, _1 = Imba.createElement;
var AudioManager = require('../util/AudioManager').AudioManager;
var ScrimbaGesture = require('../util/ScrimbaGesture').ScrimbaGesture;
var Segment = require('../util/TimelineCues').Segment;
var ACTION = require('../protocol').ACTION;

var Menu = require('uxa').Menu;

var msToStr = require('../../util/index').msToStr;


var SYMBOLS = {
	MUTED: "\ue8cc", // E8b4
	CUT: "\ue6c7",
	FF: "\ue730"
};

var round = function(val,to) {
	if(to === undefined) to = 0.5;
	return Math.round(val / to) * to;
};

var RangeView = Imba.defineTag('RangeView', function(tag){
	tag.prototype.timeline = function(v){ return this._timeline; }
	tag.prototype.setTimeline = function(v){ this._timeline = v; return this; };
	tag.prototype.data = function(v){ return this._data; }
	tag.prototype.setData = function(v){ this._data = v; return this; };
	
	tag.prototype.left = function (){
		return round(this.timeline().offset2px(this.data().start()));
	};
	
	tag.prototype.right = function (){
		return round(this.timeline().offset2px(this.data().end()));
	};
	
	tag.prototype.width = function (){
		return round(this.data().span() * this.timeline().ppms());
	};
	
	tag.prototype.render = function (){
		return this.$open(0).css('left',this.left()).css('width',this.width()).synced();
	};
});

var SegmentView = Imba.defineTag('SegmentView', RangeView, function(tag){
	let types = ['cue','audio','loop'];
	
	tag.prototype.render = function (){
		var $ = this.$;
		let dur = this.data().data()[3];
		let factor = dur ? ((this.data().span() / dur)) : 0;
		let left = this.left();
		let width = this.right() - left + 1;
		let o = this.data().options();
		
		return this.$open(0).setFlag(-1,types[this.data().data()[0]]).flagIf('selected',(this.data()._selected)).css('left',left).css('width',width).setChildren([
			($[0] || _1('div',$,0,this).flag('handle').flag('left').dataset('gesture','segmove,start')).bindData(this,'data',[]).end(),
			($[1] || _1('div',$,1,this).flag('handle').flag('right').dataset('gesture','segmove,end')).bindData(this,'data',[]).end(),
			($[2] || _1('div',$,2,this).flag('middle').dataset('gesture','move')).end(),
			($[3] || _1('div',$,3,this).flag('label')).setContent([
				(dur > 0) ? (
					($[4] || _1('span',$,4,3).flag('dur')).setContent(dur + 'ms',3)
				) : ((dur == 0) ? (
					($[5] || _1('span',$,5,3).flag('dur').setText("âˆž"))
				) : ((dur < 0) ? (
					($[6] || _1('span',$,6,3).flag('dur')).setContent(this.data().span() + 'ms',3)
				) : void(0))),
				
				false ? true : void(0)
			],1),
			
			(o && this.timeline().isOffsetBased()) ? (
				($[7] || _1('div',$,7,this).flag('subrange')).css('left',(round(this.timeline().offset2px(o[0]) - left))).css('width',(round(o[1] * this.timeline().ppms()))).end()
			) : void(0)
		],1).synced();
	};
	
	tag.prototype.ontap = function (t){
		t.halt();
		return this.trigger('segsel',this.data());
	};
});

var OffsetView = Imba.defineTag('OffsetView', function(tag){
	tag.prototype.__left = {watch: 'draw',name: 'left'};
	tag.prototype.left = function(v){ return this._left; }
	tag.prototype.setLeft = function(v){
		var a = this.left();
		if(v != a) { this._left = v; }
		if(v != a) { this.draw && this.draw(v,a,this.__left) }
		return this;
	};
	
	tag.prototype.draw = function (){
		return this.css({transform: ("translateX(" + this.left() + "px)")});
	};
});

var TimelineCanvas = Imba.defineTag('TimelineCanvas', function(tag){
	
	tag.prototype.cues = function(v){ return this._cues; }
	tag.prototype.setCues = function(v){ this._cues = v; return this; };
	tag.prototype.pxps = function(v){ return this._pxps; }
	tag.prototype.setPxps = function(v){ this._pxps = v; return this; };
	tag.prototype.startOffset = function(v){ return this._startOffset; }
	tag.prototype.setStartOffset = function(v){ this._startOffset = v; return this; };
	tag.prototype.startTime = function(v){ return this._startTime; }
	tag.prototype.setStartTime = function(v){ this._startTime = v; return this; };
	tag.prototype.endTime = function(v){ return this._endTime; }
	tag.prototype.setEndTime = function(v){ this._endTime = v; return this; };
	tag.prototype.options = function(v){ return this._options; }
	tag.prototype.setOptions = function(v){ this._options = v; return this; };
	tag.prototype.__currentOffset = {watch: 'currentOffsetDidSet',name: 'currentOffset'};
	tag.prototype.currentOffset = function(v){ return this._currentOffset; }
	tag.prototype.setCurrentOffset = function(v){
		var a = this.currentOffset();
		if(v != a) { this._currentOffset = v; }
		if(v != a) { this.currentOffsetDidSet && this.currentOffsetDidSet(v,a,this.__currentOffset) }
		return this;
	};
	tag.prototype.markedRange = function(v){ return this._markedRange; }
	tag.prototype.setMarkedRange = function(v){ this._markedRange = v; return this; };
	tag.prototype.markers = function(v){ return this._markers; }
	tag.prototype.setMarkers = function(v){ this._markers = v; return this; };
	
	tag.prototype.timeline = function (){
		return this.data();
	};
	
	tag.prototype.cues = function (){
		return this.timeline().cues();
	};
	
	tag.prototype.viewRange = function (){
		return this._viewRange || this.data()._viewRange;
	};
	
	tag.prototype.scrollLeft = function (){
		return this.startTime() * this.ppms();
	};
	
	tag.prototype.canvas = function (){
		let $ = this.$$ || (this.$$ = {});
		return (this._canvas = this._canvas||_1('canvas',this).flag('canvas'));
	};
	
	tag.prototype.build = function (){
		this._version = 0;
		this._currentOffset = 0;
		return this._defaults = {
			clipColors: ['#977f9e'],
			cutColor: '#c3c3c3',
			tickMinSpacing: 10,
			tockMinSpacing: 30,
			tickFontSize: 10,
			actionsHeight: 2
		};
	};
	
	tag.prototype.option = function (key,fallback){
		if(fallback === undefined) fallback = null;
		let val = this._options && this._options[key] || this._defaults[key];
		return (val != null) ? val : fallback;
	};
	
	tag.prototype.setup = function (){
		return this._draws = 0;
	};
	
	tag.prototype.ppms = function (){
		return this.pxps() / 1000;
	};
	
	tag.prototype.startTime = function (){
		return this.cues().offsetToTime(this.startOffset());
	};
	
	tag.prototype.startValue = function (){
		return this.isOffsetBased() ? this.startOffset() : this.startTime();
	};
	
	// nede to decide upon consistent naming for the two coordinate systems
	tag.prototype.isOffsetBased = function (){
		return !(!this.options().renderCollapsed);
	};
	
	tag.prototype.isTimeBased = function (){
		return !(this.isOffsetBased());
	};
	
	// timing methods
	tag.prototype.xToTimeOffset = function (x,round){
		if(round === undefined) round = 0;
		let box = this.dom().getBoundingClientRect();
		let val = this.startValue() + (x - box.left) / this.ppms();
		if (this.isTimeBased()) {
			val = this.cues().timeToOffset(val);
		};
		
		return round ? ((Math.round(val * round) / round)) : val;
	};
	
	tag.prototype.screenx2val = function (x){
		var val;
		let box = this.dom().getBoundingClientRect();
		return val = this.startValue() + (x - box.left) / this.ppms();
	};
	
	tag.prototype.absTimeToX = function (absTime,round){
		if(round === undefined) round = 0;
		let val = (absTime - this.startTime()) * this.ppms();
		return round ? ((Math.round(val * round) / round)) : val;
	};
	
	tag.prototype.round = function (val,precision){
		if(precision === undefined) precision = 0;
		return precision ? ((Math.round(val * precision) / precision)) : val;
	};
	
	tag.prototype.px2val = function (x){
		return this.startValue() + (x / this.ppms());
	};
	
	tag.prototype.time2px = function (time){
		if (this.isOffsetBased()) {
			return this.offset2px(this.cues().timeToOffset(time));
		};
		
		return (time - this.startTime()) * this.ppms();
	};
	
	tag.prototype.offset2px = function (offset){
		if (this.isTimeBased()) {
			return this.time2px(this.cues().offsetToTime(offset));
		};
		
		return (offset - this.startOffset()) * this.ppms();
	};
	
	tag.prototype.offset2val = function (offset){
		return this.isOffsetBased() ? offset : this.cues().offsetToTime(offset);
	};
	
	tag.prototype.time2val = function (time){
		return this.isTimeBased() ? time : this.cues().timeToOffset(time);
	};
	
	tag.prototype.val2offset = function (val){
		return this.isOffsetBased() ? val : this.cues().timeToOffset(val);
	};
	
	tag.prototype.val2time = function (val){
		return this.isTimeBased() ? val : this.cues().offsetToTime(val);
	};
	
	tag.prototype.yScale = function (){
		return 0.6;
	};
	
	tag.prototype.showCues = function (){
		return true;
	};
	
	tag.prototype.dpr = function (){
		return this._dpr || (this._dpr = window.devicePixelRatio);
	};
	
	tag.prototype.vh = function (){
		return this._vh;
	};
	
	tag.prototype.vw = function (){
		return this._vw;
	};
	
	tag.prototype.invalidated = function (){
		var $0 = arguments, i = $0.length;
		var params = new Array(i>0 ? i : 0);
		while(i>0) params[i-1] = $0[--i];
		let prev = this._guard || [];
		this._guard = params;
		for (let i = 0, items = iter$(params), len = items.length; i < len; i++) {
			if (params[i] != prev[i]) {
				this._version++;
				return true;
			};
		};
		return false;
	};
	
	tag.prototype.drawClips = function (clips,ctx){
		var source_;
		var ctx = this.canvas().dom().getContext('2d');
		let ppms = this.ppms();
		var colors = this.option('clipColors').slice();
		var colorIndex = 0;
		// canvasTime, canvasOffset
		
		let to0 = this.startOffset();
		let to1 = this.val2offset(this.startValue() + (this._vw / ppms));
		let tt0 = this.startTime();
		let tt1 = tt0 + (this._vw / ppms);
		
		let tv0 = this.isOffsetBased() ? to0 : tt0;
		let tv1 = this.isOffsetBased() ? to1 : tt1;
		
		// var startRelTime = startTime
		// var endRelTime = startRelTime
		let yOffset = Math.round(this._vh * this.option('waveAnchorY',0.5) * this.dpr());
		let yAmp = ((this.vh() * 0.5) / 128) * this.dpr() * -1 * this.yScale();
		
		let cues = [];
		
		ctx.save();
		
		// for now we draw everything		
		for (let j = 0, items = iter$(clips), len = items.length, clip; j < len; j++) {
			clip = items[j];
			let v0 = this.isOffsetBased() ? clip.o0 : clip.t0;
			let v1 = this.isOffsetBased() ? clip.o1 : clip.t1;
			
			let t0x = this.time2px(clip.t0);
			let t1x = this.time2px(clip.t1);
			
			let o0x = this.offset2px(clip.o0);
			let o1x = this.offset2px(clip.o1);
			
			let v0x = this.isOffsetBased() ? o0x : t0x;
			let v1x = this.isOffsetBased() ? o1x : t1x;
			
			let color = (source_ = clip.source).COLOR || (source_.COLOR = colors[(colorIndex++) % colors.length]);
			let wave = clip.source._wave;
			let cue = clip.cue;
			
			if ((v1x - v0x) == 0) {
				continue;
			};
			
			// possibly skip drawing
			if (v0x > this._vw || v1x < 0) {
				continue;
			};
			
			let skip = clip.skip || 0;
			let clipSkip = skip;
			let dur = v1 - v0; // does not take speedup etc into effect
			
			if (this.isOffsetBased() && clip.realSkip) {
				// console.log "draw with realSkip instead",clip:realSkip,skip,dur
				skip = clipSkip = clip.realSkip;
				// should also include a clip for this one
			};
			
			if (this.pxps() < 10) {
				let scale = Math.ceil(44100 / (this.pxps() * this.dpr()));
				wave = wave._lowres || (wave._lowres = wave.resample({scale: scale}));
			};
			
			if (true) {
				if (tv0 > v0) {
					let delta = (tv0 - v0);
					skip += delta;
					dur -= delta;
				};
				
				if (v1 > tv1) {
					dur -= (v1 - tv1);
				};
			};
			
			// the first wave-sample for this clip
			let i0 = Math.max(wave.at_time(skip / 1000),0);
			let i1 = Math.min(wave.at_time((skip + dur) / 1000),wave.offset_end);
			let spx = wave.seconds_per_pixel;
			
			ctx.save();
			ctx.fillStyle = clip.cue ? this.option('cutColor') : color; // '#977f9e'
			ctx.beginPath();
			
			// transform the canvas to have 0,0 at the start and scaling
			if (this.isOffsetBased()) {
				ctx.translate(this.offset2px(v0 - clipSkip) * this.dpr(),yOffset);
			} else {
				ctx.translate(this.time2px(v0 - clipSkip) * this.dpr(),yOffset);
			};
			
			ctx.scale(this.dpr() * spx * this.pxps(),yAmp);
			// transform as if we start at the beginning of the whole wave
			
			let i = i0;
			// drawing the lower part now
			while (i < i1){
				ctx.lineTo(i,wave.at(i * 2));
				i++;
			};
			
			while (i > i0){
				ctx.lineTo(--i,wave.at(i * 2 + 1));
			};
			
			ctx.closePath();
			ctx.fill();
			ctx.restore();
			
			
			if (cue && cues.indexOf(cue) == -1) {
				cues.push(cue);
				ctx.save();
				let c0x = v0x;
				let c1x = this.isOffsetBased() ? this.offset2px(cue.o1) : this.time2px(cue.t1);
				
				// now possibly draw some details for the clip itself
				let h = this.option('minimap') ? 10 : ((this._vh * 0.3));
				ctx.strokeStyle = this.option('cutColor');
				
				ctx.lineWidth = this.option('minimap') ? ((1 / this.dpr())) : 1;
				ctx.translate(0,yOffset);
				ctx.scale(this.dpr(),this.dpr());
				ctx.beginPath();
				
				let icon = SYMBOLS.MUTED;
				let iconSize = 7;
				
				// cutting
				if (cue.duration == 0) {
					ctx.moveTo(c0x,-h);
					ctx.lineTo(c1x,h);
					ctx.moveTo(c0x,h);
					ctx.lineTo(c1x,-h);
					icon = SYMBOLS.CUT;
					// iconSize = 6
				} else if (cue.duration < (cue.o1 - cue.o0)) {
					icon = SYMBOLS.FF;
				};
				
				ctx.strokeRect(c0x,-h,c1x - c0x,h * 2);
				// draw icon
				
				this.drawIcon(ctx,c0x + (c1x - c0x) * 0.5,-h,iconSize * this.dpr(),icon);
				
				// unless option(:minimap)
				// 	h = @vh * 0.5
				
				// ctx.moveTo(c0x,-h)
				// ctx.lineTo(c0x,h)
				
				// ctx.moveTo(c1x,-h)
				// ctx.lineTo(c1x,h)
				
				ctx.stroke();
				ctx.restore();
				// start and end-lines
			};
		};
		return this;
	};
	
	tag.prototype.drawIcon = function (ctx,x,y,size,symbol,color){
		if (this.option('minimap')) { return };
		// symbol = "\uE8b4"
		ctx.save();
		ctx.font = ("normal " + size + "px 'scrimbacon'");
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		ctx.fillText(symbol,x,y);
		return ctx.restore();
		// "\e8b4"
	};
	
	tag.prototype.ctx = function (){
		return this._ctx || (this._ctx = this.canvas().dom().getContext('2d'));
	};
	
	tag.prototype.draw = async function (){
		var pxps = this.pxps();
		let vw = this._vw = this.dom().offsetWidth;
		let vh = this._vh = this.dom().offsetHeight;
		let collapse = !this.options().renderCollapsed;
		
		if (pxps == undefined && this.endTime()) {
			pxps = (vw / (this.endTime() / 1000));
			this._pxps = pxps;
		};
		
		if (!(this.invalidated(this.startOffset(),this.startTime(),pxps,this.cues().version(),vw,vh,collapse) && vw)) {
			return this;
		};
		
		let now = Date.now();
		this._t = now;
		var draw = ++this._draws;
		
		// fetch clips
		for (let i = 0, items = iter$(this.cues().audio()), len = items.length, audioItem; i < len; i++) {
			audioItem = items[i];
			audioItem._wave = await AudioManager.instance().waveformForId(audioItem[3]);
		};
		
		// another draw has been started during wave-loading
		if (draw != this._draws) {
			return;
		};
		
		// this will clear the canvas
		var ctx = this.ctx(); // canvas.dom.getContext('2d')
		this.canvas().dom().width = vw * this.dpr();
		this.canvas().dom().height = vh * this.dpr();
		
		// draw background
		
		let clips = this.cues().audioclips(0,0,true);
		this.drawTickLines(ctx);
		this.drawClips(clips);
		this.drawActions(ctx);
		this._wheelStartTime = null;
		return this;
	};
	
	tag.prototype.drawTickLines = function (ctx){
		let pxps = this.pxps();
		let tickTime = 0;
		let tickEvery = 0;
		let tockEvery = 0;
		let tickMinSpacing = this.option('tickMinSpacing');
		let tockMinSpacing = this.option('tockMinSpacing');
		let fontSize = this.option('tickFontSize');
		
		for (let i = 0, items = [0.05,0.1,0.25,0.5,1,5,10,15,30,60,120,300,600,1200], len = items.length, v; i < len; i++) {
			v = items[i];
			if (pxps * v > tickMinSpacing) {
				tickEvery || (tickEvery = v);
			};
			
			if (pxps * v > tockMinSpacing && v >= 1) {
				tockEvery || (tockEvery = v);
				break;
			};
		};
		
		ctx.strokeStyle = '#DDDDDD';
		ctx.fillStyle = '#CCCCCC';
		
		ctx.beginPath();
		ctx.font = ("" + (fontSize * this.dpr()) + "px sans-serif");
		ctx.textAlign = 'center';
		ctx.textBaseline = 'bottom';
		
		let textWidth = ctx.measureText("0:00").width;
		
		// draw lines
		let x = 0;
		let ppms = this.ppms(),dpr = this.dpr();
		
		// add ticks directly?
		let ticks = [];
		
		let start = this.startOffset();
		if (this.option('renderTimeTicks')) {
			// add ticks for the actual time
			while (x < this._vw){
				x = this.time2px(tickTime);
				// let offsetForTime = cues.timeToOffset(tickTime * 1000)
				// x = (offsetForTime * ppms) - (start * ppms)
				if (x >= 0) { ticks.push([x,0,msToStr(tickTime),tickTime]) };
				tickTime += (tickEvery * 1000);
			};
		};
		
		let gap = Math.round(fontSize * 0.5) * dpr;
		let maxX = this._vw * dpr;
		let txtSpace = textWidth * 0.5 + 2 * dpr;
		
		for (let i = 0, len = ticks.length, tick; i < len; i++) {
			tick = ticks[i];
			let tx = tick[0] * dpr;
			let ty = tick[1] * this._vh * dpr;
			let lbl = tick[2];
			let time = tick[3];
			let tock = time % (tockEvery * 1000) == 0;
			let lineGap = tock ? (gap * 2) : (gap * 5);
			if (tx >= maxX) { continue; };
			
			ctx.beginPath();
			ctx.strokeStyle = tock ? '#D2D2D2' : '#e0e0e0';
			ctx.lineWidth = 1;
			ctx.moveTo(tx,lineGap);
			ctx.lineTo(tx,this._vh * dpr - lineGap);
			ctx.stroke();
			
			if (tock) {
				ctx.textBaseline = ty ? 'bottom' : 'top';
				ctx.textAlign = 'left';
				
				// ctx.moveTo(tx, ty - gap)
				// ctx.lineTo(tx, ty + gap)
				
				// let lblX = tx
				
				// if tx < txtSpace
				// 	tx = txtSpace
				// elif (maxX - tx) < txtSpace
				// 	tx = maxX - txtSpace
				
				ctx.fillText(lbl,tx + 4 * dpr,ty ? ((ty - gap)) : ((lineGap - 2 * dpr)));
			};
			
			// now add a full line as well
			// ctx.moveTo(tx,0)
			// ctx.lineTo(tx,@vh * dpr)
		};
		// ctx.stroke
		return this;
	};
	
	tag.prototype.getActions = function (){
		let stream = this.timeline().branch().stream();
		let action = stream.actionAtOffset(this.startOffset());
		let endOffset = this.option('minimap') ? stream.duration() : this.val2offset(this.startValue() + (this._vw / this.ppms()));
		let lines = this._lines = {};
		
		// base on calculations no?
		let maxDist = (this.option('minimap') ? 3 : 2) / this.ppms();
		
		// timeOffset is absolute
		while (action && action.timeOffset() < endOffset){
			let time = action.timeOffset();
			let type = action._type;
			let line = lines[type] || (lines[type] = []);
			let prev = line[line.length - 1];
			
			if ((prev instanceof Array) && (time - prev[1]) < maxDist) {
				prev[1] = time;
			} else if ((typeof prev=='number'||prev instanceof Number) && (time - prev) < maxDist) {
				line[line.length - 1] = [prev,time];
			} else {
				line.push(time);
			};
			action = action._next;
		};
		
		return lines;
	};
	
	tag.prototype.drawActionLayer = function (ctx,data,type,color,row){
		// if option(:minimap)
		// 	console.log "drawActionLayer",type,data,color,row
		
		if (type instanceof Array) {
			for (let i = 0, items = iter$(type), len = items.length; i < len; i++) {
				this.drawActionLayer(ctx,data,items[i],color,row);
			};
			return;
		};
		
		let actionsHeight = this.option('actionsHeight') || 2;
		let points = data[type];
		
		
		
		if (!points) { return };
		
		let size = Math.max((this.ppms() * 10),actionsHeight / 2) * this.dpr();
		let y = (this._vh - (this.option('tickFontSize') * 2) - row * (actionsHeight * 1.5)) * this.dpr();
		
		ctx.strokeStyle = color;
		ctx.lineWidth = actionsHeight * this.dpr();
		ctx.lineCap = 'round';
		ctx.beginPath();
		
		let x0 = 0;
		let x1 = 0;
		
		for (let i = 0, items = iter$(points), len = items.length, pt; i < len; i++) {
			
			pt = items[i];
			let next = points[i + 1];
			if (pt instanceof Array) {
				x0 = this.offset2px(pt[0]) * this.dpr();
				x1 = this.offset2px(pt[1]) * this.dpr();
			} else {
				x0 = this.offset2px(pt) * this.dpr();
				x1 = x0 + size;
			};
			
			ctx.moveTo(x0,y);
			ctx.lineTo(x1,y);
		};
		ctx.stroke();
		return;
	};
	
	tag.prototype.drawLines = function (ctx,points,color){
		if(color === undefined) color = '#ff2c42';
		ctx.strokeStyle = color;
		ctx.lineWidth = 1 * this.dpr();
		ctx.lineCap = 'butt';
		ctx.setLineDash([4 * this.dpr(),2 * this.dpr()]);
		ctx.beginPath();
		
		for (let i = 0, items = iter$(points), len = items.length; i < len; i++) {
			let x = this.absTimeToX(items[i]) * this.dpr();
			ctx.moveTo(x,0);
			ctx.lineTo(x,this._vh * this.dpr());
		};
		
		ctx.stroke();
		return this;
	};
	
	
	
	tag.prototype.drawActions = function (ctx){
		var lines = this.getActions();
		ctx.save();
		this.drawActionLayer(ctx,lines,ACTION.LCSELECTION,'#e0929e',0);
		this.drawActionLayer(ctx,lines,[ACTION.LCINSERT,ACTION.LCDELETE,ACTION.LCEDIT],'#91bba0',0); // 6666$$
		this.drawActionLayer(ctx,lines,ACTION.POINTER_UPDATE,'#C3C3C3',1);
		this.drawActionLayer(ctx,lines,ACTION.LAYOUT,'#FEC2BF',1);
		// draw browser-parts
		this.drawActionLayer(ctx,lines,[ACTION.PAGE_LOAD,ACTION.DOM_MUTATE,ACTION.PAGE_LOG],'#66CCFF',2);
		
		// if options(:minimap)
		// 	console.log "drawing actions in overview",lines,@vw,@vh
		// draw recording events
		// drawLines(ctx,lines[ACTION.RECSTART],'#ff2c42')
		ctx.restore();
		return this;
	};
	
	tag.prototype.ontouchstart = function (t){
		let gesture = ScrimbaGesture.options(t,{data: this.data(),
		startValue: this.startValue(),
		startTime: this.startTime(),
		startOffset: this.startOffset()});
		
		let btn = t.button();
		let alt = t.event().altKey;
		let meta = t.event().metaKey;
		let shift = t.event().shiftKey;
		let type = gesture.type;
		
		if (!type) {
			if (shift && alt) {
				type = 'mark';
			} else if (btn == 2 || alt) {
				type = 'move';
			} else if (shift) {
				type = 'mark';
				gesture.seek = true;
			} else {
				type = 'seek';
			};
		};
		
		this.log("ontouchstart",btn,alt,meta,shift,type);
		gesture.type = type;
		return ScrimbaGesture.wrap(t,gesture);
	};
	
	tag.prototype.ontouchend = function (t){
		if (t.dr() < 10) { this.trigger('segsel',null) };
		return this.trigger('autosave');
	};
	
	tag.prototype.oncontextmenu = function (e){
		return e.prevent().stop();
	};
	
	tag.prototype.onmoveupdate = function (g){
		let val = g.options().startValue - (g.dx() / this.ppms()) * 2;
		this.trigger('showrange',{start: this.val2offset(val)});
		return this;
	};
	
	tag.prototype.onmoveend = function (g){
		return this;
	};
	
	tag.prototype.onseekstart = function (g){
		// timeline.cues.dirty # why dirty?
		this.timeline().setState('seeking');
		return this.render();
	};
	
	tag.prototype.onseekupdate = function (g){
		return this.trigger('seek',{offset: this.val2offset(this.screenx2val(g.x()),1)});
	};
	
	tag.prototype.onseekend = function (g){
		var v_;
		return (this.timeline().setState(v_ = this.timeline().playState()),v_);
	};
	
	tag.prototype.onsegmoveinit = function (g){
		g.touch().capture();
		let seg = g.handler().data();
		return this.trigger('segsel',seg);
	};
	
	tag.prototype.onsegmovestart = function (g){
		let seg = g.handler().data();
		let val = g.options().start ? seg.start() : seg.end();
		return g._adjustOffset = this.xToTimeOffset(g.x(),1) - val;
	};
	
	tag.prototype.onsegmoveupdate = function (g){
		// log "onsegmoveupdate"
		var seg;
		if (seg = g.handler().data()) {
			if (g.options().start) {
				seg.setStart(this.xToTimeOffset(g.x(),1) - g._adjustOffset);
			} else {
				seg.setEnd(this.xToTimeOffset(g.x(),1) - g._adjustOffset);
			};
			this.render();
		};
		return this;
	};
	
	tag.prototype.onsegmoveend = function (g){
		let seg = g.handler().data();
		if (seg.span() == 0) {
			// log "should remove segment!"
			this.cues().removeCue(seg);
			this.render();
		};
		return this;
	};
	
	tag.prototype.onmarkstart = function (g){
		// start from 
		
		let end = this.xToTimeOffset(g.x(),1);
		let start = end;
		
		if (g.options().seek) {
			start = this.timeline().currentOffset();
		};
		
		this.setMarkedRange(g._seg = new Segment([0,start,(end - start)]));
		g._seg._pin = start;
		// g.@seg = cues.addCue([0,xToTimeOffset(g.x),10])
		this.trigger('segsel',g._seg);
		return this.render();
	};
	
	tag.prototype.onmarkupdate = function (g){
		let end = this.xToTimeOffset(g.x(),1);
		let pin = g._seg._pin;
		
		if (end > pin) {
			g._seg.setStart(pin);
			g._seg.setEnd(end);
		} else {
			g._seg.setStart(end);
			g._seg.setEnd(pin);
		};
		
		if (g.options().seek) {
			this.trigger('seek',{offset: end});
		};
		// make the seek follow the marker
		return this.render();
	};
	
	tag.prototype.onmarkend = function (g){
		var self = this, t0;
		self.log('onmarkend');
		let seg = g._seg;
		let start = seg.start();
		let span = seg.span();
		if (!self._markedView) { return };
		
		// find surrounding cue
		let wrapper = null;
		for (let i = 0, items = iter$(self.cues().cues()), len = items.length, cue; i < len; i++) {
			cue = items[i];
			if (start >= cue.start() && cue.end() >= seg.end()) {
				wrapper = cue;break;
			};
		};
		
		let cancel = function(e) {
			// log "didhide!"
			var v_;
			return (self.setMarkedRange(null),null);
		};
		
		return self._markedView.uxa().open((t0 = (t0=_1(Menu))).on$(0,['uxahide',cancel],self).setContent(
			wrapper ? (
				(t0.$.A || _1('div',t0.$,'A',t0).flag('item').setText('Set speedup audio')).on$(0,['tap',['setCueAudio',wrapper,start,span]],self)
			) : Imba.static([
				// <.item :tap.createSegment(>
				(t0.$.B || _1('div',t0.$,'B',t0).flag('item').setText('Cut')).on$(0,['tap',['createSegment',[0,start,span,0]]],self),
				(t0.$.C || _1('div',t0.$,'C',t0).flag('item').setText('Silence')).on$(0,['tap',['createSegment',[0,start,span,-1]]],self),
				(t0.$.D || _1('div',t0.$,'D',t0).flag('item').setText('Speedup')).on$(0,['tap',['createSegment',[0,start,span,500]]],self),
				(t0.$.E || _1('div',t0.$,'E',t0).flag('item').setText('Loop playback')).on$(0,['tap',['createLoop',[2,start,span]]],self)
			],2,1)
		,3).end());
	};
	
	tag.prototype.setCueAudio = function (cue,start,span){
		this.log("setCueAudio",cue,start,span);
		if (cue.duration() > 0) {
			cue.setDuration(span);
			cue.setOptions([start,span]); // and more no?
		};
		return this;
	};
	
	tag.prototype.createSegment = function (params){
		this.log('segcreate',params);
		let seg = this.cues().addCue(params);
		this.trigger('segsel',seg);
		this.setMarkedRange(null);
		return this.render();
	};
	
	tag.prototype.createLoop = function (params){
		this.timeline().setLoopSegment(new Segment(params,this.timeline().cues()));
		this.setMarkedRange(null);
		return this.render();
	};
	
	tag.prototype.tick = function (){
		return this.draw();
	};
	
	tag.prototype.mount = function (){
		this._mounted = true;
		this.render();
		return this;
	};
	
	tag.prototype.render = function (){
		var self = this, $ = this.$;
		if (!self._mounted) { return };
		self.draw();
		
		let startOffset = self.startOffset();
		let startTime = self.startTime();
		let endTime = startTime + (self._vw / self.ppms());
		let endOffset = self.val2offset(self.startValue() + (self._vw / self.ppms()));
		
		self.$open(0).flagIf('collapsed',(!(self.isOffsetBased()))).setChildren([
			self.canvas(),
			(function tagLoop($0) {
				var $$ = $0.$iter();
				for (let i = 0, items = iter$(self.timeline().cues().cues()), len = items.length, seg; i < len; i++) {
					seg = items[i];
					if (seg.end() < startOffset || seg.start() > endOffset) { continue; };
					$$.push(($0[i] || _1(SegmentView,$0,i)).setData(seg).setTimeline(self).end());
				};return $$;
			})($[0] || _2($,0)),
			self.timeline().loopSegment() ? (
				($[1] || _1(SegmentView,$,1,self).flag('loop')).bindData(self.timeline(),'loopSegment',[]).setTimeline(self).end()
			) : void(0),
			self.markedRange() ? (
				(self._markedView = self._markedView||_1(SegmentView,self).flag('markedView').flag('sel')).bindData(self,'markedRange',[]).setTimeline(self).end()
			) : void(0),
			
			(self._playhead = self._playhead||_1(OffsetView,self).flag('playhead')).setLeft(round(self.offset2px(self.currentOffset()),2)).end()
		],1).synced();
		return self;
	};
})
exports.TimelineCanvas = TimelineCanvas;


var TimelineRegionCanvas = Imba.defineTag('TimelineRegionCanvas', TimelineCanvas, function(tag){
	
	tag.prototype.onwheel = function (e){
		let shift = e.event().shiftKey;
		let alt = e.event().altKey;
		let dx = e.event().deltaX;
		let dy = e.event().deltaY;
		if (this._wheelStartTime == null) {
			this._wheelStartTime = this.startValue();
		};
		// log 'onwheel',e.event:deltaX
		// let offset = startTime + (e.event:deltaX / ppms)
		
		e.preventDefault();
		e.silence();
		
		if (shift) {
			let x = e.event().clientX;
			let zoom = Math.max(10,this.pxps() + dx);
			// supply anchor and value ourselves
			let box = this.dom().getBoundingClientRect();
			let relX = (x - box.left);
			
			let anchor = relX / (box.width);
			let val = this.val2offset(this.screenx2val(x));
			let time = this.xToTimeOffset(x);
			// now find out the pixel-position for the offset
			// if it has changed -- find out the offset for newpxpos - oldpxpos
			this.trigger('zoom',{scale: zoom});
			this.setPxps(this.parent().pxps());
			this.setCurrentOffset(this.parent().viewRange().start());
			let newPxValue = this.offset2px(val);
			let moved = newPxValue - relX;
			// console.log "after zoom",newPxValue,relX,pxps,moved
			let newStart = this.px2val(moved);
			return this.parent().viewRange().moveTo(this.val2offset(newStart),0);
		} else {
			this._wheelStartTime += (e.event().deltaX / this.ppms());
			this._wheelStartTime = Math.max(this._wheelStartTime,-100 / this.ppms());
			
			// console.log "seekTo",@wheelStartTime,e.event
			return this.trigger('showrange',{start: this.val2offset(Math.round(this._wheelStartTime))});
		};
	};
})
exports.TimelineRegionCanvas = TimelineRegionCanvas;


var TimelineOverview = Imba.defineTag('TimelineOverview', TimelineCanvas, function(tag){
	
	tag.prototype.viewRange = function(v){ return this._viewRange; }
	tag.prototype.setViewRange = function(v){ this._viewRange = v; return this; };
	
	tag.prototype.draw = function (){
		// skip drawing while touching
		if (len$(ScrimbaGesture.Active) > 0) {
			return;
		};
		
		this.setStartOffset(0);
		let end = this.offset2val(this.timeline().endOffset());
		let pad = 4;
		this.setPxps((this.dom().offsetWidth - (pad * 2)) / (end / 1000));
		this.setStartOffset((pad / this.ppms()) * -1);
		return tag.prototype.__super__.draw.apply(this,arguments);
	};
	
	tag.prototype.onwheel = function (){
		return this;
	};
	
	tag.prototype.getActions = function (){
		if (this._lines) { return this._lines };
		return tag.prototype.__super__.getActions.apply(this,arguments);
	};
	
	tag.prototype.canvas = function (){
		let $ = this.$$ || (this.$$ = {});
		return (this._canvas = this._canvas||_1('canvas',this).flag('canvas').dataset('gesture','seek')).end();
	};
	
	tag.prototype.render = function (){
		var $ = this.$;
		if (!this._mounted) { return };
		this.draw();
		
		return this.$open(0).setChildren([
			$[0] || _1(RangeView,$,0,this).flag('zoomed').flag('bg'),
			this.canvas(),
			$[1] || _1(RangeView,$,1,this).flag('zoomed').flag('front'),
			this._playhead = this._playhead||_1(OffsetView,this).flag('playhead')
		],1).synced((
			$[0].bindData(this,'viewRange',[]).setTimeline(this).end(),
			$[1].bindData(this,'viewRange',[]).setTimeline(this).end(),
			this._playhead.setLeft(round(this.offset2px(this.currentOffset()),2)).end()
		,true));
	};
	
	tag.prototype.showCues = function (){
		return false;
	};
	
	tag.prototype.yScale = function (){
		return 0.6;
	};
})
exports.TimelineOverview = TimelineOverview;
