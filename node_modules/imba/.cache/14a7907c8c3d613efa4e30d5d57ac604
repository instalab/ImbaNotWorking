function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');


/*

Lazy collection for datasyncer

*/

var sorterGenerator = function(value) {
	var fn;
	
	if ((typeof value=='string'||value instanceof String)) {
		var desc = false;
		
		if (value[0] == '-') {
			desc = true;
			value = value.substr(1);
		};
		
		fn = function(a,b) {
			var av = (a[value] || 0);
			var bv = (b[value] || 0);
			if (av instanceof Function) { av = av.call(a) };
			if (bv instanceof Function) { bv = bv.call(b) };
			
			var n = ((av > bv) ? 1 : (((bv > av) ? (-1) : 0)));
			return desc ? ((n * -1)) : n;
		};
	} else if (value instanceof Array) {
		var methods = value.map(function(_0) { return sorterGenerator(_0); });
		
		if (len$(value) == 2) {
			fn = function(a,b) { return methods[0](a,b) || methods[1](a,b); };
		};
	};
	
	return fn;
};

var Filters = require('./filters').Filters;

var refCounter = 0;

function Set(array){
	this._array = array || [];
	this._version = 0;
	this;
};

exports.Set = Set; // export class 
Set.prototype.touch = function (){
	this._version++;
	return this;
};

Set.prototype.version = function (){
	return this.version();
};

Set.prototype.check = function (){
	return this;
};

Set.prototype.add = function (item){
	if (this._array.indexOf(item) == -1) {
		this._array.push(item);
		this.touch();
	};
	return this;
};

Set.prototype.del = function (item){
	if (this._array.indexOf(item) > -1) {
		this._array.splice(this._array.indexOf(item),1);
		this.touch();
	};
	return this;
};

Set.prototype.toArray = function (){
	return this._array;
};

Set.prototype.filter = function (){
	var toArray_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (toArray_ = this.toArray()).filter.apply(toArray_,params);
};

Set.prototype.slice = function (){
	var toArray_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (toArray_ = this.toArray()).slice.apply(toArray_,params);
};

Set.prototype.at = function (index){
	return this.toArray()[index];
};

Set.prototype.indexOf = function (item){
	return this.toArray().indexOf(item);
};

Set.prototype.len = function (){
	return this.toArray().length;
};

Set.prototype.sel = function (o,fn){
	if(fn==undefined && typeof o == 'function') fn = o,o = {};
	if(o==undefined) o = {};
	var coll = new SubCollection(this,o);
	if (fn) { (coll.setQuery(fn),fn) };
	return coll;
};

function Collection(source,opts){
	if(opts === undefined) opts = {};
	this._ref = ("C" + (refCounter++));
	this._options = opts;
	this._source = (source instanceof Array) ? new Set(source) : source;
	this._array = [];
	this._dirty = false;
	this._version = 0; // should sync with source
	this._sourceVersion = -1;
	this._transforms = {};
	this._sorter = opts.sort;
	if (opts.sort) { this._sortFn = sorterGenerator(opts.sort) };
	if (opts.filters) {
		this.filters().set(opts.filters);
	};
	return this;
};

exports.Collection = Collection; // export class 
Collection.prototype.version = function(v){ return this._version; }
Collection.prototype.setVersion = function(v){ this._version = v; return this; };
Collection.prototype.source = function(v){ return this._source; }
Collection.prototype.setSource = function(v){ this._source = v; return this; };
Collection.prototype.__sorter = {watch: 'sorterDidSet',name: 'sorter'};
Collection.prototype.sorter = function(v){ return this._sorter; }
Collection.prototype.setSorter = function(v){
	var a = this.sorter();
	if(v != a) { this._sorter = v; }
	if(v != a) { this.sorterDidSet && this.sorterDidSet(v,a,this.__sorter) }
	return this;
};
Collection.prototype.__query = {watch: 'queryDidSet',name: 'query'};
Collection.prototype.query = function(v){ return this._query; }
Collection.prototype.setQuery = function(v){
	var a = this.query();
	if(v != a) { this._query = v; }
	if(v != a) { this.queryDidSet && this.queryDidSet(v,a,this.__query) }
	return this;
};
Collection.prototype.filters = function(v){ return this._filters; }
Collection.prototype.setFilters = function(v){ this._filters = v; return this; };
// prop filter watch: yes

Collection.prototype.store = function (){
	return this._source;
};

Collection.prototype.filters = function (){
	return this._filters || (this._filters = new Filters());
};

Collection.prototype.queryDidSet = function (query,prev){
	// if this is the first query
	this.touch();
	return this;
};

Collection.prototype.sorterDidSet = function (val){
	if ((typeof val=='string'||val instanceof String)) {
		this._sortFn = sorterGenerator(val);
	} else {
		this._sortFn = val;
	};
	
	if (this._sorter) {
		return this._array = this._array.sort(this._sortFn);
	};
	// touch
};

Collection.prototype.touch = function (){
	this._dirty = true;
	return this;
};

// def filterDidSet filter
// 	# what if we no longer have a filter?
// 	# @array = @array.filter(filter)
// 	self

Collection.prototype.check = function (){
	var source_;
	(source_ = this.source()) && source_.check  &&  source_.check();
	
	if (this._dirty || this._sourceVersion != this.source().version()) {
		this.sync();
	} else if (this._filters && this._filters.version() != this._filtersVersion) {
		this.sync();
	} else if (this.source() != this.store() && this.store().version() != this._storeVersion) {
		this.sync();
	};
	
	return this._version;
};

Collection.prototype.sync = function (){
	var sv = this.source().version();
	var fv = this._filters ? this._filters.version() : (-1);
	var mv = this.store().version();
	
	this._sourceVersion = sv;
	this._filtersVersion = fv;
	this._storeVersion = mv;
	this._dirty = false;
	
	// No need to refilter if we've only changed sorting
	var items = this._query ? this.source().filter(this._query) : this.source().slice();
	
	if (!((items instanceof Array))) { return this };
	
	// if only the filters changed we should not need to requery the parent
	
	if (this._filters) {
		items = items.filter(this._filters.fn());
	};
	
	if (this._sortFn) {
		items = items.sort(this._sortFn);
	};
	
	// now see if there is a difference from before
	var l0 = len$(this._array);
	var l1 = len$(items);
	var i = 0;
	var dirty = l1 != l0;
	
	// should sort them first? Otherwise they might still be the same really
	
	while (!dirty && i < l1){
		if (items[i] != this._array[i]) {
			dirty = true;
		};
		i++;
	};
	
	// add support for limiting?
	
	if (dirty) {
		// console.log "updated collection",@source?.name
		this._array = items;
		
		// we are clearing the transforms cache
		// this means that if we directly refer to the result of a transform
		// they are not updated automatically. Ideally transforms would
		// be special types of collections that reference their parent and
		// recalculate when needed
		this._transforms = {};
		this._version++;
	};
	return this;
};

Collection.prototype.filter = function (cb){
	return this.toArray().filter(cb);
};

Collection.prototype.first = function (cb){
	return this.filter(cb)[0];
};

Collection.prototype.map = function (cb){
	return this.toArray().map(cb);
};

Collection.prototype.slice = function (){
	var toArray_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (toArray_ = this.toArray()).slice.apply(toArray_,params);
};

Collection.prototype.at = function (index){
	return this.toArray()[index];
};

Collection.prototype.indexOf = function (item){
	return this.toArray().indexOf(item);
};

Collection.prototype.len = function (){
	return this.toArray().length;
};

Collection.prototype.toArray = function (){
	// this is where the magic happens
	this.check();
	return this._array;
};

Collection.prototype.version = function (){
	this.check();
	return this._version;
};

Collection.prototype.sel = function (o,fn){
	if(fn==undefined && typeof o == 'function') fn = o,o = {};
	if(o==undefined) o = {};
	var coll = new SubCollection(this,o);
	if (fn) { (coll.setQuery(fn),fn) };
	return coll;
};

Collection.prototype.transform = function (key,fn){
	// TODO remove?
	return this._transforms[key] || (this._transforms[key] = fn(this,key));
	// var coll = SubCollection.new(self,o)
	// coll.query = fn if fn
	// return coll
};

Collection.prototype.synced = function (target,cb){
	var v = this.check();
	if (target && target[this._ref] != v) {
		cb && cb(this);
		target[this._ref] = v;
		return false;
	};
	return true;
};

function SubCollection(){ return Collection.apply(this,arguments) };

Imba.subclass(SubCollection,Collection);
exports.SubCollection = SubCollection; // export class 
SubCollection.prototype.store = function (){
	return this._source.store();
};
