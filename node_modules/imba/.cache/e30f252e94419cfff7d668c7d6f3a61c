function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Packet = require('./Packet').Packet;
var MSG = require('../protocol').MSG;
var StreamBuffer = require('./StreamBuffer').StreamBuffer;
var WriteStream = require('../../models/File').WriteStream;

/*

Keeps track of checking whether a StreamBuffer has new data,
and then syncing that data to a receiver. Currently, the receiver
will always be a websocket - which means that the StreamSyncer
is currenlty only syncing data to the server.

In the future, an agent will most likely create syncers for each
watching client to push data through DataChannels (WebRTC).

It is also intended to be configurable. Ie. if no other sockets
are connected while you record the syncer should only sync every
5 seconds, but switch over to instant syncing (every time there is
a new event) whenever livestreaming is needed.

STATES
======

READY

CONFLICT

RECOVERING

*/


var STATE = {
	READY: 0,
	BUSY: 1,
	CONFLICT: 2,
	RECOVERING: 3
};


function StreamSyncer(stream,channel,peers){
	// should connect directly to a streamBuffer no?
	var self = this;
	self._stream = stream;
	self._buffer = stream.buffer();
	self._channel = channel; // 
	self._counter = 0;
	self._lastOffset = 0;
	self._remoteOffset = 0;
	self._timeout = null;
	self._requests = [];
	self._state = STATE.READY;
	self._peers = peers || [];
	
	self._tick = function() {
		self._timeout = null;
		return self.sync();
	};
	
	// FIXME must dispose with space
	self._callback = function(res,req) { return self.onresponse(res,req); };
	self._ontrim = function(e) { return self.ontrim(e); };
	self._buffer.on('trim',self._ontrim);
	
	self._broadcastOffset = 0;
	self._broadcastOffsets = [0];
	self;
};

exports.StreamSyncer = StreamSyncer; // export class 
StreamSyncer.prototype.stream = function(v){ return this._stream; }
StreamSyncer.prototype.setStream = function(v){ this._stream = v; return this; };
StreamSyncer.prototype.channel = function(v){ return this._channel; }
StreamSyncer.prototype.setChannel = function(v){ this._channel = v; return this; };
StreamSyncer.prototype.byteOffset = function(v){ return this._byteOffset; }
StreamSyncer.prototype.setByteOffset = function(v){ this._byteOffset = v; return this; };
StreamSyncer.prototype.duplicatePackets = function(v){ return this._duplicatePackets; }
StreamSyncer.prototype.setDuplicatePackets = function(v){ this._duplicatePackets = v; return this; };
StreamSyncer.prototype.__state = {watch: 'stateDidSet',name: 'state'};
StreamSyncer.prototype.state = function(v){ return this._state; }
StreamSyncer.prototype.setState = function(v){
	var a = this.state();
	if(v != a) { this._state = v; }
	if(v != a) { this.stateDidSet && this.stateDidSet(v,a,this.__state) }
	return this;
};

StreamSyncer.prototype.isRecovering = function (){
	return this.state() == STATE.RECOVERING;
};

StreamSyncer.prototype.hasConflict = function (){
	return this.state() == STATE.CONFLICT;
};

StreamSyncer.prototype.writer = function (){
	return this._writer || (this._writer = new WriteStream({id: this.branch().id()}));
};

StreamSyncer.prototype.recover = async function (){
	console.log("start recovering with stream",this._remoteOffset);
	if (!(this.hasConflict() || this.isRecovering())) { return };
	
	// make sure state is watching
	this.branch().timeline().setState('watching');
	// rollback - not to a specific time - but to a specific bufferOffset
	// how do we do this?
	
	// find out where the last stuff from server is?
	this.stream().buffer().trim(this._remoteOffset);
	// stream.fetchStreamBuffer
	
	// should not the syncer fetch as well?
	await this._buffer._model.fetchStreamBuffer(this.branch().api(),this._remoteOffset);
	this.setState(STATE.READY);
	return this;
};

StreamSyncer.prototype.branch = function (){
	return this.stream().owner();
};

StreamSyncer.prototype.api = function (){
	return this.branch().api();
};

StreamSyncer.prototype.latency = function (){
	var now = Date.now();
	var last = this._lastConfirmed;
	var next = this._requests[this._requests.indexOf(last) + 1];
	
	var lastLatency = last ? last.ms : 0;
	var nextLatency = next ? ((now - next.ts)) : 0;
	
	return Math.max(lastLatency,nextLatency);
};

StreamSyncer.prototype.confirm = function (next){
	this._remoteOffset = this._lastOffset = next;
	return this;
};

StreamSyncer.prototype.onresponse = function (res,req){
	// console.log 'onresponse',res,req
	// if we have already got response for later packet
	// we should not care
	this._lastResponse = res;
	
	switch (res.CODE) {
		case MSG.OK: {
			// pkg[3] = Date.now - pkg[2]
			this._lastConfirmed = req;
			this._remoteOffset = req.byteEnd;
			
			if (this.isRecovering()) {
				this.setState(STATE.READY);
			};
			break;
		}
		case MSG.UNAUTHORIZED: {
			console.warn("got message from server that we are unauthorized!");
			// If we are wrongfully trying to push to stream - force sync back to
			// last verified offset (local trim - and resync from server)
			this;
			break;
		}
		case MSG.ERR_OUT_OF_RANGE: {
			console.warn("server said we are out of range!",this.isRecovering());
			
			if (!(this.isRecovering()) && this.state() != STATE.CONFLICT) {
				// set state to recovering and reset to the last
				// offset we know that the server has confirmed
				
				// if the server returns another out of range
				// something more serious must be going on
				this.setState(STATE.RECOVERING);
				this._lastOffset = this._remoteOffset;
				this.sync();
				
				// this can happen if the server hadn't gotten as far
				// but if we are strictly out of sync with server
				// we must rollback everything that has happened since remote offset
				// and then follow along from there. At the very least
				// we should be thrown out of editing(!)
			};
			this;
			break;
		}
		case MSG.ERR_OUT_OF_SYNC: {
			console.warn("server said we are in conflict with the remote");
			if (!(this.isRecovering())) {
				this.setState(STATE.CONFLICT);
				// @lastOffset = @remoteOffset
				// sync
			};
			break;
		}
	};
	return this;
};

StreamSyncer.prototype.ontrim = function (offset){
	this._stream.api().log('syncer','ontrim',offset,this._lastOffset,this._remoteOffset);
	this._lastOffset = Math.min(this._lastOffset,offset);
	this._remoteOffset = Math.min(this._buffer._verifiedOffset,offset);
	this._lastConfirmed = null;
	this._requests = [];
	return this;
};

StreamSyncer.prototype.getPayload = function (){
	// let realFrom = channel.get(@buffer.id) or 0
	let from = this._lastOffset;
	let to = len$(this._buffer) - 1;
	
	if (this._buffer._verifiedOffset > this._lastOffset) {
		this._stream.api().log('syncer',"buffer already has a confirmed remote offset",this._lastOffset,this._buffer._verifiedOffset);
		from = this._lastOffset = this._buffer._verifiedOffset;
	};
	
	if (from >= to) {
		return;
	};
	
	let key = this.stream().id();
	var chunk = this._buffer.slice(from);
	return [MSG.STREAMAPPEND,key,from,chunk];
};

StreamSyncer.prototype.sync = function (force){
	if(force === undefined) force = false;
	if (this.branch().isLocal()) {
		return;
	};
	
	if (this.hasConflict()) {
		return;
	};
	
	// no longer sync without recording? Might end up not syncing to the very end
	// if (!branch.recording or !branch.recording.isPersisting)
	// 	return
	
	if (!this.branch().isRecording() && !force) {
		return;
	};
	
	// dont even sync to server now
	// return
	
	// return # WARN not saving to server now
	var packet = this.getPayload();
	var byteEnd = len$(this._buffer);
	
	
	if (packet) {
		console.log("write stream to server");
		this._lastOffset = byteEnd;
		this.writer().write(packet[3],{offset: packet[2]});
		return this;
		
		// there is no callback(!)
		this._lastOffset = byteEnd;
		var req = {byteEnd: byteEnd,handler: this._callback};
		this._requests.push(req);
		
		return this.channel().send(packet,req);
	};
};

StreamSyncer.prototype.schedule = function (){
	// persist to server every second - but not more
	this._timeout || (this._timeout = setTimeout(this._tick,1000));
	return this.broadcast(); // possibly delay 1ms - for batch operations
	// if branch.isRecording and branch.isHosting
	// 	sync
};

StreamSyncer.prototype.persist = function (){
	return this.sync();
};

StreamSyncer.prototype.dispose = function (){
	this._buffer.un('trim',this._ontrim);
	return this;
};

StreamSyncer.prototype.peers = function (){
	return this.api().peers();
};

StreamSyncer.prototype.broadcast = function (){
	// return if branch.isLocal # could we not broadcast a fully local cast?
	
	let offsets = this._broadcastOffsets;
	let from = this._broadcastOffset;
	let to = len$(this._buffer);
	let size = to - from;
	if (from >= to) {
		return;
	};
	
	if (size > 60000) {
		to = from + 60000;
	} else if (size < 400) { // and duplicatePackets
		let i = 0;
		while (i < 4){
			let off = offsets[i++];
			if (off && (to - off) < 400) {
				from = off;
			};
		};
	};
	
	let key = this.stream().id();
	var chunk = this._buffer.slice(from,to);
	let packet = Packet.serialize([MSG.STREAMAPPEND,key,from,chunk]);
	
	this._broadcastOffset = to;
	offsets.unshift(to);
	
	var peerIds = [];
	// this is what we send to peers
	for (let i = 0, items = iter$(this.peers()), len = items.length, peer; i < len; i++) {
		peer = items[i];
		peerIds.push(peer.id);
		// send chunks through unreliable channel
		peer.send(packet,{reliable: false});
	};
	if (len$(this._buffer) > to) {
		// should not be vulnerable to inf recursion
		this.broadcast();
	};
	return;
};

function StreamBroadcaster(){ };

exports.StreamBroadcaster = StreamBroadcaster; // export class 

