function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Actions = exports.Actions = {};

var Mousetrap = require('../../util/mousetrap');

var F = {
	ENABLED: 1,
	BUSY: 2
};

function Action(options){
	this._options = options;
	if (options.enabled != false) { this._enabled = true };
	this._cooldown = this._options.cooldown || 0;
	this._mousetraps = []; // memory leaks ftw
	this._scopes = this._options.scope || [];
	if ((typeof this._scopes=='string'||this._scopes instanceof String)) { this._scopes = [this._scopes] };
	this;
};

exports.Action = Action; // export class 
Action.register = function (name,o,cb){
	if(cb==undefined && typeof o == 'function') cb = o,o = {};
	if(o==undefined) o = {};
	if (name instanceof Object) {
		o = name;
		name = o.name;
	} else {
		o.name || (o.name = name);
		o.cmd || (o.cmd = cb);
	};
	
	return Actions[name] = new Action(o);
};

Action.lookup = function (name){
	return Actions[name];
};

Action.prototype.active = function(v){ return this._active; }
Action.prototype.setActive = function(v){ this._active = v; return this; };
Action.prototype.cooldown = function(v){ return this._cooldown; }
Action.prototype.setCooldown = function(v){ this._cooldown = v; return this; };
Action.prototype.options = function(v){ return this._options; }
Action.prototype.setOptions = function(v){ this._options = v; return this; };
Action.prototype.scopes = function(v){ return this._scopes; }
Action.prototype.setScopes = function(v){ this._scopes = v; return this; };

Action.prototype.exec = function (context,params){
	var ctx = context || this.context();
	if (!this.available(ctx)) { return false }; // should it be stopped?
	var res = this._options.cmd.call(this,ctx,params || this._options.params);
	this._lastExec = Date.now();
	return res || true;
};

Action.prototype.available = function (ctx){
	if(ctx === undefined) ctx = this.context();
	return this.enabled(ctx) && (!this._lastExec || (Date.now() - this._lastExec) > this._cooldown);
};

Action.prototype.enabled = function (ctx){
	if(ctx === undefined) ctx = this.context();
	var val = this.getOption('enabled',ctx);
	return (val == undefined) ? ((this._enabled || false)) : val;
};

Action.prototype.setEnabled = function (value){
	this._enabled = value;
	return this;
};

Action.prototype.getOption = function (name,ctx){
	if(ctx === undefined) ctx = this.context();
	var val = this._options[name];
	if (val instanceof Function) {
		val = val.call(this,ctx);
	};
	return val;
};

Action.prototype.name = function (ctx){
	return this._options.name;
};
Action.prototype.desc = function (ctx){
	return this.getOption('desc',ctx);
};
Action.prototype.icon = function (ctx){
	return this.getOption('icon',ctx);
};
Action.prototype.shortcut = function (){
	return this._options.shortcut;
};

Action.prototype.o = function (key){
	return this._options[key];
};

Action.prototype.state = function (ctx){
	if(ctx === undefined) ctx = this.context();
	return this.getOption('state',ctx);
};

Action.prototype.context = function (){
	return this._options.context;
};

Action.prototype.space = function (){
	return this.context();
};

Action.prototype.clone = function (opts){
	// console.log "clone options",opts
	if(opts === undefined) opts = {};
	var o = Object.create(this._options,{});
	
	for (let v, i = 0, keys = Object.keys(opts), l = keys.length, k; i < l; i++){
		k = keys[i];v = opts[k];o[k] = v;
	};
	
	return new Action(o);
};

Action.prototype.mousetrap = function (){
	var self = this;
	return self._mousetrap || (self._mousetrap = function(e,combo) {
		if (e.target.matches('textarea,input,button,.input')) {
			// TODO make this work again
			// (client.state == 'paused' or client.state == 'play')
			if (combo == 'space' && false) {
				e.preventDefault();
			} else if (!(/mod|ctrl|shift/).test(combo)) {
				return;
			};
		} else if (e.target.closest('.Overlay')) {
			console.log('no mousetrap inside overlay');
			return;
		};
		
		// console.log "mousetrap trigger",e,combo
		if (self.exec(self.context(),combo)) {
			return false;
		} else {
			return true;
		};
	});
};

Action.prototype.bindToMousetrap = function (trap){
	if (this.shortcut()) {
		trap.bind(this.shortcut(),this.mousetrap());
		trap._toDispose || (trap._toDispose = []);
		return trap._toDispose.push(this.shortcut());
	};
};

function ActionManager(context){
	var self = this;
	self._context = context;
	self._actions = [];
	self._mousetraps = [];
	self._mappings = {};
	self._combinations = [];
	self.onkeycombo = self.onkeycombo.bind(self);
	
	self._scopes = {
		slides: function() { return self.space().slides().visible(); },
		recording: function() { return self.space().recording(); },
		browser: function() { return self.space().browser().visible(); },
		watching: function() { return !self.space().isEditing(); },
		paused: function() { return self.space().isPaused(); },
		playing: function() { return self.space().isPlaying(); },
		playback: function() { return self.space().isPlaying() || self.space().isPaused(); },
		editing: function() { return self.space().isEditing(); },
		brushup: function() { return self.space().isAnnotating(); },
		space: function() { return true; }
	};
	
	for (let action, i = 0, keys = Object.keys(Actions), l = keys.length, name; i < l; i++){
		name = keys[i];action = Actions[name];self.get(name);
	};
	self;
};

exports.ActionManager = ActionManager; // export class 
ActionManager.prototype.context = function(v){ return this._context; }
ActionManager.prototype.setContext = function(v){ this._context = v; return this; };
ActionManager.prototype.scopes = function(v){ return this._scopes; }
ActionManager.prototype.setScopes = function(v){ this._scopes = v; return this; };

ActionManager.prototype.space = function (){
	return this._context;
};

ActionManager.prototype.get = function (name){
	var action = this._actions[name];
	
	if (!action && Action.lookup(name)) {
		action = Action.lookup(name);
		action = this._actions[name] = Action.lookup(name).clone({context: this.context()});
		this._actions.push(action);
		let combos = action.shortcut();
		if (!((combos instanceof Array))) { combos = [combos] };
		
		for (let i = 0, len = combos.length, combo; i < len; i++) {
			combo = combos[i];
			if (!combo) { continue; };
			if (this._combinations.indexOf(combo) < 0) {
				this._combinations.push(combo);
			};
			this._mappings[combo] || (this._mappings[combo] = []);
			this._mappings[combo].push(action);
		};
	};
	
	return action;
};

ActionManager.prototype.exec = function (name){
	var action = this.get(name);
	return action && action.exec();
};

ActionManager.prototype.trap = function (mousetrap,scope){
	// dont care about scope here?
	if (this._mousetraps.indexOf(mousetrap) == -1) {
		this._mousetraps.push(mousetrap);
	};
	
	mousetrap.bind(this._combinations,this.onkeycombo);
	return this;
};

ActionManager.prototype.onkeycombo = function (e,combo){
	// console.log "triggered combo!",combo,e:target
	var self = this;
	if (e.target.matches('textarea,input,button,.input')) {
		if (!(/mod|ctrl|shift/).test(combo)) {
			return;
		};
	};
	
	if (e.target.closest('.Overlay')) {
		// log 'no mousetrap inside overlay'
		return;
	};
	
	let actions = self._mappings[combo];
	
	for (let i = 0, items = iter$(actions), len = items.length, action; i < len; i++) {
		action = items[i];
		let allow = action.scopes().some(function(scope) {
			return scope.split("+").every(function(item) { return !self._scopes[item] || self._scopes[item](action); });
		});
		
		// unless allow
		// 	console.log "action was blocked",action.o(:name),action.scopes
		
		if (!(allow && action.enabled(action.context()))) {
			continue;
		};
		
		if (action.exec(action.context(),combo)) {
			return false;
		};
	};
	
	return true;
};

ActionManager.prototype.mousetrap = function (el,scope){
	if (!el.MOUSETRAP) {
		el.MOUSETRAP = new Mousetrap(el);
		this.trap(el.MOUSETRAP,scope);
	};
	return el.MOUSETRAP;
};

ActionManager.prototype.dispose = function (){
	for (let i = 0, items = iter$(this._mousetraps), len = items.length, trap; i < len; i++) {
		trap = items[i];
		trap.unbind(this._combinations);
		// console.log "dispose mousetrap"
		// for combo in trap.@toDispose
		//	trap.unbind(combo)
		trap.reset();
	};
	this._mousetraps = [];
	this._actions = [];
	return this._context = null;
};



