function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba'), _1 = Imba.createElement;
var protocol$ = require('./protocol'), ACTION = protocol$.ACTION, SCON = protocol$.SCON, MSG = protocol$.MSG, SPIV = protocol$.SPIV;
var Widget = require('./widgets/widget').Widget;
var Recording = require('./core/Recording').Recording;
var Timeline$ = require('./core/Timeline'), AbsTimeline = Timeline$.AbsTimeline, PubTimeline = Timeline$.PubTimeline, PlainTimeline = Timeline$.PlainTimeline;

var List = require('./util/List').List;
var Entity = require('../models/Entity').Entity;

var StreamSyncer = require('./core/StreamSyncer').StreamSyncer;
var StreamAction$ = require('./core/StreamAction'), StreamAction = StreamAction$.StreamAction, TextAction = StreamAction$.TextAction, TextEdit = StreamAction$.TextEdit, TextInsert = StreamAction$.TextInsert, TextDelete = StreamAction$.TextDelete, TextSelection = StreamAction$.TextSelection;
var StreamBuffer = require('./core/StreamBuffer').StreamBuffer;
var Stream = require('./core/Stream').Stream;
var Machine = require('./core/Machine').Machine;
var LocalBranchDialog = require('./views/LocalBranchDialog').LocalBranchDialog;
var Start = require('./views/Start').Start;

var util = require('../util');

// externs;

var tracking = require('./tracking');

function Branch(space,parent,model){
	// should it be possible to init a branch before parent is loaded?
	
	var v_;
	this._space = space;
	this._parent = parent;
	this._model = (model instanceof Entity) ? model : this.api().db().read(model);
	
	this._currentOffset = 0;
	// create cues for these maybe?!
	this._draft = this._model.get('draft') || {start: 0,cues: [],audio: []};
	this._pub = this._model.get('pub') || this._model.get('data'); // or model:data
	
	this._stream = new Stream(this._model.stream(),this,this.seed());
	this._branches = new List(this);
	this._ancestors = parent ? parent.ancestors().concat(parent) : [];
	// console.log "initing branch",SCON.clone(model.@data)
	
	if (parent) {
		parent.branches().add(this,this.id());
	};
	
	// should we not switch to abs only when we actively want to continue?
	// Is timeline relevant when we are in editing-mode?
	// 
	if (this._pub && model.isEnded()) { // state ==  @pub:audio # and (!isMine or api.isEmbed or api.isMobile)
		var typ = this._pub.audio ? PubTimeline : AbsTimeline;
		this.setTimeline((this.setPubTimeline(v_ = new typ(this,this._pub)),v_));
	} else {
		this.setTimeline((this.setAbsTimeline(v_ = new PlainTimeline(this,this._draft)),v_)); // AbsTimeline
	};
	
	this._currentOffset = this.timeline().currentOffset();
	this;
};

Imba.subclass(Branch,Widget);
exports.Branch = Branch; // export class 
Branch.register('branch');

Branch.modelDataFromEvent = function (event,opts){
	if(opts === undefined) opts = {};
	var par = event.branch();
	var offset = par.timeline().currentOffset();
	var time = par.timeline().currentTime();
	var api = SCRIMBA_API;
	var uid = api.uid();
	// var snap = par.toSnapshot
	var title = ("Local edits at " + util.msToStr(time));
	
	var data = {
		type: 'scrim', // note?
		uid: uid,
		pid: api.peer().id,
		
		data: {
			title: title,
			spiv: SPIV,
			seed: [par.id(),event.index() || 0,Math.round(offset)]
		},
		
		crets: new Date(),
		modts: new Date(),
		v: -2
	};
	
	if (!uid) {
		// what?
		data.LOCAL = true;
	};
	
	for (let v, i = 0, keys = Object.keys(opts), l = keys.length, k; i < l; i++){
		k = keys[i];v = opts[k];data[k] = v;
	};
	
	return data;
};

Branch.modelFromEvent = function (event){
	// start as offline thing
	// console.log "branch!",data
	var data = this.modelDataFromEvent(event);
	return event.branch().space().api().db().entities().build(data);
};

Branch.branchFromEvent = function (source){
	
	var model = this.modelFromEvent(source);
	var snap = source.branch().toSnapshot();
	var api = source.branch().api();
	// api.sendTracking(tracking.TYPES.CREATE_BRANCH, [model:id, model:parent_id, model:parent_index, model:parent_offset])
	// add initial action to stream
	// TODO this should look very different
	// console.log 'create branch from event',source,model
	// do we really want this snapshot?
	var buf = StreamBuffer.encode([-ACTION.SNAPSHOT,[snap]]); // ,-ACTION.LOCK,[api.sid,api.uid]
	var branch = new LocalBranch(source.branch().space(),source.branch(),model);
	
	branch._initialSnapshot = snap;
	branch._parentPlayState = source.branch().timeline().state();
	branch._isLoaded = true;
	return branch;
};

// the currently active timeline for this branch
Branch.prototype.absTimeline = function(v){ return this._absTimeline; }
Branch.prototype.setAbsTimeline = function(v){ this._absTimeline = v; return this; };
Branch.prototype.pubTimeline = function(v){ return this._pubTimeline; }
Branch.prototype.setPubTimeline = function(v){ this._pubTimeline = v; return this; };
Branch.prototype.__timeline = {watch: 'timelineDidSet',name: 'timeline'};
Branch.prototype.timeline = function(v){ return this._timeline; }
Branch.prototype.setTimeline = function(v){
	var a = this.timeline();
	if(v != a) { this._timeline = v; }
	if(v != a) { this.timelineDidSet && this.timelineDidSet(v,a,this.__timeline) }
	return this;
};

Branch.prototype.draft = function(v){ return this._draft; }
Branch.prototype.setDraft = function(v){ this._draft = v; return this; };
Branch.prototype.branches = function(v){ return this._branches; }
Branch.prototype.setBranches = function(v){ this._branches = v; return this; };
Branch.prototype.recording = function(v){ return this._recording; }
Branch.prototype.setRecording = function(v){ this._recording = v; return this; };
Branch.prototype.ancestors = function(v){ return this._ancestors; }
Branch.prototype.setAncestors = function(v){ this._ancestors = v; return this; };
Branch.prototype.currentOffset = function(v){ return this._currentOffset; }
Branch.prototype.setCurrentOffset = function(v){ this._currentOffset = v; return this; };
Branch.prototype.machine = function(v){ return this._machine; }
Branch.prototype.setMachine = function(v){ this._machine = v; return this; };
Branch.prototype.me = function(v){ return this._me; }
Branch.prototype.setMe = function(v){ this._me = v; return this; };
Branch.prototype.__host = {watch: 'hostDidSet',name: 'host'};
Branch.prototype.host = function(v){ return this._host; }
Branch.prototype.setHost = function(v){
	var a = this.host();
	if(v != a) { this._host = v; }
	if(v != a) { this.hostDidSet && this.hostDidSet(v,a,this.__host) }
	return this;
}; // :hostOrStateDidSet
Branch.prototype.__state = {watch: 'stateDidSet',name: 'state'};
Branch.prototype.state = function(v){ return this._state; }
Branch.prototype.setState = function(v){
	var a = this.state();
	if(v != a) { this._state = v; }
	if(v != a) { this.stateDidSet && this.stateDidSet(v,a,this.__state) }
	return this;
}; // :hostOrStateDidSet

// container for the events in this branch
Branch.prototype.stream = function(v){ return this._stream; }
Branch.prototype.setStream = function(v){ this._stream = v; return this; };

Branch.prototype.id = function (){
	return this._model.id;
};

Branch.prototype.api = function (){
	return this.space().api();
};

Branch.prototype.inspect = function (){
	return ("Branch(id=" + this.id() + ")");
};

Branch.prototype.title = function (){
	return "Branch";
	// model:title or "Branch"
};

Branch.prototype.model = function (){
	return this._model;
};

Branch.prototype.data = function (){
	return this._model;
};

Branch.prototype.parent = function (){
	return this._parent;
};

Branch.prototype.connectToMachine = function (o){
	var machine_, v_;
	if(o === undefined) o = {};
	(machine_ = this.machine()) || ((this.setMachine(v_ = new Machine(this,Object.assign({},this.model().cli() || {},o))),v_));
	return this.machine().connect();
};

Branch.prototype.dispose = function (){
	this._stream && this._stream.dispose  &&  this._stream.dispose();
	this._syncer && this._syncer.dispose  &&  this._syncer.dispose();
	if (this.model()._branch == this) {
		this.model()._branch = null;
	};
	return this;
};

Branch.prototype.tick = function (){
	this.setHost((this.space().peers().has(this.model().host()) || this.model().isLocal()) ? this.model().host() : null);
	this.setState(this.model().state());
	return this;
};

Branch.prototype.syncer = function (){
	return this._syncer || (this._syncer = new StreamSyncer(this.stream(),this.api().socket()));
};

Branch.prototype.head = function (){
	return this._stream.tail();
};

Branch.prototype.seed = function (){
	return this._seed || (this._seed = this._parent.stream().actionAtIndex(this.model()._data.data.seed[1]));
};

Branch.prototype.ancestors = function (){
	return this._ancestors;
};

Branch.prototype.branch = function (){
	return this;
};

Branch.prototype.setup = function (){
	return this;
};

Branch.prototype.type = function (){
	return this.model().get('type') || 'cast';
};

Branch.prototype.isInScope = function (){
	var other = this.space().branch();
	while (other){
		if (other == this) {
			return true;
		};
		other = other.parent();
	};
	return false;
};

Branch.prototype.isPublished = function (){
	return this.model().isPublished();
};

// is it disallowed to record more or continue editing this cast?
Branch.prototype.isLocked = function (){
	return this.isPublished();
};

Branch.prototype.isSignificant = function (){
	return this.stream().duration() > 0;
};

Branch.prototype.isTemplate = function (){
	return this.type() == 'template';
};
Branch.prototype.isLab = function (){
	return this.type() == 'lab';
};
Branch.prototype.isNote = function (){
	return this.type() == 'note';
};
Branch.prototype.isFork = function (){
	return this.type() == 'fork';
};
Branch.prototype.isTutorial = function (){
	return this.type() == 'tutorial';
};

Branch.prototype.isLocal = function (){
	return this.model().isLocal() && (!this.model().peer() || this.model().peer() == this.api().peer());
}; // breaks demo?
Branch.prototype.isMine = function (){
	return this.model().user() == this.api().user() || this.model().isLocal();
};
Branch.prototype.isActive = function (){
	return this.space().branch() == this;
};

Branch.prototype.isEditing = function (){
	return this.timeline().isEditing();
};
Branch.prototype.isRecording = function (){
	return !(!this.stream().recording());
}; // timeline.isRecording
Branch.prototype.isWatching = function (){
	return this.timeline().isWatching();
};
Branch.prototype.isPlaying = function (){
	return this.timeline().isPlaying();
};
Branch.prototype.isPaused = function (){
	return this.timeline().isPaused();
};
Branch.prototype.isAnnotating = function (){
	return this.timeline().isAnnotating();
};
Branch.prototype.isLive = function (){
	return this.timeline().isLive();
};

Branch.prototype.setMode = function (mode){
	return this.timeline().setState(mode);
};

Branch.prototype.mode = function (){
	return this.timeline().state();
};

// TODO cleanup all these conditions - many are deprecated and/or wrong after refactorings

Branch.prototype.isForkable = function (){
	return this.type() != 'fork' && (!(this.isLab()) || !(this.isMine())) && this.model().isForkable();
};

Branch.prototype.isUnavailable = function (){
	return Imba.indexOf(this.state(),['ending','processing','disposed']) >= 0;
};

Branch.prototype.hasUnsavedChanges = function (){
	return this.model().isLocal() || this._unsavedChanges;
};

// TODO Look into general Entity.canPublish
Branch.prototype.hasUnpublishedChanges = function (){
	return !this.model().pub || (this.model().draft && !SCON.compare(this.model().draft.cues,this.model().pub.cues));
};

Branch.prototype.hasRecordings = function (){
	return len$(this.stream().recordings()) > 0;
};

Branch.prototype.hasDuration = function (){
	return this.hasRecordings() || this.draft().end;
};

Branch.prototype.canEdit = function (){
	return this._isLoaded && (this.isLocal() || (this.stream().currentSID() == this.api().pid()) || !this.stream().currentSID());
};

// TODOEDIT
Branch.prototype.canPush = function (action){
	// as long as we are live - we should be able to push?
	// space.cursor.current == head and
	// but what if we are not fully synced up?
	return this.isLive() && this.stream().canPush(action) && (this.space().me().isActive() || this.isHosting()); // or I am host?
};

Branch.prototype.isHosting = function (){
	// or just model.peer = api.peer?
	return this.model().host() == this.api().peer();
};

Branch.prototype.canPublish = function (){
	return !(this.isLocal()) && this.hasRecordings() && this.hasUnpublishedChanges() && !(this.hasUnsavedChanges()) && !this.api().isMobile();
};

Branch.prototype.canAnnotate = function (){
	return this.hasRecordings() && !this.api().ua().isPhone() && (this.timeline() instanceof AbsTimeline);
};

Branch.prototype.canRecord = function (){
	return this.isHosting() && !(this.isRecording()) && !this.api().isMobile();
};

Branch.prototype.canGoLive = function (){
	return this.isHosting() && this.canRecord() && !(this.isRecording()) && !(this.hasRecordings());
};

Branch.prototype.isBroadcasting = function (){
	return this.isRecording() || (!(this.isLocal()) && this.host() && this.state() == 'live');
};


Branch.prototype.onpacket = function (packet){
	// find agent for packet
	// create the packet here(!)
	var ary;
	let typ = packet.CODE;
	let pid = packet.pid();
	let sender = this.space().agents().first(function(agent) { return agent.pid() == pid; });
	
	if (typ >= MSG.STREAMAPPEND && MSG.STREAMEND >= typ) {
		
		if (typ == MSG.STREAMAPPEND) {
			let timeAdjustment = (packet._localTime - packet._remoteTime) - packet._jitter;
		};
		this.stream().buffer().onpacket(packet);
	} else if (typ == MSG.AGENTLIVE) {
		
		let o = packet[2];
		// let timeSinceSent = packet.@remoteTime - o:ts
		if ((packet._remoteTime - o.ts) > 100) {
			return;
		};
		
		let localTime = packet._adjustedLocalTime;
		let before = this.stream().nextTimeOffset();
		this.stream().anchorTime({now: localTime,offset: o.offset}); // jitterBased?
		this.timeline().setLiveLatency(window.JITTER_VARIANCE || packet._jitterVariance);
		
		console.log("agent live ping",packet[1],packet[2],packet._adjustedLocalTime);
		this.space().peers().update(o.peers);
		// try to connect to all peers - according to host
		
		if (o.end) {
			// close all peer-connections
			console.log("closing peers!!");
			this.api().peers().map(function(peer) {
				return peer.socket().close();
			});
		};
	} else if (typ == MSG.AGENTPUSH) {
		// console.log "agent push",packet,packet[4]
		// need the correct agent -- explicitly
		var agent = this.space().__lookup(packet[2]);
		// control this?!
		// var agent = space.agents.find(do $1.peer == packet.peer)
		var ary = iter$(packet[3]);var code = ary[0],params = ary[1];
		var meta = packet[4];
		var action = this.action(code,params,{agent: agent});
		var states = agent._rejects || (agent._rejects = {}); // connect to peer?
		var reject = false;
		var sel;
		action._branch = this;
		action._agent = agent;
		
		var unsynced = this.stream().actions().slice(meta.index);
		
		if ((action instanceof TextAction) && meta.sel) {
			let file = action.target();
			sel = file.selections(agent);
			let state = states[file.id()];
			
			if (state && state.batch && meta.batch == state.batch) {
				// console.warn "event from batch that is already rejected",meta,action
				reject = true;
			} else if (!SCON.compare(sel,meta.sel)) {
				console.warn("Rebase TextAction",meta,sel,meta.sel);
				// if action isa TextEdit
				if (!action.rebase(meta)) {
					states[file.id()] = meta;
					reject = true;
				};
			};
		};
		
		if (agent) {
			if (reject) {
				// console.warn "rejecting",action
				action._params = [action._type,action._params,sel];
				action._type = ACTION.REJECT;
				action = this.action(ACTION.REJECT,action._params);
			};
			// push_(type,params,agent: agent)
			this.space().__push(action,{agent: agent});
		};
	} else if (typ == MSG.AGENTJOIN) {
		// console.log "asked host to join space!!",packet[1],packet[2]
		console.log("asked host to join space",this.isHosting(),this.isLive());
		if (this.isHosting() && this.isLive()) {
			// should make sure the peer is loaded in db?
			let params = packet[2];
			let pid = packet.peer().id;
			// TODO createAgent should make sure these properties are set if agent exists
			let agent = this.space().createAgent(
				{pid: pid,
				token: params.token,
				showPointer: true,
				follows: this.space().me().id(),
				offline: false}
			);
		};
	} else if (typ == MSG.AGENTSAVE) {
		// console.log "AGENT WNTS TO SAVE",packet,sender
		let file = this.space().__lookup(packet[2]);
		if (file && this.isBroadcasting()) { file.quicksave() };
	};
	return this;
};

Branch.prototype.addLocalEvent = function (event,meta){
	var _params_;
	if(meta === undefined) meta = {};
	event.AGENT || (event.AGENT = (meta && meta.agent || this.space().me())); // rly?
	event._agent = event.AGENT; // ? event.AGENT.id : null
	event._branch = this;
	
	if (!(this.isHosting()) && !(this.isLocal())) {
		let meta = (_params_ = event._params).META || (_params_.META = {});
		// console.log "trying to add local event when there is a real host(!)",event
		if (this.stream().stash().push(event,meta)) {
			if (this.host()) {
				let aid = event.agent().id();
				this.host().send([MSG.AGENTPUSH,this.id(),aid,[event._type,event._params],meta]);
			};
		};
		return event;
	};
	
	// see if we are hosting
	this.stream().sync();
	this.forceToEnd();
	var action = this.stream().write(event,meta);
	
	if (!action) {
		console.warn("action rejected by stream");
		event.discard();
		return;
	};
	
	event.ACTION = action;
	
	this.forceToEnd();
	this.syncer().schedule();
	
	// if you need to lock - also push locals?
	if (this.isWatching()) {
		this.setMode('editing');
	};
	
	return action;
};

Branch.prototype.forceToEnd = function (){
	var action;
	if (action = this.head()) {
		this.space().cursor().sync(action);
	};
	return this;
};

Branch.prototype.currentOffset = function (){
	return (this._currentOffset == -1) ? ((this._stream.duration() || 0)) : this._currentOffset;
};

// recursively update currentOffset for ancestoral branches
// should probably give a more descriptive name
Branch.prototype.didEnter = function (from){
	// console.log "didEnter!",from
	if (this.parent()) {
		this.parent().setCurrentOffset(this.model().parent_offset);
		this.parent().didEnter();
		
		if (from == this.parent()) {
			// what if parent doesnt really have a timeline to speak of?
			if (this.parent().isPlaying()) { this.parent().timeline().pause() };
		};
	};
	
	if (!(this.isLocal())) {
		this.space().socket().join(this.id());
	};
	
	if (this.space().trunk().isLab() && this.isLocal()) {
		((_1(LocalBranchDialog)).setData(this).end()).show();
	};
	return this;
};

Branch.prototype.didLeave = function (to){
	if (this.isEditing()) {
		this.log('go from editing to watching!!!',this);
		this.setMode('watching');
	};
	
	var scoped = this.isInScope();
	
	if (this.isInScope()) {
		return;
	};
	
	if (this.isLocal()) {
		// be careful about infinite looping here?
		// should not autodiscard?
		// discard unless isSignificant
		this;
	} else {
		this.space().socket().leave(this.id());
	};
	
	if (this.parent()) {
		return this.parent().didLeave(to);
	};
};

Branch.prototype.enter = function (){
	if (this.isActive()) {
		return this;
	};
	
	// We indirectly tell the space which branch we're at
	// by setting the current timeline. Should be refactored
	this.space().setTimeline(this.timeline());
	this.space().tick();
	return this;
};

Branch.prototype.leave = function (){
	if (this.isActive()) { return this.space().navigateTo(this.parent()) };
};

Branch.prototype.discard = function (){
	if (this.isLocal()) {
		if (this.timeline().isEditing()) { this.timeline().setState('watching') };
		if (this.isActive()) this.leave();
		if (this.parent()) { this.parent().branches().remove(this) };
		this.model().del(true);
		
		if (this.branch()._parentPlayState) {
			this.parent().timeline().setState(this.branch()._parentPlayState);
		};
	};
	return this;
};

Branch.prototype.stateDidSet = function (state,prev){
	if (state == 'preparing') {
		if (this.host().isMe()) {
			if (this.model().cli()) { return this.connectToMachine() };
		};
	} else if (state == 'live') {
		if (this.host() && !this.host().isMe()) {
			// console.log "request to join"
			return this.requestToJoin();
		};
	};
};

Branch.prototype.hostDidSet = function (host,prev){
	if (host) {
		if (host.isMe()) {
			this.startHosting();
		} else {
			if (this.state() == 'live') this.requestToJoin();
		};
	} else if (prev) {
		this.space().setUserMedia(null);
	};
	return this;
};

Branch.prototype.requestToJoin = async function (){
	if (!(this.host() && this.host() != this.api().peer())) { return };
	if (!this.space().isSpectating()) { return };
	// could be sent over webrtc if already working?
	// should be sent like a packet?
	// console.log "requesting to join"
	// var req = {eid: model:id, token: space.spectator.token}
	// space.view.alert("Requesting to join ({req:eid})")
	
	// host.socket.sendRequest(req)
	// TODO should spectate instead be sent out to the model - then
	// let the server take care of passing it through to peer?
	// we should already be spectating this, no?
	await this.api().isPeerConnected();
	this.model().fetchStreamBuffer(this.api(),this.stream().buffer().size());
	this.host().socket().open(this.model().id);
	return this.host().send([MSG.AGENTJOIN,this.model().id,{token: this.space().spectator().token()}]);
	// space.view.showJoinDialog(self)
};

Branch.prototype.load = async function (){
	this.model()._branch = this;
	
	if (this.isLocal() || this.model().peer() || this.space().option('demo')) {
		this.stream().sync();
		this._isLoaded = true;
		return Promise.resolve(this);
	};
	
	// if $web$ and !model.isLocal
	// 	@myFork = model.branches.filter(do $1:type == 'fork' and $1:uid == api.uid)[0]
	
	if (this._isLoaded) {
		this.log("already loaded!");
	};
	
	// TODO fetchStreamBuffer should not be synchronous. Could render scrim and then
	// continously loading more of the stream, as long as we know the final duration etc
	await this.model().fetchStreamBuffer(this.api());
	this.api().log('streamsync',this.timeline().currentOffset());
	this.stream().actionAtOffset(this.timeline().currentOffset());
	this.stream().sync();
	this._isLoaded = true;
	this.api().log('streamsync');
	return this;
};

// used to replace the existing stream with a single snapshot.
// Just for development currently.

Branch.prototype.refreshBranches = function (){
	// TODO REMOVE
	return this;
	var coll = this.model().branches();
	var v = coll.check();
	if (this._branchesVersion == v) {
		return;
	};
	
	this._branchesVersion = v;
	
	for (let i = 0, items = iter$(coll), len = items.length, item; i < len; i++) {
		// create / init branches here
		item = items[i];
		if (!this._branches.has(item.id)) {
			// should add them directly no?
			new Branch(this.space(),this,item).load(); // we are loading branches instantly
		};
	};
	return this;
};

Branch.prototype.loadChildBranch = function (item){
	// TODO REMOVE
	if (!this._branches.has(item.id)) {
		// should add them directly no?
		// log "loadChildBranch",@isLoaded
		return new Branch(this.space(),this,item).load(); // we are loading branches instantly
	} else {
		return Promise.resolve(this._branches.get(item.id));
	};
};

Branch.prototype.widgets = function (){
	return this.space().widgets();
};

Branch.prototype.record = async function (o){
	var offset_;
	if(o === undefined) o = {};
	if (!(this.canRecord())) { return Promise.reject("Not allowed to record") };
	// await save
	if (o.live) {
		true;
	};
	await (((typeof (offset_ = o.offset)=='number'||offset_ instanceof Number)) ? this.trimToTimeOffset(o.offset) : Promise.resolve(this));
	this.forceToEnd();
	var rec = new Recording(this,o);
	return rec.start();
};

Branch.prototype.startRecording = function (){
	this.push_(ACTION.RECSTART,[]);
	for (let i = 0, items = iter$(this.space().mediaStreams()), len = items.length; i < len; i++) {
		this.space().recordMediaStream(items[i]);
	};
	return this;
	// if stream.@recording
	//	stream.@recording.upload
	
	// go through peers and record whatever audio there is
};

Branch.prototype.stopRecording = function (){
	if (!this.stream().recording()) { return this };
	
	for (let i = 0, items = iter$(this.space().mediaStreams()), len = items.length, stream; i < len; i++) {
		stream = items[i];
		if (stream._recording) {
			stream._recording.upload();
			stream._recording = null;
		};
	};
	
	this.push_(ACTION.RECSTOP,[]);
	// should we not continue streaming the remainder of the stream?
	return this.syncer().sync(true);
};

Branch.prototype.trimToTimeOffset = function (timeOffset){
	var action = this.stream().actionAtOffset(timeOffset);
	return this.trimToAction(action,timeOffset);
};

Branch.prototype.trimToAction = function (action,timeOffset,appendTrimEvent){
	var self = this;
	throw "not implemented";
	return new Promise(function(resolve,reject) {
		if ((typeof action=='number'||action instanceof Number)) {
			action = self.stream().actionAtIndex(action);
		};
		
		timeOffset || (timeOffset = action.timeOffset());
		
		var dirty = false;
		var addTime = Math.max(timeOffset - action.timeOffset(),0);
		// TODO - should wait for space to successfully sync to action
		self.space().cursor().sync(action);
		self.stream().buffer().trim(action._byteEnd);
		
		var msg = [[MSG.STREAMTRIM,self.id(),action._byteEnd,self.stream().currentSID() || '']];
		
		self.log("trimToTimeOffset",timeOffset,action,msg);
		
		if (appendTrimEvent || addTime) {
			msg.push(addTime || 0,-ACTION.TRIM,[]);
		};
		
		self.api().send(StreamBuffer.encode(msg),function(res) {
			
			let draftData = self.timeline().cues().trimCuesAndAudio(timeOffset);
			self.log("responded from trim",res,draftData);
			// draft:end = timeOffset # Math.min(draft:end,timeOffset)
			self.model().save({draft: self.draft()});
			return resolve(self);
		});
		
		return self;
	});
};

Branch.prototype.toSnapshot = function (o){
	if(o === undefined) o = {};
	var snap = {};
	var event = this.space().cursor().current();
	o.local = true;
	
	if (event.branch() != this) {
		throw "cannot create snapshot for wrong branch",event;
	};
	
	snap.seed = [this.model().id,event.index() || 0,Math.round(this.timeline().currentOffset())];
	snap.spiv = SPIV;
	
	var widgets = this.widgets().map(function(item) {
		if (!(o.exclude && Imba.indexOf(item.TYPE,o.exclude) >= 0)) {
			return item.serialize(o,snap);
		};
	});
	
	snap.widgets = widgets.filter(function(item) { return item; });
	return snap;
};

Branch.prototype.trySave = function (){
	if (!this.model().isLocal()) {
		return Promise.resolve(this);
	};
	return this.uxa().open((_1(StreamDialog)).setData(this).end());
};

Branch.prototype.startAnnotating = function (){
	if (!(this.canAnnotate())) { return };
	this._frozenDraft = JSON.stringify(this.draft());
	this.log('startAnnotating');
	this.timeline().setIsAnnotating(true);
	return this;
};

Branch.prototype.stopAnnotating = function (cues){
	if (JSON.stringify(this.draft()) != this._frozenDraft) {
		this.save({draft: this._draft});
	};
	
	this.timeline().setIsAnnotating(false);
	return this;
};

Branch.prototype.startHosting = async function (){
	var origin;
	if (!(this.isHosting())) { return };
	if (this.me() || this.space().option('demo')) { return };
	
	var me = this.space().createAgent(
		{pid: this.api().pid(),
		uid: this.api().uid(),
		token: this.space().spectator().token(),
		offline: false,
		host: true}
	);
	this.setMe(me);
	this.space().agent().setFollows(me);
	this.space().setMe(me);
	
	if (this.model().cli()) {
		await this.connectToMachine();
		let readme = this.space().fs().find(/\/readme(\.(md|txt))?/i);
		if (readme) { (this.space().primaryEditor().setFile(readme),readme) };
		try {
			if (origin = this.model().git().origin.match(/github\.com\/([\w\-]+)\/([\w\-]+)/)) {
				this.log("found github origin",origin);
			};
		} catch (e) { };
		
		await this.saveModel();
	} else {
		this.space().fs().mkfile('readme.md',{type: 'file',name: 'readme.md',body: 'Hello there'});
		this.space().fs().mkfile('app.js',{type: 'file',name: 'app.js',body: 'var array = [1,2,3,4];'});
		let readme = this.space().fs().find(/\/readme(\.(md|txt))?/i);
		if (readme) { (this.space().primaryEditor().setFile(readme),readme) };
		await this.saveModel();
	};
	return this;
};

Branch.prototype.saveModel = async function (){
	if (this.model().isLocal()) {
		if (!this.api().user()) {
			this.space().view().uxa().open((_1(Start).flag('dialog')).setData(this).end());
			await this.api().githubLoginPromise();
		};
		
		let res = await this.api().rpc('scrimCreate.msgpack',[this.model()._data]);
		return App.router().replace(this.model().url() + ("?secret=" + (res.secret())));
	};
};



Branch.prototype.save = async function (updates){ // full = false
	if(updates === undefined) updates = {};
	console.log("Branch#save deprecated",updates,this);
	
	var wasLocal = this.model().isLocal();
	
	await this.api().tryLogin();
	
	if (this.stream().duration() != 0) { this.draft().end = this.stream().duration() };
	
	var upd = {
		draft: this._draft
	};
	
	if (updates instanceof Object) {
		for (let value, i = 0, keys = Object.keys(updates), l = keys.length, key; i < l; i++){
			key = keys[i];value = updates[key];upd[key] = value;
		};
	};
	
	if (wasLocal || !this.model().uid) {
		upd.uid || (upd.uid = this.api().uid());
	};
	
	if (!this.api().uid()) {
		throw "not allowed to save unless logged in";
	};
	
	if (!this.model().uid) {
		upd.uid = this.api().uid();
	};
	
	this.log("saving model",upd);
	
	await this.model().save(upd);
	
	// because our branch is no longer local we should be able to sync
	await this.syncer().persist(true);
	return this;
};

Branch.prototype.__uid = function (){
	return 0;
};

function LocalBranch(){ return Branch.apply(this,arguments) };

Imba.subclass(LocalBranch,Branch);
exports.LocalBranch = LocalBranch; // export class 
LocalBranch.prototype.populate = function (){
	// could happen in a different manner?
	var agentData = SCON.clone(this.space().me()._data);
	// update agent.follows chain
	agentData.token = this.space().spectator().token();
	this.setMe(this.space().createAgent(agentData).widget());
	this.space().setMe(this.me());
	return this;
};

function Trunk(){ return Branch.apply(this,arguments) };

Imba.subclass(Trunk,Branch);
exports.Trunk = Trunk; // export class 
Trunk.prototype.seed = function (){
	return null;
};
