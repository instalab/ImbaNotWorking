function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
/*

Helper class that represents the local viewer / agent
Keeps track of the widget options / settings viewer
overrides, and sets up triggers to clear them when
playback resumes etc. Used very little as of yet, but
it seems like a good idea to have an per-space session/client

*/

function Client(space){
	this._space = space;
	this._options = new Map();
	
	this._space.on('playing',function() {
		return space.agent().options().discardLocals();
	});
	this;
};

exports.Client = Client; // export class 
Client.prototype.idle = function(v){ return this._idle; }
Client.prototype.setIdle = function(v){ this._idle = v; return this; };
Client.prototype.options = function(v){ return this._options; }
Client.prototype.setOptions = function(v){ this._options = v; return this; };
Client.prototype.space = function(v){ return this._space; }
Client.prototype.setSpace = function(v){ this._space = v; return this; };

Client.prototype.optionsForItem = function (item){
	var params;
	if (!(params = this._options.get(item))) {
		this._options.set(item,params = {});
	};
	return params;
};

Client.prototype.set = function (obj,key,value){
	var params = this.optionsForItem(obj);
	params[key] = value;
	return this;
};

Client.prototype.clearOptions = function (){
	var updates = [];
	this._options.forEach(function(params,widget) {
		var v_;
		if (len$(Object.keys(params))) {
			updates.push(widget);
			let res = [];
			for (let v, i = 0, keys = Object.keys(params), l = keys.length, k; i < l; i++){
				k = keys[i];v = params[k];res.push((((v_ = params[k]),delete params[k], v_)));
			};
			return res;
		};
	});
	
	for (let i = 0, len = updates.length; i < len; i++) {
		updates[i].optionsDidUpdate();
	};
	return this;
};

Client.prototype.flushLocals = function (){
	this.options().forEach(function(params,widget) {
		return widget.options().set(params);
	});
	
	return this.space().files().forEach(function(file) {
		return file.flushLocals();
	});
};
