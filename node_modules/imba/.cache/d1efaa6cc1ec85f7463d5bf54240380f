function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _2 = Imba.createTagCache, _1 = Imba.createElement;

var protocol$ = require('../protocol'), FILE = protocol$.FILE, SCON = protocol$.SCON, DIRTY = protocol$.DIRTY;

var Delay = require('../../util/Delay').Delay;

var Dimensions = require('../core/Dimensions').Dimensions;

// externs;

var tracking = require('../tracking');

if (false) {};

var imbaActions = require('../monaco/imbaActions');

var CodePreview = Imba.defineTag('CodePreview', function(tag){
	tag.prototype.file = function(v){ return this._file; }
	tag.prototype.setFile = function(v){ this._file = v; return this; };
	tag.prototype.__value = {watch: 'valueDidSet',name: 'value'};
	tag.prototype.value = function(v){ return this._value; }
	tag.prototype.setValue = function(v){
		var a = this.value();
		if(v != a) { this._value = v; }
		if(v != a) { this.valueDidSet && this.valueDidSet(v,a,this.__value) }
		return this;
	};
	
	tag.prototype.build = function (){
		var $ = ($_ = this.$).$build$ || ($_.$build$ = _2(this));
		return this.$open('build0').setChildren(this._code = this._code||_1('pre',this).flag('code'),2).synced();
	};
	
	tag.prototype.valueDidSet = function (value){
		return this._code.dom().innerText = value;
	};
	
	tag.prototype.render = function (){
		if (!(this.file())) { return };
		this.setValue(this.file().currentBody());
		return this;
	};
	
	tag.prototype.setScrollPosition = function (pos){
		if (pos.scrollLeft != undefined) {
			this.dom().scrollLeft = this._scrollLeft = pos.scrollLeft;
		};
		
		if (pos.scrollTop != undefined) {
			this.dom().scrollTop = this._scrollTop = pos.scrollTop;
		};
		return this;
	};
	
	tag.prototype.getScrollTop = function (){
		return this.dom().scrollTop;
	};
	
	tag.prototype.getScrollLeft = function (){
		return this.dom().scrollLeft;
	};
	
	tag.prototype.getScrollWidth = function (){
		return 0;
	};
	
	tag.prototype.getScrollHeight = function (){
		return 0;
	};
});

var EditorView = Imba.defineTag('EditorView', function(tag){
	
	tag.prototype.layout = function(v){ return this._layout; }
	tag.prototype.setLayout = function(v){ this._layout = v; return this; };
	tag.prototype.__file = {watch: 'fileDidSet',name: 'file'};
	tag.prototype.file = function(v){ return this._file; }
	tag.prototype.setFile = function(v){
		var a = this.file();
		if(v != a) { this._file = v; }
		if(v != a) { this.fileDidSet && this.fileDidSet(v,a,this.__file) }
		return this;
	};
	tag.prototype.__fontSize = {watch: 'fontSizeDidSet',name: 'fontSize'};
	tag.prototype.fontSize = function(v){ return this._fontSize; }
	tag.prototype.setFontSize = function(v){
		var a = this.fontSize();
		if(v != a) { this._fontSize = v; }
		if(v != a) { this.fontSizeDidSet && this.fontSizeDidSet(v,a,this.__fontSize) }
		return this;
	};
	tag.prototype.__selState = {watch: 'selStateDidSet',name: 'selState'};
	tag.prototype.selState = function(v){ return this._selState; }
	tag.prototype.setSelState = function(v){
		var a = this.selState();
		if(v != a) { this._selState = v; }
		if(v != a) { this.selStateDidSet && this.selStateDidSet(v,a,this.__selState) }
		return this;
	};
	tag.prototype.__scrollState = {watch: 'scrollStateDidSet',name: 'scrollState'};
	tag.prototype.scrollState = function(v){ return this._scrollState; }
	tag.prototype.setScrollState = function(v){
		var a = this.scrollState();
		if(v != a) { this._scrollState = v; }
		if(v != a) { this.scrollStateDidSet && this.scrollStateDidSet(v,a,this.__scrollState) }
		return this;
	};
	tag.prototype.__streamLayout = {watch: 'streamLayoutDidSet',name: 'streamLayout'};
	tag.prototype.streamLayout = function(v){ return this._streamLayout; }
	tag.prototype.setStreamLayout = function(v){
		var a = this.streamLayout();
		if(v != a) { this._streamLayout = v; }
		if(v != a) { this.streamLayoutDidSet && this.streamLayoutDidSet(v,a,this.__streamLayout) }
		return this;
	};
	tag.prototype.__autoScroll = {'default': true,watch: 'autoScrollDidSet',name: 'autoScroll'};
	tag.prototype.autoScroll = function(v){ return this._autoScroll; }
	tag.prototype.setAutoScroll = function(v){
		var a = this.autoScroll();
		if(v != a) { this._autoScroll = v; }
		if(v != a) { this.autoScrollDidSet && this.autoScrollDidSet(v,a,this.__autoScroll) }
		return this;
	}
	tag.prototype._autoScroll = true;
	
	tag.prototype.space = function (){
		return this.data().space();
	};
	
	tag.prototype.build = function (){
		this._syncing = false;
		this._dirty = {};
		this._bridge = this._preview = (_1(CodePreview)).end();
		this._layout = {};
		this._layouter = new Delay(this,'relayout');
		this._scrollTarget = {};
		
		this.dom().appendChild(this._preview.dom());
		this.dom().appendChild(((_1('div').flag('left-shadow'))).dom());
		this.dom().appendChild(((_1('div').flag('top-shadow'))).dom());
		return this;
	};
	
	tag.prototype.setup = function (){
		var self = this;
		self.data().setView(self);
		self.setSref(self.data().id());
		self.layoutCodePreview();
		self.space().once('dispose',function() { return self.dispose(); });
		self._v = self.data().options()._v;
		
		self.space().on('reflow',function(dirty) {
			// log "space.reflow",dirty
			self._top = self._left = self._width = self._height = 0;
			return self.relayout();
		});
		
		self.space().on('watch',function() {
			self.log('Space:watch');
			return (self.setAutoScroll(true),true);
		});
		
		self.space().on('playing',function() {
			self.log("Space:playing",self.autoScroll());
			self.setAutoScroll(true);
			return self.space().agent().options().reset('file');
		});
		
		// data.on('configured') do
		//	log "Configured"
		//	@editor and @editor.updateOptions(getDynamicOptions)
		
		return self;
	};
	
	tag.prototype.posToScreen = function (x,y){
		return this.data().agentToLocalPoint(x,y);
	};
	
	tag.prototype.batch = function (blk){
		var sync = this._syncing;
		this._syncing = true;
		blk();
		this._syncing = sync;
		return this;
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self._mounted = true;
		self.load();
		self.render();
		setTimeout(function() { return self.relayout(); },20);
		return self;
	};
	
	tag.prototype.fontSize = function (){
		return this.space().view().fontSize();
	};
	
	tag.prototype.unmount = function (){
		return this;
	};
	
	tag.prototype.focus = function (){
		this.log('called focus');
		if (this._editor) {
			return this._editor.focus();
		};
	};
	
	tag.prototype.onfocus = function (e){
		if (e.event().target == this) {
			this.log('editor onfocus');
			// log "onfocus",e.event:target
			return this._editor.focus();
		};
	};
	
	tag.prototype.autoScrollDidSet = function (bool){
		if (bool) { return this.unsyncScroll() };
	};
	
	tag.prototype.getDynamicOptions = function (){
		var opts;
		var fontSize = this.space().view().fontSize(); // what about api.fontSize?
		var pub = this.space().model().pub;
		
		return opts = {
			renderWhitespace: this.data().renderWhitespace() ? 'boundary' : 'none',
			renderIndentGuides: this.data().renderIndentGuides(),
			fontSize: (this._fontSize = fontSize),
			lineHeight: this._lineHeight = Math.ceil(this._fontSize * 1.5),
			lineDecorationsWidth: fontSize + 4,
			wordWrapColumn: this.data().wordWrapColumn(),
			wordWrap: (this.data().wordWrap() && (!pub || !pub.noWordWrap)) ? 'wordWrapColumn' : 'off',
			wrappingIndent: this.data().wrappingIndent()
		};
	};
	
	tag.prototype.configuration = function (){
		return this._editor.viewModel.configuration;
	};
	tag.prototype.fontInfo = function (){
		return this.configuration().editor.fontInfo;
	};
	tag.prototype.layoutInfo = function (){
		return this.configuration().editor.layoutInfo;
	};
	
	// LAYOUT
	tag.prototype.leftPadding = function (){
		var o = this.getDynamicOptions();
		// should get fontSize directly
		return Math.round(o.fontSize * 0.6 * 5) + o.lineDecorationsWidth;
	};
	
	tag.prototype.top = function (){
		return this._top || (this._top = this.dom().offsetTop);
	};
	tag.prototype.left = function (){
		return this._left || (this._left = this.dom().offsetLeft);
	};
	tag.prototype.width = function (){
		return this._layout.width || this._width;
	};
	tag.prototype.height = function (){
		return this._layout.height || this._height;
	};
	tag.prototype.contentTop = function (){
		return 20;
	};
	tag.prototype.contentLeft = function (){
		return this._layout.contentLeft || this.leftPadding();
	}; // + 4
	tag.prototype.scrollTop = function (){
		return this._bridge.getScrollTop();
	};
	tag.prototype.scrollLeft = function (){
		return this._bridge.getScrollLeft();
	};
	tag.prototype.lineHeight = function (){
		return Math.ceil(this._fontSize * 1.5);
	};
	
	tag.prototype.setScrollPosition = function (pos){
		let target = this._scrollTarget;
		if (pos.scrollTop != target.scrollTop || pos.scrollLeft != target.scrollLeft) {
			target.scrollTop = pos.scrollTop;
			target.scrollLeft = pos.scrollLeft;
			this._bridge.setScrollPosition(pos);
		};
		return this;
	};
	
	tag.prototype.setSelections = function (sel){
		if (this._editor) {
			this._monacoSel = this.monacoBridge().opToSelections(sel);
			return this._editor.setSelections(this._monacoSel);
		};
	};
	
	tag.prototype.layoutCodePreview = function (){
		return this._preview.css(
			{left: this.contentLeft() + 'px',
			paddingTop: this.contentTop() + 'px',
			fontSize: this.fontSize() + 'px',
			lineHeight: this.lineHeight() + 'px'}
		);
	};
	
	tag.prototype.currentCodeAnchor = function (){
		if (!(this._editor && this._file)) {
			return;
		};
		
		var sel = this._editor.getSelection();
		var ev = this.space().cursor().current();
		var uri = ("scrimba://" + (ev.branch().id()) + "@" + (ev.index()));
		
		if (this.file() && sel) {
			let l0 = sel.startLineNumber;
			let c0 = sel.startColumn;
			let l1 = sel.endLineNumber;
			let c1 = sel.endColumn;
			
			uri += ("" + (this.file().path()) + "#");
			
			// should be possible to show without a particular selection?
			
			uri += ("L" + l0);
			
			if (c0 == 1 && c1 == 1) {
				if ((l1 - 1) > l0) {
					uri += ("-" + (l1 - 1));
				};
			} else {
				uri += (":" + c0);
				
				// single marker
				if (l0 == l1 && c0 == c1) {
					true;
				} else if (c1 == 1) {
					l1 = l1 - 1;
					// c1 = @editor:model.getLineMaxColumn(l1)
					uri += ("-" + l1);
					if (c0 != 1) {
						uri += (":" + this._editor.model.getLineMaxColumn(l1));
					};
				} else {
					uri += ("-" + l1 + ":" + c1);
				};
			};
		};
		
		return {uri: uri,text: this._editor.model.getValueInRange(sel)};
	};
	
	tag.prototype.batchEdits = function (blk){
		var self = this;
		if (!self._editor) {
			return self.batch(blk);
		};
		
		self.batch(function() {
			var model = self._editor.getModel();
			var cursor = self._editor.cursor;
			if (cursor) {
				cursor._isHandling = true;
			};
			
			blk(); // @editor.blockRendering(blk)
			
			if (cursor) {
				return cursor._isHandling = false;
			};
		});
		return self;
	};
	
	
	tag.prototype.render = function (){
		var self = this;
		if (!self._mounted) { return };
		
		self.batch(function() {
			self.setFile(self.data().currentFile());
			self.flagIf('hasAgentFocus',self.file() && (self.space().agent().focus() == self.file() || self.space().agent().focus() == self.data()));
			if (!(self.file())) { return };
			
			if (!self._editor) {
				self._preview.render();
			};
			
			var sel = self.file().selState();
			
			// update selection if changed
			if (sel != self.selState() && self._editor) {
				self.setSelState(sel);
				if (!sel.LOCAL) { self.setSelections(sel) };
			};
			
			self.syncScroll();
			
			if (self.data().options()._v != self._v && self._editor) {
				self._v = self.data().options()._v;
				self._editor.updateOptions(self.getDynamicOptions());
			};
			
			
			// probably not needed after fixing font-loader
			if (self._editor) {
				self._editor.render();
			};
			
			// try to update layout on every render
			// ensures that layout does not end up out of sync
			return self.pushLayout();
		});
		
		return self;
	};
	
	
	// calculate the local layout for the current file
	tag.prototype.relayout = function (){
		// this part should only happen on space-resize now
		var w = this._width || (this._width = this.dom().offsetWidth);
		var h = this._height || (this._height = this.dom().offsetHeight);
		
		if (!(w && this._editor)) { return };
		
		this._compositingLayout = true;
		
		if (this._syncedFontSize != this.space().view().fontSize()) {
			this._editor.updateOptions(this.getDynamicOptions());
			this._syncedFontSize = this.space().view().fontSize();
		};
		
		if (w != this._syncedWidth || h != this._syncedHeight) {
			this._syncedWidth = w;
			this._syncedHeight = h;
			this._editor.layout({height: h,width: w});
		};
		
		// pushLayout
		this._compositingLayout = false;
		return this;
	};
	
	tag.prototype.pushLayout = function (){
		if (!(this.space().isEditing() && this._editor)) {
			return;
		};
		
		this.data().setLeft(this.left());
		this.data().setTop(this.top());
		this.data().setWidth(this.width());
		this.data().setHeight(this.height());
		this.data().setContentLeft(this.contentLeft());
		this.data().setContentTop(this.contentTop());
		this.data().setFontSize(this.fontSize());
		this.data().setLineHeight(this.lineHeight());
		
		if (this.file() && this._editor) {
			this.file().setScrollTop(this._editor.getScrollTop()); // :scrollTop
			this.file().setScrollLeft(this._editor.getScrollLeft()); // e:scrollLeft
		};
		return this;
	};
	
	/*
		see if file-scroll has changed - sync the view accordingly
		should probably take selection, pointer etc into account to
		intelligently decide what should be visible if the viewport
		is smaller than the agent's.
		*/
	
	tag.prototype.syncScroll = function (){
		if (this.space().isEditing() || !(this.autoScroll())) { return };
		
		// happens inside editor
		
		var agentLineHeight = this.data().lineHeight() || 21;
		var agentScrollTop = this.file().scrollTop() || 0;
		var agentScrollLeft = this.file().scrollLeft() || 0;
		let agentLineCount = this.data().height() / agentLineHeight;
		var sel = (this._monacoSel && this._monacoSel[0]);
		var updates = null;
		
		let target = {};
		let lineCount = this.height() / this.lineHeight();
		let heightRatio = lineCount / agentLineCount;
		let scrollTop = target.scrollTop = Math.round(agentScrollTop * (this.lineHeight() / agentLineHeight));
		let scrollLeft = target.scrollLeft = Math.round(agentScrollLeft * (this.fontSize() / (this.data().fontSize() || 14)));
		
		let pointerX = this._agentPointerX;
		let pointerY = this._agentPointerY;
		
		// only if our viewport is smaller than recorder?
		let prev = this._scrollTarget;
		
		// look at where the selection is
		if (sel && heightRatio < 1) {
			let selTop = this._editor.getTopForLineNumber(sel.startLineNumber);
			let selBottom = this._editor.getTopForLineNumber(sel.endLineNumber);
			let selCaret = this._editor.getTopForLineNumber(sel.positionLineNumber);
			
			// converting relative to caret for now
			// calculating that position for agent
			let agentCaret = (selCaret / this.lineHeight()) * agentLineHeight;
			let agentRelCaret = (agentCaret - agentScrollTop) / this.data().height();
			let relCaret = (selCaret - scrollTop) / this.height();
			let relScrollTop = Math.round(selCaret - this.height() * agentRelCaret);
			// console.log "relCaret",agentRelCaret,relScrollTop
			
			
			let padBottom = (1 - relCaret) * this.height();
			let padTop = relCaret * this.height();
			
			// if agent has not scrolled and selCaret is still pretty far up - dont 
			// if there is more than x amount of pixels available below or above in the original scroll-position
			// go with that one.
			if (padBottom > this.lineHeight()) {
				true;
			} else {
				target.scrollTop = relScrollTop;
			};
			
			if (pointerY < target.scrollTop) {
				target.scrollTop = Math.round(pointerY - this.lineHeight());
			};
		};
		
		this.setScrollPosition(target);
		
		if (agentScrollTop != this._agentScrollTop) {
			this._agentScrollTop = agentScrollTop;
		};
		
		if (agentScrollLeft != this._agentScrollLeft) {
			this._agentScrollLeft = agentScrollLeft;
		};
		return this;
	};
	
	tag.prototype.unsyncScroll = function (){
		return this._agentScrollLeft = this._agentScrollTop = -1;
	};
	
	tag.prototype.fileDidSet = function (file,old){
		var v_;
		this.flag('hasFile',!!file);
		if (old) { (old.setEditor(null),null) };
		this._preview.setFile(file);
		if (file) { (file.setEditor(this),this) };
		this._dirty.file = true;
		
		this.flag('binary-file',file && file.isBinary());
		
		if (!this._editor) { return };
		
		// editor is not supposed to deal with binary file at all
		if (file && file.isBinary()) {
			file = null;
		};
		
		// activate autoScroll when switching between file-scroll
		// maybe opt out if paused?
		if (this.space().isPlaying() || this.space().isWatching()) { (this.setAutoScroll(true),true) };
		this.unsyncScroll();
		
		// console.log "editor has focus already"
		// if the editor is focused, it will lose the focus
		// to document.body when we replace the model.
		// Therefore we move focus to MainView first.
		
		var hadFocus = false;
		if (this._bridge.isFocused()) {
			hadFocus = true;
		};
		
		if (file) {
			let model = file.model().model();
			this._editor.setModel(model);
			this._editor.FILE = file;
			
			try {
				this._editor.viewModel.viewLayout._linesLayout.insertWhitespace(0,0,this.contentTop());
			} catch (e) { };
			
			// sync scrollPosition back to previous one
			if (this.space().isEditing()) {
				this.setScrollPosition(
					{scrollTop: file.scrollTop() || 0,
					scrollLeft: file.scrollLeft() || 0}
				);
				// no need to relayout here - is it?
				this.relayout(); // only if editing?
			} else if (!(this.autoScroll()) && file._lastScrollPosition) {
				this.log("restore local scrollPosition!");
				this.setScrollPosition(
					{scrollTop: file._lastScrollPosition.scrollTop,
					scrollLeft: file._lastScrollPosition.scrollLeft}
				);
			};
		} else {
			this._editor.setModel(null);
		};
		
		// set selections directly
		if (file && file.selState()) {
			this.setSelState(file.selState());
			this._editor.render();
			this.setSelections(this.selState());
		};
		
		if (hadFocus) { // or parent.dom.contains(document:activeElement)
			return this._editor.focus();
		};
	};
	
	tag.prototype.focusWidgetForNode = function (){
		return this.data();
	};
	
	tag.prototype.oncopy = function (){
		// did copy
		var sel = this.monacoBridge().selectionToArray(this._editor.getSelection());
		return this.api().sendTracking(tracking.TYPES.COPY,[this.space().timeline().currentOffset(),this.file().id(),sel]);
	};
	
	tag.prototype.oncut = function (){
		return this.oncopy();
	};
	
	/*
		Method for loading monaco
		*/
	
	tag.prototype.load = async function (){
		var self = this;
		if (self._editor || self._loading) {
			return self;
		};
		
		self._loading = true;
		
		await self.monacoBridge().load();
		
		var opts = SCON.clone(window.MonacoEnvironment.defaults);
		
		for (let o = self.getDynamicOptions(), v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
			k = keys[i];v = o[k];opts[k] = v;
		};
		
		self._toDispose = [];
		self._timeouts = [];
		
		var ext = self._file ? self._file.ext() : '';
		
		var services = {logService: console};
		
		monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);
		monaco.languages.typescript.typescriptDefaults.setCompilerOptions(
			{experimentalDecorators: true}
		);
		
		self._editor = monaco.editor.create(self.dom(),opts,services);
		self._lastCursorSelection = Date.now();
		
		self.monacoBridge().patchEditor(self._editor);
		
		// delegate cursor-change to FileModel
		self._toDispose.push(self._editor.onDidChangeCursorSelection(function(event) {
			if (self.file() && !self.space().isSyncing() && !self._syncing) {
				self.file().model().onDidChangeCursorSelection(event);
				self._lastCursorSelection = Date.now();
				Imba.commit(event);
			};
			return;
		}));
		
		self._toDispose.push(self._editor.onDidScrollChange(function(e) {
			var v_;
			if (!(self._file && (e.scrollTopChanged || e.scrollLeftChanged))) { return };
			
			// keep the last scrollObject on file
			self.file()._lastScrollPosition = e;
			self.space().touch('locals'); // should be touch scroll
			
			// no need to register anything if we are currently syncing
			if (self._syncing || self.space().cursor().syncing()) {
				return;
			};
			
			self.setAutoScroll(false);
			self.log("scroll",e);
			
			if (self.space().isEditing()) {
				// sync scroll
				self.file().setScrollTop(e.scrollTop);
				return (self.file().setScrollLeft(v_ = e.scrollLeft),v_);
			};
		}));
		
		self._toDispose.push(self._editor.onDidLayoutChange(function(e) {
			self.log("onDidLayoutChange",e);
			return self._layout = e;
			// should relayout at the end of render anyway?
			// @layouter.delay(10) unless @compositingLayout
		}));
		
		self._toDispose.push(self._editor.onDidFocusEditor(function(e) {
			return self.log("onDidFocusEditor");
			// space.agent.focus = data
		}));
		
		self._toDispose.push(self._editor.onDidBlurEditor(function(e) {
			return self.log("onDidBlurEditor");
		}));
		
		
		self._editor.addAction(
			{id: 'inline-transpiled-code',
			label: "Inline transpiled code",
			keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_J],
			run: function(ed) {
				if (ed.model.getModeId() != 'imba') { return };
				return imbaActions.inlineCompiledCode(ed.model,ed);
			}}
		);
		
		self._bridge = self._editor;
		self._layout = self._editor.getLayoutInfo();
		
		if (!self._file) {
			self._editor.setModel(null);
		};
		
		for (let i = 0, items = iter$(self.space().files()), len = items.length; i < len; i++) {
			// Preload models
			items[i].model().model();
		};
		
		self.batch(function() {
			self._agentScrollTop = self._agentScrollLeft = -1;
			self._scrollTarget = {};
			if (self._file) { return self.fileDidSet(self._file) };
		});
		
		self.flag('loaded');
		self.render();
		if (window.performance) {
			console.log("editor loaded",window.performance.now());
		};
		return self;
	};
	
	tag.prototype.dispose = function (){
		var $1;
		for (let i = 0, items = iter$(this._toDispose), len = items.length; i < len; i++) {
			($1 = items[i]) && $1.dispose  &&  $1.dispose();
		};
		
		this._toDispose = null;
		
		for (let i = 0, items = iter$(this._timeouts), len = items.length; i < len; i++) {
			clearTimeout(items[i]);
		};
		
		this._timeouts = null;
		
		this.setFile(null);
		window.SE = null;
		
		if (this._editor) {
			this._editor.setModel(null);
			this._editor.dispose();
			try {
				this._editor.domElement.innerHTML = '';
			} catch (e) { };
			
			this._editor.domElement = null;
		};
		
		if (this._model) {
			// dispose all file-models?
			this._model.dispose();
			this._model = null;
		};
		
		// shouldnt be needed?
		this._editor = null;
		this._dom._tag = null;
		this._dom.innerHTML = null;
		
		this._data.setView(null);
		this._data = null;
		this._owner = null;
		this._dom.parentNode.removeChild(this._dom);
		return this;
	};
})
exports.EditorView = EditorView;
