var Imba = require('imba'), _3 = Imba.createTagList, _2 = Imba.createTagMap, _1 = Imba.createElement;
var uxa$ = require('uxa'), Dialog = uxa$.Dialog, SelectField = uxa$.SelectField, Button = uxa$.Button;

var MediaRecording = require('../util/MediaRecording').MediaRecording;
var MediaRecordingStats = require('./MediaRecordingStats').MediaRecordingStats;

var util = require('../util');

var CONSTRAINTS = [
	['noiseSuppression','Noise Suppression'],
	['echoCancellation','Echo Cancellation'],
	['autoGainControl','Auto-Gain'],
	['typingNoiseDetection','Typing Noise Detection']
];

var lastSelectedDevice = null;

var RecDialog = Imba.defineTag('RecDialog', Dialog, function(tag){
	
	tag.prototype.sample = function(v){ return this._sample; }
	tag.prototype.setSample = function(v){ this._sample = v; return this; };
	
	tag.prototype.branch = function (){
		return this.data();
	};
	
	tag.prototype.space = function (){
		return this.branch().space();
	};
	
	tag.prototype.togglePrev = function (e){
		e.target().prev().setChecked(!e.target().prev().checked());
		return e.halt();
	};
	
	tag.prototype.isSupported = function (){
		return this.space().audio().canRecordAudio(); // and api.ua.isChrome
	};
	
	tag.prototype.devices = function (){
		var devices_;
		return (devices_ = this.space().audio().devices()).OPTIONS || (devices_.OPTIONS = this.space().audio().devices().map(function(device,i) {
			return [device.deviceId,device.label || ("Mic #" + (i + 1))];
		}));
	};
	
	tag.prototype.supportedConstraints = function (){
		return this._supportedConstraints || (this._supportedConstraints = window.navigator.mediaDevices.getSupportedConstraints());
	};
	
	tag.prototype.constraints = function (){
		var supported = this.supportedConstraints();
		var options = this.formData();
		
		var constraints = {};
		
		constraints.deviceId = options.audioDeviceId;
		constraints.channelCount = 1;
		
		for (let i = 0, len = CONSTRAINTS.length; i < len; i++) {
			let key = CONSTRAINTS[i][0];
			if (supported[key]) {
				constraints[key] = !(!options[key]);
			};
		};
		
		if (supported.sampleRate) {
			constraints.sampleRate = 48000;
		};
		
		if (this.api().ua().isChrome()) {
			constraints.googAutoGainControl = false;
			// constraints:sampleSize = 20
		};
		
		// if @mandatoryFailTest?.checked
		// 	constraints:erroneousParameter = true
		
		return constraints;
	};
	
	tag.prototype.onsamplestart = function (){
		var self = this;
		self.setSample(new MediaRecording({constraints: self.constraints(),debug: self.formData().debug}));
		self.sample().start().then(function() { return true; }).catch(function(e) {
			var v_;
			self.log("sample could not start!!",e);
			self.uxa().flash(e.message);
			return (self.setSample(null),null);
		});
		self.schedule({raf: true});
		return self;
	};
	
	tag.prototype.onsamplestop = function (){
		return this.sample().stop();
	};
	
	tag.prototype.onsampleplay = function (){
		return this.sample().play();
	};
	
	tag.prototype.body = function (){
		var $ = this.$$ || (this.$$ = {}), t0, self = this, t1, t2;
		return (t0 = self._body = self._body||(t0=_1('div',self)).flag('body')).setContent([
			(t0.$.A || _1('h1',t0.$,'A',t0).flag('red').setText('Record')),
			(t0.$.B || _1('p',t0.$,'B',t0).flag('dim').setText('Choose a microphone and click "CONFIRM" to start the recording.')),
			(t0.$.C || _1('p',t0.$,'C',t0).flag('info').setText("If you make a mistake during your recording, don't worry. You can cut away, silence or speed up parts of your recording afterward. You can also redo the entire recording if you want.")),
			
			self.isSupported() ? (
				(t1 = t0.$.D || (t1=_1('div',t0.$,'D',t0)).flag('mic')).setContent([
					// <input type='checkbox' name='mic' checked=yes>
					(self._deviceSelect = self._deviceSelect||_1(SelectField,t1).flag('deviceSelect').flag('device').setLabel("Select microphone").setName('audioDeviceId')).setOptions(self.devices()).end(),
					// if api.ua.isChrome
					(t0.$.E || _1('div',t0.$,'E',t1).flag('testing')).setContent([
						(function tagLoop($0) {
							var t1, $$ = $0.$iter();
							for (let i = 0, len = CONSTRAINTS.length, item; i < len; i++) {
								item = CONSTRAINTS[i];
								if (!self.supportedConstraints()[item[0]]) { continue; };
								$$.push((t1 = $0[i] || (t1=_1('label',$0,i)).setContent([
									_1('input',t1.$,'A',t1).setType("checkbox").setChecked(true),
									_1('span',t1.$,'B',t1)
								],2)).end((
									t1.$.A.setName(item[0]).end(),
									t1.$.B.setContent(item[1],3)
								,true)));
							};return $$;
						})(t0.$['F'] || _2(t0.$,'F',t0.$.E)),
						(t0.$.G || _1('label',t0.$,'G','E').setContent([
							_1('input',t0.$,'H','G').setType("checkbox").setName('debug').setChecked(false),
							_1('span',t0.$,'I','G').setText('debug')
						],2)).end((
							t0.$.H.end()
						,true)),
						
						// <input@mandatoryFailTest type="checkbox" name='mandatoryFail'>
						(!(self.sample()) || self.sample().audio()) ? (
							(t0.$.J || _1(Button,t0.$,'J','E').flag('sm').flag('primary').flag('testButton').setNestedAttr('uxa','action','samplestart').setLabel('Test')).end()
						) : (
							(t0.$.K || _1(Button,t0.$,'K','E').flag('sm').flag('primary').flag('testButton').setNestedAttr('uxa','action','samplestop').setLabel('Stop')).end()
						)
					],1),
					
					self.sample() ? Imba.static([
						(t0.$.L || _1(MediaRecordingStats,t0.$,'L',t1).flag('sample')).bindData(self,'sample',[]).end(),
						
						self.sample().error() ? (
							(t0.$.M || _1('div',t0.$,'M',t1).flag('sample').flag('error')).setContent((self.sample().error().message || self.sample().error()),3)
						) : void(0),
						
						self.sample().audio() ? (
							Imba.getTagForDom(self.sample().audio())
						) : void(0)
					],1,1) : void(0),
					
					(self._endOffset != self._currOffset) ? (
						(t0.$.N || _1('div',t0.$,'N',t1).flag('Alert').flag('danger').flag('large').flag('rerecord').setContent(
							t2 = t0.$.O || (t2=_1('label',t0.$,'O','N')).setContent([
								self._recFromOffset = self._recFromOffset||_1('input',t2).flag('recFromOffset').setType("checkbox"),
								_1('span',t0.$,'P',t2)
							],2)
						,2)).end((
							self._recFromOffset.end(),
							t0.$.P.setNestedAttr('uxa','md',("Re-record from current time *(" + util.msToStr(self._currTime,3) + ")*")).end()
						,true))
					) : void(0)
				],1)
			) : (
				(t0.$.Q || _1('div',t0.$,'Q',t0).flag('Alert').flag('danger').flag('large').setText("Recording / streaming is currently only available from Chrome and Firefox."))
			)
		],1);
	};
	
	tag.prototype.onchange = function (e){
		this.log("onchange");
		if (this._recFromOffset && this._recFromOffset.checked()) {
			return this.space().timeline().seek(this._currOffset);
		} else {
			return this.space().timeline().seekToEnd();
		};
	};
	
	tag.prototype.setup = function (){
		this._currOffset = this.space().timeline().currentOffset();
		this._currTime = this.space().timeline().offsetToTime(this._currOffset);
		this._endOffset = this.space().timeline().endOffset();
		this.log("initial offset",this._currOffset);
		return tag.prototype.__super__.setup.apply(this,arguments);
	};
	
	tag.prototype.mount = function (){
		if (this._recFromOffset) {
			this._recFromOffset.dom().checked = true;
		};
		this.schedule({events: true,interval: 1000});
		if (lastSelectedDevice) {
			this._deviceSelect.setValue(lastSelectedDevice);
		};
		return this;
	};
	
	tag.prototype.unmount = function (){
		return this.unschedule();
	};
	
	tag.prototype.onuxasubmit = function (e){
		var self = this;
		self.log('onsubmit',self.formData());
		if (self.sample()) {
			self.sample().stop();
		};
		
		// return self
		var params = self.formData();
		
		var options = {
			mic: self.constraints(),
			pointer: true,
			live: true
		};
		
		lastSelectedDevice = params.audioDeviceId;
		
		if (self._recFromOffset && self._recFromOffset.checked()) {
			options.offset = self._currOffset;
			if (!window.confirm(("Are you sure you want to restart recording from " + util.msToStr(self._currTime) + "? This cannot be undone"))) {
				return e.prevent().stop();
			};
		};
		
		return self.uxa().queue().add(300,function() {
			return self.branch().record(options);
		});
	};
})
exports.RecDialog = RecDialog;
