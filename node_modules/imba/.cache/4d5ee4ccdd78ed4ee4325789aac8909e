function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');

var protocol$ = require('../protocol'), ACTION_MAP = protocol$.ACTION_MAP, ACTION = protocol$.ACTION, WIDGET = protocol$.WIDGET, CAST = protocol$.CAST, KEYS = protocol$.KEYS, SCON = protocol$.SCON;
var Struct = require('./Struct').Struct;

/*

Every change that is persisted to a stream has a type.
There is a StreamAction subclass for each type, and
every event is deserialised to an instance of said class.

These deserialised events (StreamAction instances) are
themselves responsible for applying (StreamAction#commit)
and reverting (StreamAction#revert) themselves in the context
of a space. Any changes an action creates MUST be revertable.

*/


function StreamAction(params,branch){
	this._params = params;
	this._branch = branch;
	this._offset = 0;
	this._prev = null;
	this._next = null;
	this._receivedAt = Date.now();
	this;
};

exports.StreamAction = StreamAction; // export class 
StreamAction.seed = function (stream){
	var seed = new this([],stream._owner);
	seed._index = -1;
	seed._byteOffset = 1;
	return seed;
};

StreamAction.handles = function (type,opts){
	if(opts === undefined) opts = {};
	ACTION_MAP[type] = this;
	this._type = this.prototype._type = type;
	this._options = opts;
	this._strategy = opts.strategy;
	this._diff = opts.diff;
	return this;
};

StreamAction.type = function (type){
	return ACTION_MAP[type];
};

StreamAction.deserialize = function (raw,branch){
	var type = ACTION_MAP[raw[0]] || this;
	return new type(raw,branch);
};

StreamAction.build = function (params,meta,source){
	if (!((params instanceof Array))) {
		params = this.paramify(params);
	};
	return new this(params,null);
};

StreamAction.encode = function (params,rel,stream,idx){
	if (this._strategy == 'dedupe') {
		let json = JSON.stringify(params);
		if (stream._dupes[json] != null) {
			return [stream._dupes[json]];
		};
	};
	
	return params;
};

StreamAction.decode = function (params,rel,stream,idx){
	var _dupes_;
	if (this._strategy == 'dedupe') {
		if (params.length == 1) {
			params = stream._actions[params[0]]._params;
		} else {
			var json = JSON.stringify(params);
			((_dupes_ = stream._dupes)[json] == null) ? (_dupes_[json] = idx) : _dupes_[json];
		};
	};
	
	return new this(params);
};

StreamAction.schema = function (items){
	this.prototype._schema = this._schema = items;
	this._defaults = [];
	
	var getter = function(i) {
		return function() { return this._params[i]; };
	};
	
	for (let i = 0, ary = iter$(items), len = ary.length; i < len; i++) {
		this._defaults.push(0);
		this.prototype[ary[i]] = getter(i);
	};
	return this;
};

// can convert object with keys into array based on schema of action
// helpful to make sure we are supplying the correct attributes etc
StreamAction.paramify = function (dict){
	if (!this._schema) {
		throw ("A" + (this.prototype._type) + " does not support paramify");
	};
	
	var values = this._defaults.slice();
	
	for (let val, i = 0, keys = Object.keys(dict), l = keys.length, key; i < l; i++){
		key = keys[i];val = dict[key];let idx = this._schema.indexOf(key);
		values[idx] = val;
	};
	
	return values;
};


StreamAction.prototype.offset = function(v){ return this._offset; }
StreamAction.prototype.setOffset = function(v){ this._offset = v; return this; };
StreamAction.prototype.type = function(v){ return this._type; }
StreamAction.prototype.setType = function(v){ this._type = v; return this; };
StreamAction.prototype.params = function(v){ return this._params; }
StreamAction.prototype.setParams = function(v){ this._params = v; return this; };
StreamAction.prototype.index = function(v){ return this._index; }
StreamAction.prototype.setIndex = function(v){ this._index = v; return this; };
StreamAction.prototype.byteEnd = function(v){ return this._byteEnd; }
StreamAction.prototype.setByteEnd = function(v){ this._byteEnd = v; return this; };
StreamAction.prototype.receivedAt = function(v){ return this._receivedAt; }
StreamAction.prototype.setReceivedAt = function(v){ this._receivedAt = v; return this; };

StreamAction.prototype.log = function (){
	var branch_;
	var $0 = arguments, i = $0.length;
	var pars = new Array(i>0 ? i : 0);
	while(i>0) pars[i-1] = $0[--i];
	return (branch_ = this.branch()).log.apply(branch_,[].concat(['action:' + this.constructor.name], [].slice.call(pars)));
};

// addToStream stream
// link up next / prev etc
StreamAction.prototype.addToStream = function (stream){
	this._stream = stream;
	this._branch || (this._branch = stream._owner);
	this._prev = stream._tail;
	this._parent = stream._lastActions[this._type];
	this._offset = stream._lastTimeOffset;
	return this.INDEX = this._index = len$(stream);
};

StreamAction.prototype.commitToStream = function (stream){
	if (this._prev) { this._prev._next = this };
	stream.lastActions()[this._type] = this;
	stream.actions().push(this);
	this._byteEnd = stream.byteLength();
	return this;
};

// in the odd case where we need to rollback
// items in the stream - we must ensure that
// the encoder/decoder state is fixed
// At some point we might need to start
// reconstructing the whole stream instead
StreamAction.prototype.removeFromStream = function (stream){
	stream._lastActions[this._type] = this._parent;
	stream.actions().pop();
	return this;
};

// commitToStream stream
// update the stream lastTargetAction and more

StreamAction.prototype.timeOffset = function (){
	return this._offset;
};

StreamAction.prototype.branch = function (){
	return this._branch || this._stream._owner;
};

StreamAction.prototype.space = function (){
	return this.branch().space();
};

StreamAction.prototype.data = function (){
	return this._params[1];
};

StreamAction.prototype.toString = function (){
	return ("A#" + (this.INDEX));
};

StreamAction.prototype.toStruct = function (){
	return this._params;
};

StreamAction.prototype.addSubAction = function (action,cursor){
	// console.warn "addSubAction",action,self
	action._branch = this.branch();
	this._children || (this._children = []);
	// var action = StreamAction.new(raw,branch)
	// action.@branch = branch
	this._children.push(action);
	action.commitWithCursor(cursor);
	return action;
};

StreamAction.prototype.encode = function (stream){
	return this.constructor.encode(this._params,this._parent ? this._parent._params : null,stream,this._index);
	// @params
};

StreamAction.prototype.target = function (){
	return this._branch.__lookup(this._params[0]) || this._branch.space();
};

StreamAction.prototype.isEnabled = function (){
	return true;
};

StreamAction.prototype.isSignificant = function (){
	return false;
};

StreamAction.prototype.commitWithCursor = function (cursor){
	cursor._stack.unshift(this);
	this.commit(cursor);
	cursor._stack.shift();
	return this;
};

StreamAction.prototype.revertWithCursor = function (cursor){
	cursor._stack.unshift(this);
	if (this._children) {
		var i = this._children.length;
		while (i > 0){
			this._children[--i].revertWithCursor(cursor);
		};
		this._children = null;
	};
	
	this.revert(cursor);
	cursor._stack.shift();
	return this;
};

// applying this action
StreamAction.prototype.commit = function (cursor){
	var target;
	if (target = this.target()) {
		cursor.markTarget(target);
		target.apply(this);
	};
	return this;
};

// reverting this action
StreamAction.prototype.revert = function (cursor){
	var target;
	if (target = this.target()) {
		cursor.markTarget(target);
		target.revert(this);
	};
	return this;
};

// rejected by stream - possibly revert if
// merely creating the action had side-effects
StreamAction.prototype.discard = function (){
	return this;
};



function CreateWidget(){ return StreamAction.apply(this,arguments) };

Imba.subclass(CreateWidget,StreamAction);
exports.CreateWidget = CreateWidget; // export class 
CreateWidget.handles(ACTION.WIDGET_CREATE,['target','config']);

CreateWidget.prototype.isSignificant = function (){
	return true;
};

CreateWidget.prototype.widget = function (){
	return this._widget || (this._widget = this.target().widgets().create(this.data().type,this.data(),this));
};

CreateWidget.prototype.commit = function (cursor){
	this.widget().commitAdd();
	return cursor.markTarget(this.target());
};

CreateWidget.prototype.revert = function (cursor){
	this.widget().revertAdd();
	cursor.markTarget(this.target());
	return this;
};


function Snapshot(raw,branch){
	this._params = raw;
	this._branch = branch;
	this._offset = 0;
	this._prev = null;
	this._next = null;
	this;
};

Imba.subclass(Snapshot,StreamAction);
exports.Snapshot = Snapshot; // export class 
Snapshot.handles(CAST.SNAPSHOT,['data']);

Snapshot.prototype.commit = function (){
	if (!this.branch().space().isDeserialized()) {
		// only apply snapshot if this is the first snapshot in space
		this.branch().space().deserialize(this._params[0],this);
	};
	// else
	//	console.log "skip Snapshot - already deserialized"
	return this;
};

Snapshot.prototype.revert = function (){
	// console.log "snapshot cannot be reverted"
	return this;
};

function BranchAction(){ return Snapshot.apply(this,arguments) };

Imba.subclass(BranchAction,Snapshot);
exports.BranchAction = BranchAction; // export class 
BranchAction.handles(CAST.BRANCH);

BranchAction.prototype.commit = function (){
	if (this.branch() == this.branch().space().trunk()) {
		BranchAction.prototype.__super__.commit.apply(this,arguments);
	};
	return this;
};

function ForkAction(){ return BranchAction.apply(this,arguments) };

Imba.subclass(ForkAction,BranchAction);
exports.ForkAction = ForkAction; // export class 
ForkAction.handles(ACTION.FORK);

function PingAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(PingAction,StreamAction);
exports.PingAction = PingAction; // export class 
PingAction.handles(ACTION.PING);

function ConfigSet(){ return StreamAction.apply(this,arguments) };

Imba.subclass(ConfigSet,StreamAction);
exports.ConfigSet = ConfigSet; // export class 
ConfigSet.handles(ACTION.SET,[]);

/*	
	if target(0) is same as previous - drop
	if key(1) is the same as well - drop 
	
	So, setting the same property twice would result in
	[targetId,myProperty,myFirstValue],[mySecondValue]
	*/


// maybe set this upon creation?
// rel is the previous event of same type?
ConfigSet.decode = function (params,rel,stream,idx){
	if (rel) {
		if (params.length < 2) {
			params.unshift(rel[1]);
		};
		if (params.length < 3) {
			params.unshift(rel[0]);
		};
	};
	
	return new this(params);
};

ConfigSet.encode = function (params,rel){
	if (rel && rel.length == params.length) {
		
		// if we have the same target
		if (params[0] == rel[0]) {
			if (params[1] == rel[1]) {
				return [params[2]];
			} else {
				return [params[1],params[2]];
			};
		};
	};
	
	return params;
};

ConfigSet.prototype.key = function (){
	return KEYS[this._params[1]] || this._params[1];
};

ConfigSet.prototype.commit = function (cursor){
	var target;
	var key = this.key();
	if (target = this.target()) {
		cursor.markTarget(target);
		this._revertValue || (this._revertValue = target._data[key]);
		target._data[key] = this._params[2];
		// why do this directly?
		return target.options()._v++;
	};
};

ConfigSet.prototype.revert = function (cursor){
	var target;
	if (target = this.target()) {
		cursor.markTarget(target);
		target._data[this.key()] = this._revertValue;
		target.options()._v++;
	};
	return this;
};


function Patch(){ return StreamAction.apply(this,arguments) };

Imba.subclass(Patch,StreamAction);
exports.Patch = Patch; // export class 
Patch.handles(ACTION.PATCH);

// maybe set this upon creation?

Patch.prototype.key = function (){
	return KEYS[this._params[1]] || this._params[1];
};

Patch.prototype.data = function (){
	return this._params[2];
};

Patch.prototype.commit = function (cursor){
	var target;
	var key = this.key(),data = this.data();
	if (target = this.target()) {
		cursor.markTarget(target);
		this._revertValue = target._data[key];
		// unless @rev:val
		// 	console.log "trying to patch empty val!!",self
		this._value || (this._value = Struct.decode(this._revertValue || data,data));
		// console.log "patching",data,@value
		target._data[key] = this._value;
		return target.options()._v++;
	};
};

Patch.prototype.revert = function (cursor){
	var target;
	if (target = this.target()) {
		cursor.markTarget(target);
		target._data[this.key()] = this._revertValue;
		target.options()._v++;
	};
	return this;
};


function TextAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(TextAction,StreamAction);


function TextEdit(){ return TextAction.apply(this,arguments) };

Imba.subclass(TextEdit,TextAction);
exports.TextEdit = TextEdit; // export class 
TextEdit.handles(ACTION.LCEDIT); // [fileid,edits[ [range,text], ... ]]

TextEdit.prototype.isSignificant = function (){
	return true;
};

TextEdit.prototype.data = function (){
	return this._params[1];
};

TextEdit.prototype.selAfter = function (){
	return this._params[2];
};

TextEdit.prototype.selBefore = function (){
	return this._selBefore;
};

TextEdit.prototype.commit = function (cursor){
	var target = this.target();
	this._selBefore = target._selState;
	cursor.markTarget(target);
	target.model().apply(this.data(),this.LOCAL);
	if (this.selAfter()) {
		target._selState = this.selAfter();
	};
	
	// FIXME this should use something else
	target.async('modified');
	return this.LOCAL = null;
};

TextEdit.prototype.revert = function (cursor){
	cursor.markTarget(this.target());
	this.target().model().undo(this.data());
	if (this.selBefore()) {
		return this.target()._selState = this.selBefore();
	};
};

function TextInsert(){ return TextEdit.apply(this,arguments) };

Imba.subclass(TextInsert,TextEdit);
exports.TextInsert = TextInsert; // export class 
TextInsert.handles(ACTION.LCINSERT);

TextInsert.decode = function (params,rel,stream){
	if (typeof params == 'string') {
		var start = rel[4] || [rel[1],rel[2] + rel[3].length];
		params = [rel[0],start[0],start[1],params];
	};
	
	return new this(params);
};

TextInsert.encode = function (params,rel){
	if (!rel) { return params };
	var start = rel[4] || [rel[1],rel[2] + rel[3].length];
	
	if (start.length == 2 && start[0] == params[1] && start[1] == params[2]) {
		if (!params[4]) {
			return params[3];
		};
	};
	
	return params;
};

TextInsert.prototype.encode = function (stream){
	// TODO send through to constructor.encode
	var rel = this._parent && this._parent._params;
	var pars = this._params;
	
	if (rel && !pars[4]) {
		var psel = this._parent.selAfter();
		// this starts where the previous ends
		if (psel.length == 2 && psel[0] == pars[1] && psel[1] == pars[2]) {
			return pars[3];
		};
	};
	
	return pars;
};

TextInsert.prototype.data = function (){
	if (this._data) { return this._data };
	let pars = this._params;
	let edit = [[pars[1],pars[2]],pars[3]];
	return this._data = [edit];
};

TextInsert.prototype.selAfter = function (){
	return this._selAfter || (this._selAfter = this._params[4] || [this._params[1],this._params[2] + this._params[3].length]);
};

function TextDelete(){ return TextEdit.apply(this,arguments) };

Imba.subclass(TextDelete,TextEdit);
exports.TextDelete = TextDelete; // export class 
TextDelete.handles(ACTION.LCDELETE);

// def self.decode pkg, rel, branch
// 	if var rp = rel and rel.@params

TextDelete.prototype.range = function (){
	return this._range || (this._range = this._params.slice(1,5));
};

TextDelete.prototype.data = function (){
	return this._data || (this._data = [[this.range()]]);
};

TextDelete.prototype.selAfter = function (){
	return this._selAfter || (this._selAfter = this._params[5] || this._params.slice(1,3));
};

function TextSelection(){ return TextAction.apply(this,arguments) };

Imba.subclass(TextSelection,TextAction);
exports.TextSelection = TextSelection; // export class 
TextSelection.handles(ACTION.LCSELECTION);

// if there are less than 3 params
// it signals that params should be identical
// to previous LCSELECTION, except the last n items

TextSelection.decode = function (params,rel,stream,idx){
	if (rel && params.length < 3) {
		params = rel.slice(0,-params.length).concat(params);
	};
	
	return new this(params);
};

TextSelection.encode = function (params,rel){
	if (rel && rel.length == params.length) {
		// check if only the last number has changed
		let i = 0;
		while (i < rel.length){
			if (rel[i] != params[i]) {
				break;
			};
			i++;
		};
		
		let uniqTail = params.slice(i);
		if (uniqTail.length < 3) {
			return uniqTail;
		};
	};
	
	return params;
};

TextSelection.prototype.selAfter = function (){
	return this._selAfter || (this._selAfter = this._params.slice(1));
};

TextSelection.prototype.commit = function (cursor){
	this._selBefore = this.target()._selState;
	return this.target()._selState = this.selAfter();
};

TextSelection.prototype.revert = function (){
	return this.target()._selState = this._selBefore;
};

function TextScroll(){ return StreamAction.apply(this,arguments) };

Imba.subclass(TextScroll,StreamAction);
exports.TextScroll = TextScroll; // export class 
TextScroll.handles(ACTION.LCSCROLL);


function NodeLayoutAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(NodeLayoutAction,StreamAction);
exports.NodeLayoutAction = NodeLayoutAction; // export class 
NodeLayoutAction.handles(ACTION.NODE_LAYOUT); // [ nodeRef, ]

NodeLayoutAction.prototype.sref = function (){
	return this._params[0];
};

NodeLayoutAction.prototype.layout = function (){
	return this._params[1];
};

NodeLayoutAction.prototype.commit = function (){
	this._rev = this._stream.layouts()[this.sref()];
	this._stream.layouts()[this.sref()] = this.layout();
	return this;
};

NodeLayoutAction.prototype.revert = function (){
	return this._stream.layouts()[this.sref()] = this._rev;
};


function PointerUpdate(){ return StreamAction.apply(this,arguments) };

Imba.subclass(PointerUpdate,StreamAction);
exports.PointerUpdate = PointerUpdate; // export class 
PointerUpdate.handles(ACTION.POINTER_UPDATE);

PointerUpdate.schema([
	'x', // delta
	'y', // delta
	'flags',
	'hover', // target
	'angle', // 0-120
	'pressure' // 0-120
]);

PointerUpdate.decode = function (params,rel,stream,idx){
	if (rel) {
		params[0] += rel[0]; // x
		params[1] += rel[1]; // y
		var i = params.length;
		while (i < rel.length){
			params[i] = rel[i++];
		};
	};
	
	return new this(params);
};

PointerUpdate.encode = function (params,rel,stream,idx){
	if (!rel) { return params };
	
	// workaround - check if hover-array is equal
	if (String(params[3]) == String(rel[3])) {
		params[3] = rel[3];
	};
	
	var diff = params.slice();
	diff[0] = params[0] - rel[0];
	diff[1] = params[1] - rel[1];
	var i = rel.length - 1;
	
	
	
	while (i > 1 && rel[i] == params[i]){
		diff.pop();
		i--;
	};
	
	return diff;
};

// def encode
//	return PointerUpdate.encode(@params,@parent ? @parent.@params : null)

PointerUpdate.prototype.addToStream = function (stream){
	PointerUpdate.prototype.__super__.addToStream.apply(this,arguments);
	this._parent && (this._parent._nextFrame = this);
	return;
};

PointerUpdate.prototype.nextFrame = function (){
	return this._nextFrame;
};

PointerUpdate.prototype.prevFrame = function (){
	return this._parent;
};

PointerUpdate.prototype.view = function (){
	return this._branch._space._view._pointer;
};

PointerUpdate.prototype.target = function(v){ return this._target; }
PointerUpdate.prototype.setTarget = function(v){ this._target = v; return this; };

PointerUpdate.prototype.target = function (){
	return this._target || (this._target = this.originalTarget());
};

PointerUpdate.prototype.sref = function (){
	return this._sref || (this._sref = this.originalSref());
};

PointerUpdate.prototype.setSref = function (newSref){
	this._sref = newSref;
	this._target = this._branch._space._view.lookup(newSref);
	this;
	return this;
};

PointerUpdate.prototype.originalTarget = function (){
	return this._originalTarget || (this._originalTarget = this._branch._space._view.lookup(this.originalSref()));
};

PointerUpdate.prototype.originalSref = function (){
	return this._params[3];
};

PointerUpdate.prototype.targetLayout = function (){
	return this._branch._stream.layouts()[this.sref()];
};

PointerUpdate.prototype.commit = function (){
	// change pointer-update
	var view;
	if (view = this.view()) {
		// log 'commit'
		view.setKeyframe(this);
	};
	return this;
};

PointerUpdate.prototype.revert = function (){
	var view;
	if (view = this.view()) {
		view.setKeyframe(this._parent);
	};
	return this;
};

function FSRenameAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(FSRenameAction,StreamAction);
exports.FSRenameAction = FSRenameAction; // export class 
FSRenameAction.handles(ACTION.FS_RENAME);

FSRenameAction.prototype.target = function (){
	return this._branch.__lookup(this._params[0]);
};

FSRenameAction.prototype.commit = function (){
	this.target().setName(this._params[1]);
	return this;
};

function FSMoveAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(FSMoveAction,StreamAction);
exports.FSMoveAction = FSMoveAction; // export class 
FSMoveAction.handles(ACTION.FS_MOVE); // source, newTaret

FSMoveAction.prototype.target = function (){
	return this._branch.__lookup(this._params[0]);
};

FSMoveAction.prototype.commit = function (){
	this._prevDir || (this._prevDir = this.target().parentDir());
	this._targetDir = this._branch.__lookup(this._params[1]);
	// target.name = @params[1]
	this.log("FSMoveAction",this._params);
	this._prevDir.entries().remove(this.target());
	this.target().setParent(this._targetDir);
	this._targetDir.entries().add(this.target());
	// target.parentDir.entries.remove(target)
	return this;
};

FSMoveAction.prototype.revert = function (){
	this.log("FSMoveAction.revert");
	this._targetDir.entries().remove(this.target());
	this.target().setParent(this._prevDir);
	return this._prevDir.entries().add(this.target());
};

function FSRemoveAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(FSRemoveAction,StreamAction);
exports.FSRemoveAction = FSRemoveAction; // export class 
FSRemoveAction.handles(ACTION.FS_REMOVE);

FSRemoveAction.prototype.target = function (){
	return this._target || (this._target = this._branch.__lookup(this._params[0]));
};

FSRemoveAction.prototype.commit = function (){
	return this.target().commitDel();
};

FSRemoveAction.prototype.revert = function (){
	return this.target().revertDel();
};


function SimAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(SimAction,StreamAction);
exports.SimAction = SimAction; // export class 
SimAction.prototype.target = function (){
	return this._branch._space.simulator();
};

function SimBuild(){ return SimAction.apply(this,arguments) };

Imba.subclass(SimBuild,SimAction);
exports.SimBuild = SimBuild; // export class 
SimBuild.handles(ACTION.SIM_BUILD);

function SimResult(){ return SimAction.apply(this,arguments) };

Imba.subclass(SimResult,SimAction);
exports.SimResult = SimResult; // export class 
SimResult.handles(ACTION.SIM_RESULT);

function ConsoleAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(ConsoleAction,StreamAction);
ConsoleAction.prototype.target = function (){
	return this._branch._space._console;
};

ConsoleAction.prototype.data = function (){
	return this._params;
};

// applying this action
ConsoleAction.prototype.commit = function (cursor){
	cursor.markTarget(this.target());
	return this.target().apply(this);
};

// reverting this action
ConsoleAction.prototype.revert = function (cursor){
	cursor.markTarget(this.target());
	return this.target().revert(this);
};

ConsoleAction.prototype.isEnabled = function (){
	return false;
};

function ConsoleClear(){ return ConsoleAction.apply(this,arguments) };

Imba.subclass(ConsoleClear,ConsoleAction);
exports.ConsoleClear = ConsoleClear; // export class 
ConsoleClear.handles(ACTION.CONSOLE_CLEAR);

// TODO move logic here


function ConsoleLog(){ return ConsoleAction.apply(this,arguments) };

Imba.subclass(ConsoleLog,ConsoleAction);
exports.ConsoleLog = ConsoleLog; // export class 
ConsoleLog.handles(ACTION.CONSOLE_LOG);

// TODO move logic here


function ConsoleValExpand(){ return ConsoleAction.apply(this,arguments) };

Imba.subclass(ConsoleValExpand,ConsoleAction);
exports.ConsoleValExpand = ConsoleValExpand; // export class 
ConsoleValExpand.handles(ACTION.CONSOLE_VAL_EXPAND);

// TODO move logic here


// DOM events

var PlayerPage = require('../widgets/browser/PlayerPage').PlayerPage;

function PageAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(PageAction,StreamAction);
exports.PageAction = PageAction; // export class 
PageAction.prototype.page = function (){
	return this._page || (this._page = this._stream._lastPage);
};

PageAction.prototype.browser = function (){
	return this.branch().space().browser();
};

PageAction.prototype.commitToStream = function (stream){
	PageAction.prototype.__super__.commitToStream.apply(this,arguments);
	return this.page();
};

PageAction.prototype.isEnabled = function (){
	return false;
};

PageAction.prototype.baseURI = function (){
	return this.browser().baseURI(this.index());
};


function PageRequest(){ return PageAction.apply(this,arguments) };

Imba.subclass(PageRequest,PageAction);
exports.PageRequest = PageRequest; // export class 
PageRequest.handles(ACTION.PAGE_REQUEST);

PageRequest.prototype.page = function (){
	return this._page || (this._page = (this._stream._lastPage = new PlayerPage(this,{baseURI: this.baseURI()})));
};

PageRequest.prototype.url = function (){
	return this._params[1];
};

PageRequest.prototype.commit = function (){
	this.browser().setPage(this.page());
	if (this.url()) {
		this.browser().setUrl(this.url());
	};
	
	this._prevHistory = this.browser().history().apply(this.url(),this._params[2]);
	return this;
};

PageRequest.prototype.revert = function (){
	return this.browser().history().reset(this._prevHistory);
};



function PageLoad(){ return PageAction.apply(this,arguments) };

Imba.subclass(PageLoad,PageAction);
exports.PageLoad = PageLoad; // export class 
PageLoad.handles(ACTION.PAGE_LOAD);

PageLoad.prototype.page = function (){
	if (this._page) { return this._page };
	
	this._page = this._stream._lastPage;
	
	if (!this._page || this._page.loadAction()) {
		this._page = this._stream._lastPage = new PlayerPage(this,{baseURI: this.baseURI()});
	};
	
	this._page.setLoadAction(this);
	return this._page;
};

PageLoad.prototype.url = function (){
	return this._params[1];
};

PageLoad.prototype.commit = function (cursor){
	var v_;
	this.page().setStatus(this._params[0]);
	this.browser().setPage(this.page());
	return (this.browser().setUrl(v_ = this.url()),v_);
};

PageLoad.prototype.revert = function (cursor){
	this.page().setStatus(null);
	return this;
};

function PageLoaded(){ return PageAction.apply(this,arguments) };

Imba.subclass(PageLoaded,PageAction);
exports.PageLoaded = PageLoaded; // export class 
PageLoaded.handles(ACTION.PAGE_LOADED,{strategy: 'dedupe'});

PageLoaded.prototype.commit = function (cursor){
	if (!this._applied) {
		this._applied = true;
		this.page().applyInitialState(this._params);
		this.page().syncStyleSheets(this.branch().space().files());
	};
	
	this.browser().setPage(this.page());
	this.page().setLoaded(this);
	return this;
};

PageLoaded.prototype.revert = function (){
	this.page().setLoaded(null);
	return this;
};

function PageLogAction(){ return PageAction.apply(this,arguments) };

Imba.subclass(PageLogAction,PageAction);
exports.PageLogAction = PageLogAction; // export class 
PageLogAction.handles(ACTION.PAGE_LOG,{strategy: 'dedupe'});

PageLogAction.prototype.commit = function (cursor){
	this._page.logs().push(this._params);
	if (!cursor.skipping()) {
		this.space().emit('log',this);
	};
	return this;
};

PageLogAction.prototype.revert = function (){
	let item = this._page.logs().pop();
	if (item != this._params) {
		console.warn("PageLogAction reverted incorrectly?",this._params,item);
	};
	return this;
};

// Add PageLocationAction < PageAction

function DOMAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(DOMAction,StreamAction);
exports.DOMAction = DOMAction; // export class 
DOMAction.prototype.commitToStream = function (stream){
	DOMAction.prototype.__super__.commitToStream.apply(this,arguments);
	this._target = stream._lastPage;
	return this;
};

DOMAction.prototype.target = function (){
	return this._target || (this._target = this.space().simulator()._player.bridge());
};

DOMAction.prototype.browser = function (){
	return this.branch().space().browser();
};

DOMAction.prototype.node = function (id){
	return this._node || (this._node = this.target().nodeForPath((id == undefined) ? this._params[0] : id));
};

DOMAction.prototype.isEnabled = function (){
	return false;
};


function DOMReset(){ return DOMAction.apply(this,arguments) };

Imba.subclass(DOMReset,DOMAction);
exports.DOMReset = DOMReset; // export class 
DOMReset.handles(ACTION.DOM_RESET);

DOMReset.prototype.commit = function (){
	this.target().setFocusNode(null);
	this.target().setActiveNode(null);
	this.target().setHoverNode(null);
	this._rev || (this._rev = [].slice.call(this.target().root().childNodes));
	this.target().setSelection(null);
	this.target().root().innerHTML = '';
	return this.target().reindexNodes();
};

DOMReset.prototype.revert = function (){
	var root = this.target().root();
	for (let i = 0, items = iter$(this._rev), len = items.length; i < len; i++) {
		root.appendChild(items[i]);
	};
	this.target().setSelection(null);
	return this.target().reindexNodes();
};

function DOMMutate(){ return DOMAction.apply(this,arguments) };

Imba.subclass(DOMMutate,DOMAction);
exports.DOMMutate = DOMMutate; // export class 
DOMMutate.handles(ACTION.DOM_MUTATE);

DOMMutate.prototype.commit = function (){
	try {
		this.target().applyMutations(this._params);
	} catch (e) {
		this.log('mutate errored',e);
		this._error = e;
		this.target().setErrored(this);
	};
	return this;
};

DOMMutate.prototype.revert = function (){
	this.target().revertMutations(this._params,this);
	return this;
};

function DOMSelection(){ return DOMAction.apply(this,arguments) };

Imba.subclass(DOMSelection,DOMAction);
exports.DOMSelection = DOMSelection; // export class 
DOMSelection.handles(ACTION.DOM_SELECTION);

DOMSelection.prototype.commit = function (){
	var sel = null;
	
	if (this._params.length) {
		this._params.NODE || (this._params.NODE = this.node());
		sel = this._params;
	};
	
	this._rev = this.target().selection();
	return (this.target().setSelection(sel),sel);
};

DOMSelection.prototype.revert = function (){
	return (this.target().setSelection(this._rev),this._rev);
};


function DOMScroll(){ return DOMAction.apply(this,arguments) };

Imba.subclass(DOMScroll,DOMAction);
exports.DOMScroll = DOMScroll; // export class 
DOMScroll.handles(ACTION.DOM_SCROLL);

DOMScroll.prototype.commit = function (){
	var node;
	if (node = this.node()) {
		this._rev || (this._rev = [null,node.scrollLeft,node.scrollTop]);
		node.scrollLeft = this._params[1];
		return node.scrollTop = this._params[2];
	};
};

DOMScroll.prototype.revert = function (){
	if (this._rev) {
		this.node().scrollLeft = this._rev[1];
		return this.node().scrollTop = this._rev[2];
	};
};

function DOMFocusIn(){ return DOMAction.apply(this,arguments) };

Imba.subclass(DOMFocusIn,DOMAction);
exports.DOMFocusIn = DOMFocusIn; // export class 
DOMFocusIn.handles(ACTION.DOM_FOCUSIN,['domtarget']);

DOMFocusIn.prototype.commit = function (){
	var v_;
	this._rev = this.target().focusNode();
	return (this.target().setFocusNode(v_ = this.node()),v_);
};

DOMFocusIn.prototype.revert = function (){
	return (this.target().setFocusNode(this._rev),this._rev);
};

function DOMHoverIn(){ return DOMAction.apply(this,arguments) };

Imba.subclass(DOMHoverIn,DOMAction);
exports.DOMHoverIn = DOMHoverIn; // export class 
DOMHoverIn.handles(ACTION.DOM_HOVERIN,['domtarget']);

DOMHoverIn.prototype.commit = function (){
	var v_;
	this._rev = this.target().hoverNode();
	return (this.target().setHoverNode(v_ = this.node()),v_);
};

DOMHoverIn.prototype.revert = function (){
	return (this.target().setHoverNode(this._rev),this._rev);
};

function DOMActiveIn(){ return DOMAction.apply(this,arguments) };

Imba.subclass(DOMActiveIn,DOMAction);
exports.DOMActiveIn = DOMActiveIn; // export class 
DOMActiveIn.handles(ACTION.DOM_ACTIVEIN,['domtarget']);

DOMActiveIn.prototype.commit = function (){
	var v_;
	this._rev = this.target().activeNode();
	return (this.target().setActiveNode(v_ = this.node()),v_);
};

DOMActiveIn.prototype.revert = function (){
	return (this.target().setActiveNode(this._rev),this._rev);
};




// RECORDING

function RecStart(){ return StreamAction.apply(this,arguments) };

Imba.subclass(RecStart,StreamAction);
exports.RecStart = RecStart; // export class 
RecStart.handles(ACTION.RECSTART);

RecStart.prototype.__stop = {watch: 'stopDidSet',name: 'stop'};
RecStart.prototype.stop = function(v){ return this._stop; }
RecStart.prototype.setStop = function(v){
	var a = this.stop();
	if(v != a) { this._stop = v; }
	if(v != a) { this.stopDidSet && this.stopDidSet(v,a,this.__stop) }
	return this;
};
RecStart.prototype.audio = function(v){ return this._audio; }
RecStart.prototype.setAudio = function(v){ this._audio = v; return this; };

RecStart.prototype.commitToStream = function (stream){
	var stop_;
	if (this._parent) {
		(stop_ = this._parent.stop()) || ((this._parent.setStop(this),this));
	};
	
	stream.recordings().push(this);
	return RecStart.prototype.__super__.commitToStream.apply(this,arguments);
};

RecStart.prototype.removeFromStream = function (stream){
	if (this._parent && this._parent.stop() == this) {
		this._parent.setStop(null);
	};
	
	stream.recordings().pop();
	return RecStart.prototype.__super__.removeFromStream.apply(this,arguments);
};

RecStart.prototype.stopDidSet = function (stop,prev){
	if (stop) {
		this._duration = stop.timeOffset() - this.timeOffset();
		
		try {
			this._audio = {
				offset: this.timeOffset(),
				fid: this._params[1].audiofile.id,
				span: this._duration
			};
			
			this.branch()._stream.audio().add(this._audio);
		} catch (e) {
			true;
		};
	} else if (this._audio) {
		this.branch()._stream.audio().remove(this._audio);
	};
	
	return this;
};


function RecStop(){ return StreamAction.apply(this,arguments) };

Imba.subclass(RecStop,StreamAction);
exports.RecStop = RecStop; // export class 
RecStop.handles(ACTION.RECSTOP);

RecStop.prototype.recording = function(v){ return this._recording; }
RecStop.prototype.setRecording = function(v){ this._recording = v; return this; };

RecStop.prototype.commitToStream = function (stream){
	var stop_;
	if (this._recording = stream.recordings().last()) {
		(stop_ = this._recording.stop()) || ((this._recording.setStop(this),this));
	};
	return RecStop.prototype.__super__.commitToStream.apply(this,arguments);
};

RecStop.prototype.removeFromStream = function (stream){
	if (this._recording && this._recording.stop() == this) {
		this._recording.setStop(null);
	};
	return RecStop.prototype.__super__.removeFromStream.apply(this,arguments);
};

function TrimAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(TrimAction,StreamAction);
exports.TrimAction = TrimAction; // export class 
TrimAction.handles(ACTION.TRIM);


function LockAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(LockAction,StreamAction);
exports.LockAction = LockAction; // export class 
LockAction.handles(ACTION.LOCK);

LockAction.prototype.sid = function (){
	return this._params[0];
};

LockAction.prototype.uid = function (){
	return this._params[1];
};

LockAction.prototype.commitToStream = function (stream){
	// @prev.@next = self if @prev
	// stream.lastActions[@type] = self
	// stream.actions.push(self)
	// @byteEnd = stream.byteLength
	LockAction.prototype.__super__.commitToStream.apply(this,arguments);
	stream.setCurrentLock(this);
	return this;
};


function LayoutAction(){ return StreamAction.apply(this,arguments) };

Imba.subclass(LayoutAction,StreamAction);
exports.LayoutAction = LayoutAction; // export class 
LayoutAction.handles(ACTION.LAYOUT);

LayoutAction.decode = function (params,rel){
	return new this((rel ? Struct.decode(rel,params) : params));
};

LayoutAction.encode = function (params,rel){
	return rel ? ((Struct.diff(rel,params) || [0])) : params;
};

LayoutAction.prototype.target = function (){
	return this._branch.__lookup(this._params[12]);
};

LayoutAction.prototype.commit = function (){
	// could use the existing subaction-system
	var target;
	if (target = this.target()) {
		this._prevValue = target._data.layout;
		target._data.layout = this._params;
	};
	return;
};

LayoutAction.prototype.revert = function (){
	this.target()._data.layout = this._prevValue;
	return;
};

function BrowserLayoutAction(){ return LayoutAction.apply(this,arguments) };

Imba.subclass(BrowserLayoutAction,LayoutAction);
exports.BrowserLayoutAction = BrowserLayoutAction; // export class 
BrowserLayoutAction.handles(ACTION.BROWSER_LAYOUT);

// LEGACY
function WidgetAppend(){ return StreamAction.apply(this,arguments) };

Imba.subclass(WidgetAppend,StreamAction);
exports.WidgetAppend = WidgetAppend; // export class 
WidgetAppend.handles(ACTION.WIDGET_APPEND);

function WidgetFlag(){ return StreamAction.apply(this,arguments) };

Imba.subclass(WidgetFlag,StreamAction);
exports.WidgetFlag = WidgetFlag; // export class 
WidgetFlag.handles(ACTION.WIDGET_FLAG,['target','int_flag']);

function WidgetUnflag(){ return StreamAction.apply(this,arguments) };

Imba.subclass(WidgetUnflag,StreamAction);
exports.WidgetUnflag = WidgetUnflag; // export class 
WidgetUnflag.handles(ACTION.WIDGET_UNFLAG,['target','int_flag']);




// ACTION.DOM_RESET = DOM.RESET = 60
// ACTION.DOM_INSERT = DOM.INSERT = 61
// ACTION.DOM_MUTATE = DOM.MUTATE = 65
// ACTION.DOM_EVENT = DOM.EVENT = 80
// ACTION.DOM_SCROLL = DOM.SCROLL = 81
// ACTION.DOM_FOCUSIN = DOM.FOCUSIN = 82 # [path]
// ACTION.DOM_FOCUSOUT = DOM.FOCUSOUT = 83 # [path]
// ACTION.DOM_HOVERIN = DOM.HOVERIN = 84
// ACTION.DOM_HOVEROUT = DOM.HOVEROUT = 85
// ACTION.DOM_ACTIVEIN = DOM.ACTIVEIN = 86
// ACTION.DOM_ACTIVEOUT = DOM.ACTIVEOUT = 87
// ACTION.DOM_SELECTION = DOM.SELECTION = 88 # also in state?