function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');
// externs;

var Widget = require('./widget').Widget;
var PaneWidget = require('./PaneWidget').PaneWidget;

var protocol$ = require('../protocol'), WIDGET = protocol$.WIDGET, FILE = protocol$.FILE, SCON = protocol$.SCON, ACTION = protocol$.ACTION, LCRange = protocol$.LCRange;

var List = require('../util/List').List;
var TextModel = require('../util/TextModel').TextModel;

var editor;
if (false) {};
var strutil = require('../../util/strings');

var Dimensions = require('../core/Dimensions').Dimensions;

var tracking = require('../../scrimba/tracking');

// wrapper around monaco editor and model
function FileModel(file){
	this._file = file;
	this._batch = [];
	this._batchState = {};
	this._changes = [];
	this._raw = new TextModel(this._file.initialBody());
	// Preload model for the worker
	this.model();
	
	this;
};

FileModel.prototype.file = function(v){ return this._file; }
FileModel.prototype.setFile = function(v){ this._file = v; return this; };
FileModel.prototype.model = function(v){ return this._model; }
FileModel.prototype.setModel = function(v){ this._model = v; return this; };

FileModel.prototype.id = function (){
	return this.file().__uid();
};

FileModel.prototype.space = function (){
	return this.file().space();
};

FileModel.prototype.body = function (){
	return this._raw.getValue();
};

FileModel.prototype.logLine = function (nr){
	var ret;
	var raw = this._raw._lines[nr];
	var monaco = this._model._lines[nr];
	return ret = [raw,monaco._text,raw.length,monaco._text.length];
};

FileModel.prototype.applyEdits = function (edit,silent){
	if(silent === undefined) silent = false;
	if (!edit.MONACO) {
		let res = [];
		for (let i = 0, items = iter$(edit), len = items.length, item; i < len; i++) {
			item = items[i];
			res.push({range: editor.arrayToRange(item[0]),text: item[1]});
		};
		edit.MONACO = res;
	};
	return this._applyEditsRaw.call(this._model,edit.MONACO);
};

FileModel.prototype.isSyncing = function (){
	return this._syncing || this.space().isSyncing();
};

FileModel.prototype.model = function (){
	if (false) {};
	return this._model;
};

FileModel.prototype.setupMonaco = function (){
	var self = this;
	if (!false || self._model || self._initing || !window.monaco) { return };
	
	self._initing = true;
	
	self._uri = monaco.Uri.parse(self.file().uri());
	// console.warn "setup file",file,file.uri,body,@queue
	self._changes = [];
	
	let existing = monaco.editor.getModel(self._uri);
	
	if (existing) {
		// console.log "model already exists!!!",existing
		existing.FILE_MODEL.dispose();
	};
	
	self._model = monaco.editor.createModel(self._raw.getValue(),null,self._uri); // 'text'
	self._initing = false;
	self._model.FILE_MODEL = self;
	
	var opts = {
		trimAutoWhitespace: false
	};
	
	if (self._file.useTabs()) {
		opts.insertSpaces = false;
		opts.tabSize = 4;
	};
	
	self._model.updateOptions(opts);
	
	
	var applyEditsRaw = self._applyEditsRaw = self._model.applyEdits;
	
	self._model.applyEdits = function(operations) {
		var rev = applyEditsRaw.call(self._model,operations);
		if (!(self.isSyncing())) {
			self._batchState.significant = true;
			self._batchState.preapplied = true;
			
			var scrimbaOps = [];
			var count = len$(operations);
			// workaround for our version of monaco where backspace-deleting
			// an emoji would return an incorrect range
			for (let i = 0, items = iter$(operations), len = items.length, op; i < len; i++) {
				op = items[i];
				if (rev[i] && strutil.containsEmoji(rev[i].text)) {
					// console.log "reversed operation contains emoji!!!",rev[i]
					op.range.startColumn = rev[i].range.startColumn;
				};
				
				let range = editor.rangeToArray(op.range);
				
				if (op.text) {
					scrimbaOps.push([range,op.text]);
				} else {
					scrimbaOps.push([range]);
				};
				
				// single inserts from collaped range
				if (count == 1) {
					if (op.text && range.length == 2) {
						// console.log "LCINSERT",range,op:text
						self.pushEvent(ACTION.LCINSERT,[self.id(),range[0],range[1],op.text]);
						return rev;
					} else if (!op.text) {
						// range[0],range[1],range[2],range[3]
						self.pushEvent(ACTION.LCDELETE,[self.id()].concat(range));
						return rev;
					};
				};
			};
			
			// console.log "LCEDIT",id,scrimbaOps
			self.pushEvent(ACTION.LCEDIT,[self.id(),scrimbaOps]);
		};
		return rev;
	};
	
	return self;
};

FileModel.prototype.onDidChangeCursorSelection = function (event){
	var ary, items;
	if (!(this.isSyncing())) {
		var sel = editor.selectionToArray(event.selection);
		var msel = [sel];
		
		for (let i = 0, items = iter$(event.secondarySelections), len = items.length; i < len; i++) {
			sel = null;
			msel.push(editor.selectionToArray(items[i]));
		};
		
		let last = this._batch[len$(this._batch) - 1] || {};
		
		if (last.TYPE == ACTION.LCINSERT) {
			// console.log "cursor selection after LCINSERT?"
			var ary = iter$(last);let tid = ary[0],tline = ary[1],tcol = ary[2],tins = ary[3];
			if (tins.indexOf('\n') >= 0 || !sel || sel[0] != tline || (sel[1] - (tcol + tins.length)) != 0) {
				last.push(sel || msel);
			};
		} else if (last.TYPE == ACTION.LCDELETE) {
			
			var items = iter$(last);let tid = items[0],l0 = items[1],c0 = items[2];
			if (!sel || sel[0] != l0 || sel[1] != c0 || sel.length > 2) {
				last[5] = sel || msel;
			};
		} else if (last.TYPE == ACTION.LCEDIT) {
			last.push(sel || msel);
		} else if (!this.file().space().isEditing()) {
			// setting the localSelection
			this.file().setLocalSel(sel || msel);
			if (this.file().space().isPlaying()) {
				this.file().space().timeline().pause();
			};
		} else {
			this.pushEvent(ACTION.LCSELECTION,[this.id()].concat(sel || msel));
		};
		// cursorSelection will always be the last event we want in a batch
		// so we should force flush the batch immediately
		this.flushEvents();
	};
	return this;
};

FileModel.prototype.pushEvent = function (type,params){
	var self = this;
	params.TYPE = type;
	self._batch.push(params);
	setTimeout(function() { return self.flushEvents(); },0);
	return self;
};

FileModel.prototype.flushEvents = function (){
	if (len$(this._batch)) {
		var items = this._batch.slice(0);
		var state = this._batchState;
		this._batch = [];
		this._batchState = {};
		// console.log 'flush events',items.len
		this.file().setLocalSel(null);
		
		if (len$(items) == 1) {
			this.file().push_(items[0].TYPE,items[0],state);
		} else {
			let batched;
			let res = [];
			for (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
				item = ary[i];
				res.push([item.TYPE,item]);
			};
			batched = res;
			this.file().batch_(batched,state);
		};
	};
	return this;
};


FileModel.prototype.apply = function (edits,isLocal){
	if(isLocal === undefined) isLocal = false;
	this._raw.apply(edits);
	if (!isLocal || !isLocal.preapplied) {
		this._changes.push(edits);
	};
	return this;
};

FileModel.prototype.undo = function (edits){
	this._raw.apply(edits.UNDO,-1);
	for (let i = 0, items = iter$(edits.UNDO), len = items.length; i < len; i++) {
		this._changes.push([items[i]]);
	};
	return this;
};


FileModel.prototype.flushChanges = function (){
	var self = this;
	if (!self._model) { return };
	
	var editor = self._file._editor;
	var ops = self._changes;
	var now = Date.now();
	
	if (len$(ops) == 0) {
		return self;
	};
	
	self._changes = [];
	self._syncing = true;
	
	// just update the body directly
	if (len$(ops) > 3) {
		// window.FE = self
		
		// TODO should delay rendering for editor even if we batch
		
		self._changeDiff = {
			model: self._model.getValue(),
			raw: self._raw.getValue()
		};
		// @lastOps = ops
		var diff = self._raw.getDiff(self._model._lines);
		
		self._changeDiff.diff = diff;
		
		if (diff && diff[0][0] == 1) {
			// should rather check whether we have many changes
			self._model.setValue(self._raw.getValue());
		} else if (diff) {
			self.applyEdits([diff]);
			// @applyEditsRaw.call(@model,[patch])
		};
		// console.log "applied patch",diff
	} else if (editor) {
		// should we ever use these?
		editor.batchEdits(function() {
			// console.log "flush applyEdits",ops
			let res = [];
			for (let i = 0, items = iter$(ops), len = items.length; i < len; i++) {
				res.push(self.applyEdits(items[i]));
			};
			return res;
		});
	} else {
		for (let i = 0, items = iter$(ops), len = items.length; i < len; i++) {
			self.applyEdits(items[i]);
		};
	};
	
	// console.log 'flushChanges',ops.len,Date.now - now
	self._syncing = false;
	self._file.async('modified');
	return self;
};

FileModel.prototype.enable = function (){
	this._enabled = true;
	return this;
};

FileModel.prototype.disable = function (){
	this._enabled = false;
	return this;
};

FileModel.prototype.dispose = function (){
	this._model && this._model.dispose  &&  this._model.dispose();
	this._model = null;
	return this;
};

function FileWidget(){ return PaneWidget.apply(this,arguments) };

Imba.subclass(FileWidget,PaneWidget);
exports.FileWidget = FileWidget; // export class 
FileWidget.register('file',FILE);

// attr name
FileWidget.prototype.body = function(v){ return this.getAttribute('body'); }
FileWidget.prototype.setBody = function(v){ this.setAttribute('body',v); return this; };
FileWidget.prototype.lang = function(v){ return this.getAttribute('lang'); }
FileWidget.prototype.setLang = function(v){ this.setAttribute('lang',v); return this; };
FileWidget.prototype.blobId = function(v){ return this.getAttribute('blobId'); }
FileWidget.prototype.setBlobId = function(v){ this.setAttribute('blobId',v); return this; };

FileWidget.prototype.buffer = function(v){ return this._buffer; }
FileWidget.prototype.setBuffer = function(v){ this._buffer = v; return this; };
FileWidget.prototype.diff = function(v){ return this._diff; }
FileWidget.prototype.setDiff = function(v){ this._diff = v; return this; };
FileWidget.prototype.stream = function(v){ return this._stream; }
FileWidget.prototype.setStream = function(v){ this._stream = v; return this; };
FileWidget.prototype.editor = function(v){ return this._editor; }
FileWidget.prototype.setEditor = function(v){ this._editor = v; return this; };

FileWidget.prototype.scrollState = function(v){ return this._scrollState; }
FileWidget.prototype.setScrollState = function(v){ this._scrollState = v; return this; };
FileWidget.prototype.selState = function(v){ return this._selState; }
FileWidget.prototype.setSelState = function(v){ this._selState = v; return this; };
FileWidget.prototype.__localSel = {watch: 'localSelDidSet',name: 'localSel'};
FileWidget.prototype.localSel = function(v){ return this._localSel; }
FileWidget.prototype.setLocalSel = function(v){
	var a = this.localSel();
	if(v != a) { this._localSel = v; }
	if(v != a) { this.localSelDidSet && this.localSelDidSet(v,a,this.__localSel) }
	return this;
};
FileWidget.prototype.localScroll = function(v){ return this._localScroll; }
FileWidget.prototype.setLocalScroll = function(v){ this._localScroll = v; return this; };
// prop decorations

FileWidget.option('name');
FileWidget.option('parent',{type: 'widget'});

// only for text-files. Should probably be stored on the editor-widget instead
// or on a subwidget of file representing the actual ViewModel
FileWidget.option('scrollTop');
FileWidget.option('scrollLeft');

FileWidget.prototype.setup = function (){
	this._localScroll = false;
	this._selState = [[1,1]];
	this._stream = [];
	this._edits = 0;
	this._initialBody = this.data().body;
	this._decorations = {};
	// @decorations = List.new(self)
	return this;
};

FileWidget.prototype.posToScreen = function (x,y,sl,cl){
	if (this._editor) {
		let layout = this.agentLayout();
		let pars = {
			top: layout.top(),
			left: layout.left(),
			contentTop: 0,
			contentLeft: 0,
			scrollTop: layout.scrollTop(),
			scrollLeft: layout.scrollLeft(),
			fontSize: layout.scaleX(),
			lineHeight: layout.scaleY()
		};
		
		return this.space().primaryEditor().agentToLocalPoint(x,y,pars);
	};
	
	return null;
};

FileWidget.prototype.model = function (){
	return this._model || (this._model = new FileModel(this));
};

FileWidget.prototype.localLayout = function (){
	return this._editor ? this.clientLayout() : null;
};

FileWidget.prototype.uri = function (){
	return ("" + (this.space().namespace()) + this.path());
};

FileWidget.prototype.ext = function (){
	let idx = this.name().lastIndexOf('.');
	return (idx > 0) ? this.name().substr(idx + 1) : '';
};

FileWidget.prototype.lang = function (){
	return this.data().lang || this.ext() || 'text';
};

FileWidget.prototype.title = function (){
	return this.name();
};

FileWidget.prototype.commitAdd = function (){
	FileWidget.prototype.__super__.commitAdd.apply(this,arguments);
	// space.files.add(self,id)
	this._initialBody = this.data().body; // really?
	return this;
};

FileWidget.prototype.mount_ = function (){
	FileWidget.prototype.__super__.mount_.apply(this,arguments);
	this.space().files().add(this,this.id());
	return this.parentDir().entries().add(this);
};

FileWidget.prototype.unmount_ = function (){
	FileWidget.prototype.__super__.unmount_.apply(this,arguments);
	// what if parentDir no longer exists?
	this.space().files().remove(this,this.id());
	return this.parentDir().entries().remove(this);
};

FileWidget.prototype.parentDir = function (){
	return this.parent() || this.space().fs();
};

FileWidget.prototype.replaceBody = function (newBody,hard){
	if(hard === undefined) hard = false;
	var prev = this.body();
	var diff = new TextModel(newBody).getDiff(this.model().body());
	
	if (hard) {
		var range = this.model()._raw.expandedRange([1,1],prev);
		diff = [range,newBody];
	};
	
	this.log("replacBody",diff);
	if (diff) {
		return this.push_(ACTION.LCEDIT,[this.id(),[diff]]);
	};
};

FileWidget.prototype.deltaDecorations = function (ns,decorations){
	var range_;
	if (true) { return };
	// what if monaco is not already loaded?
	for (let i = 0, items = iter$(decorations), len = items.length, item; i < len; i++) {
		item = items[i];
		if ((typeof (range_ = item.range)=='string'||range_ instanceof String)) {
			item.range = editor.stringToRange(item.range);
		} else if (item.range instanceof Array) {
			item.range = editor.arrayToRange(item.range);
		};
	};
	
	this.log("deltaDecorations",decorations);
	
	return this._decorations[ns] = this.model().model().deltaDecorations(this._decorations[ns] || [],decorations);
	// @decorations = model.model.deltaDecorations(@decorations,decorations)
};

FileWidget.prototype.initialBody = function (){
	return (this._initialBody == null) ? (this._initialBody = this.data().body) : this._initialBody;
};

FileWidget.prototype.currentBody = function (){
	return this.model().body();
};

FileWidget.prototype.localSelDidSet = function (new$){
	var self = this;
	clearTimeout(self._localSelTrackingTimeout);
	if (new$) {
		self._localSelTrackingTimeout = setTimeout(function() {
			return self.space().api().sendTracking(tracking.TYPES.SELECTION,[self.space().timeline().currentOffset(),self.id(),new$]);
		},500);
	};
	return self;
};

FileWidget.prototype.flushLocals = function (){
	if (this.localSel()) {
		this.push_(ACTION.LCSELECTION,[this.id()].concat(this.localSel()));
	};
	return this;
};

FileWidget.prototype.buffer = function (){
	return this.data().buffer || this.data().body;
};

FileWidget.prototype.toString = function (){
	return this.currentBody();
};

FileWidget.prototype.persist_ = function (){
	this._data.body = this.currentBody();
	this._data.selState = this._selState;
	return this;
};

FileWidget.prototype.modified = function (){
	this.emit('modified',this);
	return this;
};

FileWidget.prototype.synced_ = function (){
	// TODO -- could be synced immediately
	this._data.body = this.currentBody();
	// no need to flush until the editor tries to flush?
	return this._model && this._model.flushChanges  &&  this._model.flushChanges();
};

FileWidget.prototype.pointer = function (){
	return this._editor && this._editor.pointer();
};

FileWidget.prototype.node = function (){
	return this._editor;
};

FileWidget.prototype.agentIsShowing = function (){
	return this.space().agent().options().get('file',false) == this;
};

FileWidget.prototype.clientIsShowing = function (){
	return this.space().agent().file() == this;
};

FileWidget.prototype.isBinary = function (){
	return !(!(this.blobId()));
};

FileWidget.prototype.useTabs = function (){
	return this.lang() == 'imba';
};

FileWidget.prototype.quicksave = function (){
	this.space().emit('quicksave',this);
	return this;
};

FileWidget.prototype.dispose = function (){
	this._editor = null;
	return this._model && this._model.dispose  &&  this._model.dispose();
};

FileWidget.prototype.rename = function (name){
	// should check with filesystem(!)
	if (!name || name == this.name() || this.parentDir().entries().any(function(f) { return f.name() == name; })) {
		return this;
	};
	
	return this.push_(ACTION.FS_RENAME,[this.id(),name]);
};

FileWidget.prototype.moveTo = function (target){
	// should be separate action, or just change parent?
	this.log("moveTo",target);
	if (this.parent() != target) {
		this.push_(ACTION.FS_MOVE,[this.id(),target.id()]);
		return this;
	};
};

FileWidget.prototype.path = function (){
	return ("" + (this.parentDir().path()) + "/" + this.name());
};

FileWidget.prototype.rm = function (){
	// should ask to confirm
	// check if we are currently in focus?
	if (this.space().agent().file() == this) {
		// let idx = space.files.indexOf(self)
		// let rel = space.files.at(idx - 1) or space.files.at(idx + 1)
		this.space().agent().setFocus(null);
		this.space().agent().setFile(null);
	};
	
	return this.push_(ACTION.FS_REMOVE,[this.id()]);
};


