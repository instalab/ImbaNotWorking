function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba'), _1 = Imba.createElement;
var protocol$ = require('./protocol'), ACTION = protocol$.ACTION, SCON = protocol$.SCON, MSG = protocol$.MSG, SPIV = protocol$.SPIV;
var Widget = require('./widgets/widget').Widget;
var Recording = require('./core/Recording').Recording;
var Timeline$ = require('./core/Timeline'), AbsTimeline = Timeline$.AbsTimeline, PubTimeline = Timeline$.PubTimeline;

var List = require('./util/List').List;

var StreamSyncer = require('./core/StreamSyncer').StreamSyncer;
var StreamAction = require('./core/StreamAction').StreamAction;
var StreamBuffer = require('./core/StreamBuffer').StreamBuffer;
var Stream = require('./core/Stream').Stream;

var LocalBranchDialog = require('./views/LocalBranchDialog').LocalBranchDialog;

var util = require('../util');
var msgpack = require('msgpack-lite');

// externs;

var tracking = require('./tracking');

function Branch(space,parent,model){
	// should it be possible to init a branch before parent is loaded?
	var v_;
	this._space = space;
	this._parent = parent;
	this._model = model = space.api().db().read(model);
	
	this._currentOffset = 0;
	// create cues for these maybe?!
	this._draft = model.draft || {start: 0,cues: [],audio: []};
	this._pub = model.pub;
	
	this._stream = new Stream(model.stream(),this,this.seed());
	this._branches = new List(this);
	this._ancestors = parent ? parent.ancestors().concat(parent) : [];
	
	if (parent) {
		parent.branches().add(this,this.id());
	};
	
	// should we not switch to abs only when we actively want to continue?
	if (model.pub && (!(this.isMine()) || this.api().isEmbed() || this.api().isMobile())) {
		var typ = model.pub.audio ? PubTimeline : AbsTimeline;
		this.setTimeline((this.setPubTimeline(v_ = new typ(this,this._pub)),v_));
	} else {
		this.setTimeline((this.setAbsTimeline(v_ = new AbsTimeline(this,this._draft)),v_));
	};
	
	this._currentOffset = this.timeline().currentOffset();
	this;
};

Imba.subclass(Branch,Widget);
exports.Branch = Branch; // export class 
Branch.register('branch');


Branch.modelDataFromEvent = function (event,opts){
	if(opts === undefined) opts = {};
	var par = event.branch();
	var cid = par.id();
	var offset = par.timeline().currentOffset();
	var time = par.timeline().currentTime();
	var api = SCRIMBA_API;
	var uid = api.uid();
	// var snap = par.toSnapshot
	
	var title = ("Local edits at " + util.msToStr(time));
	
	var data = {
		type: 'note', // note?
		title: title,
		privacy: 'public',
		spiv: SPIV,
		uid: uid || ("-" + (api.localToken())),
		parent_id: par.id(),
		parent_index: event.index(),
		parent_offset: offset,
		created_at: new Date(),
		edited_at: new Date(),
		v: -2
	};
	
	if (!uid) {
		// what?
		data.LOCAL = true;
	};
	
	for (let v, i = 0, keys = Object.keys(opts), l = keys.length, k; i < l; i++){
		k = keys[i];v = opts[k];data[k] = v;
	};
	
	return data;
};

Branch.modelFromEvent = function (event){
	// start as offline thing
	// console.log "branch!",data
	var data = this.modelDataFromEvent(event);
	return event.branch().space().api().db().casts().build(data);
};

Branch.branchFromEvent = function (source){
	
	var model = this.modelFromEvent(source);
	var snap = source.branch().toSnapshot();
	var api = source.branch().api();
	
	api.sendTracking(tracking.TYPES.CREATE_BRANCH,[model.id,model.parent_id,model.parent_index,model.parent_offset]);
	
	// add initial action to stream
	var buf = StreamBuffer.encode([-ACTION.SNAPSHOT,[snap],-ACTION.LOCK,[api.sid(),api.uid()]]);
	model.buffer().add(buf,0);
	
	var branch = new this(source.branch().space(),source.branch(),model);
	branch._initialSnapshot = snap;
	// var action = branch.action(ACTION.BRANCH,[snap])
	branch._parentPlayState = source.branch().timeline().state();
	branch._isLoaded = true;
	branch.setMode('editing');
	branch.stream().sync({local: true});
	// branch.addLocalEvent(action)
	// console.log "branch from event",branch,action
	return branch;
};

// the currently active timeline for this branch
Branch.prototype.absTimeline = function(v){ return this._absTimeline; }
Branch.prototype.setAbsTimeline = function(v){ this._absTimeline = v; return this; };
Branch.prototype.pubTimeline = function(v){ return this._pubTimeline; }
Branch.prototype.setPubTimeline = function(v){ this._pubTimeline = v; return this; };
Branch.prototype.__timeline = {watch: 'timelineDidSet',name: 'timeline'};
Branch.prototype.timeline = function(v){ return this._timeline; }
Branch.prototype.setTimeline = function(v){
	var a = this.timeline();
	if(v != a) { this._timeline = v; }
	if(v != a) { this.timelineDidSet && this.timelineDidSet(v,a,this.__timeline) }
	return this;
};

Branch.prototype.draft = function(v){ return this._draft; }
Branch.prototype.setDraft = function(v){ this._draft = v; return this; };
Branch.prototype.branches = function(v){ return this._branches; }
Branch.prototype.setBranches = function(v){ this._branches = v; return this; };
Branch.prototype.recording = function(v){ return this._recording; }
Branch.prototype.setRecording = function(v){ this._recording = v; return this; };
Branch.prototype.ancestors = function(v){ return this._ancestors; }
Branch.prototype.setAncestors = function(v){ this._ancestors = v; return this; };
Branch.prototype.currentOffset = function(v){ return this._currentOffset; }
Branch.prototype.setCurrentOffset = function(v){ this._currentOffset = v; return this; };

// container for the events in this branch
Branch.prototype.stream = function(v){ return this._stream; }
Branch.prototype.setStream = function(v){ this._stream = v; return this; };

Branch.prototype.id = function (){
	return this._model.id;
};

Branch.prototype.api = function (){
	return this.space().api();
};

Branch.prototype.inspect = function (){
	return ("Branch(id=" + this.id() + ")");
};

Branch.prototype.title = function (){
	return this.model().title || "Branch";
};

Branch.prototype.model = function (){
	return this._model;
};

Branch.prototype.data = function (){
	return this._model;
};

Branch.prototype.parent = function (){
	return this._parent;
};

Branch.prototype.dispose = function (){
	this._stream && this._stream.dispose  &&  this._stream.dispose();
	this._syncer && this._syncer.dispose  &&  this._syncer.dispose();
	return this;
};

Branch.prototype.tick = function (){
	// refreshBranches
	return this;
};

Branch.prototype.syncer = function (){
	return this._syncer || (this._syncer = new StreamSyncer(this.stream(),this.api().socket()));
};

Branch.prototype.head = function (){
	return this._stream.tail();
};

Branch.prototype.seed = function (){
	return this._seed || (this._seed = this._parent.stream().actionAtIndex(this.model().parent_index));
};

Branch.prototype.ancestors = function (){
	return this._ancestors;
};

Branch.prototype.branch = function (){
	return this;
};

Branch.prototype.setup = function (){
	return this;
};

Branch.prototype.state = function (){
	return this.model().state;
};

Branch.prototype.type = function (){
	return this.model().type || 'cast';
};

Branch.prototype.pub = function (){
	return this.model().pub;
};

Branch.prototype.isInScope = function (){
	var other = this.space().branch();
	while (other){
		if (other == this) {
			return true;
		};
		other = other.parent();
	};
	return false;
};

Branch.prototype.isPublished = function (){
	return this.model().isPublished();
};

// is it disallowed to record more or continue editing this cast?
Branch.prototype.isLocked = function (){
	return this.isPublished();
};

Branch.prototype.isSignificant = function (){
	return this.stream().duration() > 0;
};

Branch.prototype.isTemplate = function (){
	return this.type() == 'template';
};
Branch.prototype.isLab = function (){
	return this.type() == 'lab';
};
Branch.prototype.isNote = function (){
	return this.type() == 'note';
};
Branch.prototype.isFork = function (){
	return this.type() == 'fork';
};
Branch.prototype.isTutorial = function (){
	return this.type() == 'tutorial';
};

Branch.prototype.isLocal = function (){
	return this.model().isLocal();
};

Branch.prototype.isMine = function (){
	return this.model().uid == this.api().uid() || this.isLocal();
};

Branch.prototype.isActive = function (){
	return this.space().branch() == this;
};

Branch.prototype.setMode = function (mode){
	return this.timeline().setState(mode);
};

Branch.prototype.mode = function (){
	return this.timeline().state();
};

Branch.prototype.isEditing = function (){
	return this.timeline().isEditing();
};
Branch.prototype.isRecording = function (){
	return this.timeline().isRecording();
};
Branch.prototype.isWatching = function (){
	return this.timeline().isWatching();
};
Branch.prototype.isPlaying = function (){
	return this.timeline().isPlaying();
};
Branch.prototype.isPaused = function (){
	return this.timeline().isPaused();
};
Branch.prototype.isAnnotating = function (){
	return this.timeline().isAnnotating();
};
Branch.prototype.isLive = function (){
	return this.timeline().isLive();
};

Branch.prototype.isForkable = function (){
	return this.type() != 'fork' && (!(this.isLab()) || !(this.isMine())) && this.model().isForkable();
};

Branch.prototype.hasUnsavedChanges = function (){
	return this.model().isLocal() || this._unsavedChanges;
};

Branch.prototype.hasUnpublishedChanges = function (){
	return !this.model().pub || (this.model().draft && !SCON.compare(this.model().draft.cues,this.model().pub.cues));
};

Branch.prototype.hasRecordings = function (){
	return len$(this.stream().recordings()) > 0;
};

Branch.prototype.hasDuration = function (){
	return this.hasRecordings() || this.draft().end;
};

// can I contribute to this branch?
Branch.prototype.canContribute = function (){
	return this.isLocal() || this.model().hasMember(this.api().uid());
};

Branch.prototype.canEdit = function (){
	return this._isLoaded && (this.isLocal() || this.stream().currentSID() == this.api().sid());
};

// TODOEDIT
Branch.prototype.canPush = function (action){
	return this.isEditing() && this.space().cursor().current() == this.head() && this.stream().canPush(action);
};

Branch.prototype.canPublish = function (){
	return this.canContribute() && !(this.isLocal()) && this.hasRecordings() && !(this.isTemplate()) && this.hasUnpublishedChanges() && !(this.hasUnsavedChanges()) && !this.api().isMobile();
};

Branch.prototype.canPrepare = function (){
	return this.canContribute() && !(this.hasRecordings());
};

Branch.prototype.canAnnotate = function (){
	return this.canContribute() && this.hasRecordings() && !this.api().ua().isPhone() && (this.timeline() instanceof AbsTimeline);
};

Branch.prototype.canRecord = function (){
	return this.canContribute() && !(this.isLocked()) && !(this.isTemplate()) && !(this.isLocal()) && !(this.isLab()) && (!this._parent || !this._parent.isLab()) && !this.api().isMobile();
};

Branch.prototype.canSave = function (){
	return this.isActive() && this.canContribute() && this.hasUnsavedChanges() && this.api().uid();
};

Branch.prototype.checkIntegrity = async function (){
	var stats = await this.api().rpc('castCheckIntegrity',[this.id()]);
	console.log("result from integrity",stats);
	return stats;
};

Branch.prototype.ensureIntegrity = async function (){
	var self = this;
	var files = self.draft().audio.map(function(item) { return self.api().db().get(item[3]); });
	await Promise.all(files.map(function(file) { return file.repair(); }));
	
	var stats = await self.checkIntegrity();
	var byteLength = len$(self.stream().buffer());
	if (stats.byteLength != byteLength) {
		console.warn("The length of the stream differs on server and client",stats,byteLength);
	};
	
	if (len$(stats.issues)) {
		console.warn("There are known issues with cast",stats.issues);
	};
	
	return Promise.resolve(stats);
};

Branch.prototype.registerView = function (){
	if (this._registeredView || this.space().isDisposing()) {
		return;
	};
	
	this._registeredView = true;
	// TODO do this through socket
	return this.api().rpc('registerView',[this.id()]);
};

Branch.prototype.addLocalEvent = function (event,meta){
	if(meta === undefined) meta = {};
	var action = this.stream().write(event,meta);
	
	if (!action) {
		console.warn("action rejected by stream");
		event.discard();
		return;
	};
	
	this.forceToEnd();
	this.syncer().schedule();
	
	// if you need to lock - also push locals?
	if (this.isWatching()) {
		this.setMode('editing');
	};
	
	return action;
};

Branch.prototype.forceToEnd = function (){
	var action;
	if (action = this.head()) {
		this.space().cursor().sync(action);
		// currentOffset = action.offset
		// timeline.anchorTime(action.offset)
	};
	return this;
};

Branch.prototype.currentOffset = function (){
	return (this._currentOffset == -1) ? ((this._stream.duration() || 0)) : this._currentOffset;
};

// recursively update currentOffset for ancestoral branches
// should probably give a more descriptive name
Branch.prototype.didEnter = function (from){
	// console.log "didEnter!",from
	if (this.parent()) {
		this.parent().setCurrentOffset(this.model().parent_offset);
		this.parent().didEnter();
		
		if (from == this.parent()) {
			// what if parent doesnt really have a timeline to speak of?
			if (this.parent().isPlaying()) { this.parent().timeline().pause() };
		};
	};
	
	if (!(this.isLocal())) {
		this.space().socket().join(this.id());
	};
	
	if (this.space().trunk().isLab() && this.isLocal()) {
		((_1(LocalBranchDialog)).setData(this).end()).show();
	};
	// elif space.trunk.isTutorial and isLocal
	// 	space.view.alert("Entered playground mode – click _play_ to resume watching", info: yes, duration: 5000)
	
	return this;
};

Branch.prototype.didLeave = function (to){
	if (this.isEditing()) {
		this.log('go from editing to watching!!!',this);
		this.setMode('watching');
	};
	
	var scoped = this.isInScope();
	
	if (this.isInScope()) {
		return;
	};
	
	if (this.isLocal()) {
		// be careful about infinite looping here?
		// should not autodiscard?
		// discard unless isSignificant
		this;
	} else {
		this.space().socket().leave(this.id());
	};
	
	if (this.parent()) {
		return this.parent().didLeave(to);
	};
};

Branch.prototype.enter = function (){
	if (this.isActive()) {
		return this;
	};
	
	// We indirectly tell the space which branch we're at
	// by setting the current timeline. Should be refactored
	this.space().setTimeline(this.timeline());
	this.space().tick();
	return this;
};

Branch.prototype.leave = function (){
	if (this.isActive()) { return this.space().navigateTo(this.parent()) };
};

Branch.prototype.discard = function (){
	if (this.isLocal()) {
		if (this.timeline().isEditing()) { this.timeline().setState('watching') };
		if (this.isActive()) this.leave();
		if (this.parent()) { this.parent().branches().remove(this) };
		this.model().del(true);
		
		if (this.branch()._parentPlayState) {
			this.parent().timeline().setState(this.branch()._parentPlayState);
		};
	};
	return this;
};

Branch.prototype.load = async function (){
	var self = this;
	if (self.isLocal()) {
		self.stream().sync();
		self._isLoaded = true;
		return Promise.resolve(self);
	};
	
	if (false && !self.model().isLocal()) {
		self._myFork = self.model().branches().filter(function(_0) { return _0.type == 'fork' && _0.uid == self.api().uid(); })[0];
	};
	
	if (self._isLoaded) {
		self.log("already loaded!");
	};
	
	await self.model().fetchStreamBuffer(self.api());
	self.api().log('streamsync',self.timeline().currentOffset());
	self.stream().actionAtOffset(self.timeline().currentOffset());
	
	if (self.timeline().isLive() || true) { // force to the very end
		self.stream().sync();
		self._isLoaded = true;
	} else {
		// why do we really need to delay syncing here?
		// might be because we want to render before really syncing?
		if (true) { // setTimeout(&,100) do
			self.stream().sync(); // why not sync immediately? what?
			self._isLoaded = true;
		};
	};
	
	
	self.api().log('streamsync');
	return self;
};

// used to replace the existing stream with a single snapshot.
// Just for development currently.
Branch.prototype.flattenStream = function (){
	var snap = this.toSnapshot();
	var msg = [MSG.STREAMFLATTEN,this.id(),snap];
	return this.api().send(msg,function() {
		return console.log("returned from flattenStream");
	});
};

Branch.prototype.refreshBranches = function (){
	return this;
	// for branch in
	var coll = this.model().branches();
	var v = coll.check();
	if (this._branchesVersion == v) {
		return;
	};
	
	this._branchesVersion = v;
	
	for (let i = 0, items = iter$(coll), len = items.length, item; i < len; i++) {
		// create / init branches here
		item = items[i];
		if (!this._branches.has(item.id)) {
			// should add them directly no?
			new Branch(this.space(),this,item).load(); // we are loading branches instantly
		};
	};
	return this;
};

Branch.prototype.loadChildBranch = function (item){
	if (!this._branches.has(item.id)) {
		// should add them directly no?
		// log "loadChildBranch",@isLoaded
		return new Branch(this.space(),this,item).load(); // we are loading branches instantly
	} else {
		return Promise.resolve(this._branches.get(item.id));
	};
};

Branch.prototype.widgets = function (){
	return this.space().widgets();
};

Branch.prototype.record = async function (o){
	var offset_;
	if(o === undefined) o = {};
	if (!(this.canRecord())) { return Promise.reject("Not allowed to record") };
	// first make sure we are at the very end of cast
	
	// WARN what if there is an error when recording - should we really trim before we know it is safe?
	// it would help to first setup the microphone to make sure that part works
	await (((typeof (offset_ = o.offset)=='number'||offset_ instanceof Number)) ? this.trimToTimeOffset(o.offset) : Promise.resolve(this));
	this.forceToEnd();
	
	var rec = new Recording(this,o);
	return rec.start();
};

Branch.prototype.trimToTimeOffset = function (timeOffset){
	var action = this.stream().actionAtOffset(timeOffset);
	return this.trimToAction(action,timeOffset);
};


Branch.prototype.trimToAction = function (action,timeOffset,appendTrimEvent){
	var self = this;
	return new Promise(function(resolve,reject) {
		if ((typeof action=='number'||action instanceof Number)) {
			action = self.stream().actionAtIndex(action);
		};
		
		timeOffset || (timeOffset = action.timeOffset());
		
		var dirty = false;
		var addTime = Math.max(timeOffset - action.timeOffset(),0);
		// TODO - should wait for space to successfully sync to action
		self.space().cursor().sync(action);
		self.stream().buffer().trim(action._byteEnd);
		
		var msg = [[MSG.STREAMTRIM,self.id(),action._byteEnd,self.stream().currentSID() || '']];
		
		self.log("trimToTimeOffset",timeOffset,action,msg);
		
		if (appendTrimEvent || addTime) {
			msg.push(addTime || 0,-ACTION.TRIM,[]);
		};
		
		self.api().send(StreamBuffer.encode(msg),function(res) {
			
			let draftData = self.timeline().cues().trimCuesAndAudio(timeOffset);
			self.log("responded from trim",res,draftData);
			// draft:end = timeOffset # Math.min(draft:end,timeOffset)
			self.model().save({draft: self.draft()});
			return resolve(self);
		});
		
		return self;
	});
};

Branch.prototype.toSnapshot = function (o){
	if(o === undefined) o = {};
	var snap = {};
	var event = this.space().cursor().current();
	o.local = true;
	
	if (event.branch() != this) {
		throw "cannot create snapshot for wrong branch",event;
	};
	
	snap.seed = [this.model().id,event.index() || 0,Math.round(this.timeline().currentOffset())];
	snap.spiv = SPIV;
	
	var widgets = this.widgets().map(function(item) {
		if (!(o.exclude && Imba.indexOf(item.TYPE,o.exclude) >= 0)) {
			return item.serialize(o,snap);
		};
	});
	
	snap.widgets = widgets.filter(function(item) { return item; });
	return snap;
};


// try to lock this branch for editing
// will return a promise with details on whether lock has succeeded or not
Branch.prototype.lock = function (cb){
	this.stream().lock();
	this.stream().sync();
	return cb && cb(null,true);
};

Branch.prototype.startEditing = function (){
	var self = this;
	self.lock(function() {
		// console.log "returned from lock!!!",canEdit,canPrepare
		if (self.canPrepare()) {
			return self.setMode('editing');
		};
	});
	return self;
};

Branch.prototype.stopEditing = function (){
	if (!(this.isEditing())) {
		throw "branch is not editing!",this;
	};
	
	// push snapshot
	if (this.isTemplate() && this.head().type() != ACTION.SNAPSHOT) {
		// log 'pushing snapshot since template'
		this.push_(ACTION.SNAPSHOT,[this.toSnapshot()]);
	};
	
	this.setMode(this.isRecording() ? 'paused' : 'watching');
	return this;
};

Branch.prototype.stopRecording = function (){
	if (this.recording()) {
		return this.recording().stop();
	};
};

// triggered when an event
// def startForking atAction, firstAction
Branch.prototype.myFork = function (){
	// Not correct for challenge / response?
	var self = this;
	if (self.isLab() && self.isMine()) { return self };
	return self._myFork || (self._myFork = self.model().branches().filter(function(_0) { return _0.type == 'fork' && _0.uid == self.api().uid(); })[0]);
};

Branch.prototype.upsertResponse = async function (){
	if (this.myFork()) {
		return Promise.resolve(this.myFork());
	};
	
	if (this.isLab() && this.isMine()) {
		return Promise.resolve(this);
	};
	
	if (!(this.type() == 'challenge' || this.type() == 'lab')) {
		return Promise.resolve(null);
	};
	
	if (this.space().trunk().model().uid == this.api().uid()) {
		return Promise.resolve(null);
	};
	
	var snap = this.toSnapshot();
	var resp = await this.api().rpc('castRespond',[this.space().trunk().id(),snap],{models: true});
	
	this._myFork = resp;
	// console.log "returned from castRespond",resp
	return resp;
};

Branch.prototype.startAnnotating = function (){
	if (!(this.canAnnotate())) { return };
	this._frozenDraft = JSON.stringify(this.draft());
	this.log('startAnnotating');
	this.timeline().setIsAnnotating(true);
	return this;
};

Branch.prototype.stopAnnotating = function (cues){
	console.log("stopAnnotating",cues);
	
	if (JSON.stringify(this.draft()) != this._frozenDraft) {
		this.save({draft: this._draft});
	};
	
	this.timeline().setIsAnnotating(false);
	return this;
};

Branch.prototype.save = async function (updates){ // full = false
	if(updates === undefined) updates = {};
	var wasLocal = this.model().isLocal();
	
	await this.api().tryLogin();
	
	this.draft().end = this.stream().duration(); // really=
	
	var upd = {
		draft: this._draft
	};
	
	for (let value, i = 0, keys = Object.keys(updates), l = keys.length, key; i < l; i++){
		key = keys[i];value = updates[key];upd[key] = value;
	};
	
	if (wasLocal || !this.model().uid) {
		upd.uid || (upd.uid = this.api().uid());
	};
	
	if (!this.api().uid()) {
		throw "not allowed to save unless logged in";
	};
	
	if (!this.model().uid) {
		upd.uid = this.api().uid();
	};
	
	await this.model().save(upd);
	
	// because our branch is no longer local we should be able to sync
	await this.syncer().persist(true);
	
	return this;
};

Branch.prototype.publish = async function (o){
	if(o === undefined) o = {};
	await this.save(true);
	
	var integrity = await this.ensureIntegrity();
	
	if (len$(integrity.issues)) {
		console.log("HAS ISSUES!!!",integrity);
		return Promise.resolve({error: "issues with publish!"});
	};
	
	o.end = this.stream().duration();
	await this.save(true);
	
	var pub = await this.api().rpc('publish',[this.id(),o]);
	await this.model().fetch(); // hard refresh
	return this;
};

Branch.prototype.__uid = function (){
	return 0;
};

function Trunk(){ return Branch.apply(this,arguments) };

Imba.subclass(Trunk,Branch);
exports.Trunk = Trunk; // export class 
Trunk.prototype.seed = function (){
	return null;
};
