function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
// TODO move Packet from protocol here
var msgpack = require('msgpack-lite');
var Bufferish = exports.Bufferish = msgpack.Decoder.prototype.bufferish;

var Resource = require('../../store/Resource').Resource;

var CurrentScope = null;

var pack = (function($mod$){
	$mod$.concat = function (buffers){
		"use strict";
		var self = this || $mod$;
		return Bufferish.concat(buffers);
	};
	
	$mod$.encode = function (){
		"use strict";
		var self = this || $mod$;
		var $0 = arguments, i = $0.length;
		var chunks = new Array(i>0 ? i : 0);
		while(i>0) chunks[i-1] = $0[--i];
		var encoder = new (msgpack.Encoder)({});
		for (let i = 0, items = iter$(chunks), len = items.length; i < len; i++) {
			encoder.write(items[i]);
		};
		return encoder.read();
	};
	
	$mod$.codec = function (){
		"use strict";
		var self = this || $mod$;
		if (self._codec) { return self._codec };
		self._codec = msgpack.createCodec();
		
		self._codec.addExtPacker(0x1E,{name: 'Resource'},function(item) {
			if (false) {};
			
			// if we have access to the channel we pack to we can
			// start caching versions of ids to not include previously
			// synced data
			let plain = item.serialize(CurrentScope);
			return msgpack.encode(plain);
		});
		
		self._codec.addExtUnpacker(0x1E,function(buf) {
			var db = CurrentScope && CurrentScope.db();
			var obj = msgpack.decode(buf);
			// console.log "decoding Resource",obj
			if (true) {
				// be strict in node - never implicitly read objects
				return db.get(obj.id || obj);
			};
			
			return ((typeof obj=='string'||obj instanceof String)) ? db.get(obj) : db.read(obj);
		});
		
		var packers = self._codec.extPackers;
		var packer = packers.Resource;
		
		// TODO should rather fork and fix msgpack-lite
		for (let i = 0, items = ['Entity','Peer','Scrim','Message','Note','Repo','Course','User','Org','Hub','Topic','Link'], len = items.length; i < len; i++) {
			packers[items[i]] = packers.Resource;
		};
		
		return self._codec;
	};
	
	$mod$.isBinary = function (value){
		"use strict";
		var self = this || $mod$;
		if (true && (value instanceof Buffer)) {
			return true;
		};
		
		if ((value instanceof ArrayBuffer) || (value instanceof Uint8Array)) {
			return true;
		};
		
		return false;
	};
	return $mod$;
})({})
exports.pack = pack;

function Packet(data,channel){
	this._channel = channel;
	this._ref = 0;
	this._data = true && Buffer.from(data);
	
	CurrentScope = channel.api();
	var decoder = new (msgpack.Decoder)({codec: pack.codec()});
	decoder.write(this._data);
	this._params = decoder.fetch();
	
	if ((typeof this._params=='number'||this._params instanceof Number)) {
		let offset = decoder.offset;
		this._ref = this._params;
		this._data = (false ? true : this._data.slice(offset));
		this._params = decoder.fetch();
		this._offset = decoder.offset - offset;
	} else {
		this._offset = decoder.offset;
	};
	
	this.CODE = this[0] = this._params[0];
	this[1] = this._params[1];
	this[2] = this._params[2];
	this[3] = this._params[3];
	this[4] = this._params[4];
	this;
};

exports.Packet = Packet; // export class 
Packet.prototype.params = function(v){ return this._params; }
Packet.prototype.setParams = function(v){ this._params = v; return this; };
Packet.prototype.channel = function(v){ return this._channel; }
Packet.prototype.setChannel = function(v){ this._channel = v; return this; };
Packet.prototype.data = function(v){ return this._data; }
Packet.prototype.setData = function(v){ this._data = v; return this; };
Packet.prototype.ref = function(v){ return this._ref; }
Packet.prototype.setRef = function(v){ this._ref = v; return this; };

// TODO add method with named params for actually
// assembling a packet, including potential payload

Packet.decode = function (data,scope){
	CurrentScope || (CurrentScope = scope);
	return msgpack.decode(data,{codec: pack.codec()});
};

Packet.serialize = function (data,o){
	var ref_;
	if(o === undefined) o = {};
	if (pack.isBinary(data)) {
		// if we serialize with reference - add reference as number before
		if (o.ref) { data = pack.concat([pack.encode(o.ref),data]) };
		return data;
	};
	
	// if the last value is a buffer - it should be included as payload instead
	if (data instanceof Array) {
		data = data.slice();
		if (pack.isBinary(data[data.length - 1])) {
			o.payload = data.pop();
		};
	};
	
	CurrentScope = o.scope;
	
	let packet;
	
	try {
		packet = [msgpack.encode(data,{codec: pack.codec()})];
	} catch (e) {
		console.log("failed packing",data,e);
		if (o.scope && o.scope.serialize) {
			data = o.scope.serialize(data);
		};
		packet = [msgpack.encode(data)];
	};
	
	if (o.payload) {
		packet.push(o.payload);
	};
	
	if (o.ref && (typeof (ref_ = o.ref)=='number'||ref_ instanceof Number)) {
		packet.unshift(pack.encode(o.ref));
	};
	
	return (packet.length > 1) ? pack.concat(packet) : packet[0];
};

Packet.deserialize = function (data,channel,o){
	if(o === undefined) o = {};
	CurrentScope = o.scope;
	return new this(data,channel);
};

Packet.prototype.payloadSize = function (){
	return this._data.byteLength - this._offset;
};

Packet.prototype.peer = function (){
	return this.channel().peer();
};

Packet.prototype.retain = function (){
	// packets are inited with data from an arraybuffer
	// that is reused across requests. If we do anything
	// asynchronous with the data, we need to retain it
	if (true) {
		this._data = Buffer.from(this._data);
		this._payload = null;
	};
	return this;
};

Packet.prototype.payload = function (){
	if (true) {
		return this._payload || (this._payload = this._data.slice(this._offset));
	};
};

Packet.prototype.resolve = function (msg){
	this.channel().respond(this._ref,msg);
	return this;
};

Packet.prototype.reply = function (msg){
	return this.resolve(msg);
};

Packet.prototype.pid = function (){
	return this.peer().id;
};
