var Imba = require('imba');
function Delay(target,path){
	var self = this;
	self._target = target;
	self._path = path;
	self._time = 0;
	self._timeout = null;
	self._trigger = function() { return self.trigger(); };
	self;
};

exports.Delay = Delay; // export class 
Delay.prototype.data = function(v){ return this._data; }
Delay.prototype.setData = function(v){ this._data = v; return this; };

// def self.delay target, time, func
// FINISH
Delay.delay = function (owner,name,time,blk){
	var store = owner.__delays_ || (owner.__delays_ = {});
	var delay = store[name] || (store[name] = new Delay(owner,name));
	(time == -1) ? delay.cancel() : delay.delay(time);
	return delay;
};

Delay.prototype.async = function (name){
	var self = this;
	self._asyncTriggers || (self._asyncTriggers = {});
	var fn = self._asyncTriggers[name] || (self._asyncTriggers[name] = function() { return self[name](); });
	Imba.TICKER.add(fn);
	return self;
};


Delay.prototype.delay = function (ms){
	let at = Date.now() + ms;
	
	if (this._timeout && (at >= this._time)) {
		// just set new time -- when the
		// current timeout is triggered,
		// it will reschedule
		this._time = at;
	} else {
		this._time = at;
		if (this._timeout) { clearTimeout(this._timeout) };
		this._timeout = setTimeout(this._trigger,ms);
	};
	return this;
};

// TODO Add method that extends current delay
// instead of scheduling at current time + ms 

Delay.prototype.cancel = function (){
	clearTimeout(this._timeout);
	this._timeout = null;
	this._time = null;
	return this;
};

Delay.prototype.trigger = function (){
	clearTimeout(this._timeout);
	this._timeout = null;
	
	if (this._time) {
		let ms = this._time - Date.now();
		// we do expect the timeout to be
		// correct down to a few ms
		if (ms > 3) { return this.delay(ms) };
	};
	
	if (this._target instanceof Function) {
		this._target(this);
	} else {
		this._target[this._path](this);
	};
	
	return this;
};
