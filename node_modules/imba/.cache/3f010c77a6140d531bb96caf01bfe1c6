function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var MSG = require('../protocol').MSG;
var msgpack = require('msgpack-lite');

var StreamBuffer = require('./StreamBuffer').StreamBuffer;

/*

Keeps track of checking whether a StreamBuffer has new data,
and then syncing that data to a receiver. Currently, the receiver
will always be a websocket - which means that the StreamSyncer
is currenlty only syncing data to the server.

In the future, an agent will most likely create syncers for each
watching client to push data through DataChannels (WebRTC).

It is also intended to be configurable. Ie. if no other sockets
are connected while you record the syncer should only sync every
5 seconds, but switch over to instant syncing (every time there is
a new event) whenever livestreaming is needed.

STATES
======

READY

CONFLICT

RECOVERING

*/


var STATE = {
	READY: 0,
	BUSY: 1,
	CONFLICT: 2,
	RECOVERING: 3
};

function StreamSyncer(stream,channel){
	// should connect directly to a streamBuffer no?
	var self = this;
	self._stream = stream;
	self._buffer = stream.buffer();
	self._channel = channel;
	self._counter = 0;
	self._lastOffset = 0;
	self._remoteOffset = 0;
	self._timeout = null;
	self._requests = [];
	self._state = STATE.READY;
	
	self._tick = function() {
		self._timeout = null;
		return self.sync();
	};
	
	// FIXME must dispose with space
	self._callback = function(res,req) { return self.onresponse(res,req); };
	self._ontrim = function(e) { return self.ontrim(e); };
	self._buffer.on('trim',self._ontrim);
	self;
};

exports.StreamSyncer = StreamSyncer; // export class 
StreamSyncer.prototype.stream = function(v){ return this._stream; }
StreamSyncer.prototype.setStream = function(v){ this._stream = v; return this; };
StreamSyncer.prototype.channel = function(v){ return this._channel; }
StreamSyncer.prototype.setChannel = function(v){ this._channel = v; return this; };
StreamSyncer.prototype.byteOffset = function(v){ return this._byteOffset; }
StreamSyncer.prototype.setByteOffset = function(v){ this._byteOffset = v; return this; };
StreamSyncer.prototype.__state = {watch: 'stateDidSet',name: 'state'};
StreamSyncer.prototype.state = function(v){ return this._state; }
StreamSyncer.prototype.setState = function(v){
	var a = this.state();
	if(v != a) { this._state = v; }
	if(v != a) { this.stateDidSet && this.stateDidSet(v,a,this.__state) }
	return this;
};

StreamSyncer.prototype.isRecovering = function (){
	return this.state() == STATE.RECOVERING;
};

StreamSyncer.prototype.branch = function (){
	return this.stream().owner();
};

StreamSyncer.prototype.latency = function (){
	var now = Date.now();
	var last = this._lastConfirmed;
	var next = this._requests[this._requests.indexOf(last) + 1];
	
	var lastLatency = last ? last.ms : 0;
	var nextLatency = next ? ((now - next.ts)) : 0;
	
	return Math.max(lastLatency,nextLatency);
};

StreamSyncer.prototype.confirm = function (next){
	this._remoteOffset = this._lastOffset = next;
	return this;
};

StreamSyncer.prototype.onresponse = function (res,req){
	// console.log 'onresponse',res,req
	// if we have already got response for later packet
	// we should not care
	this._lastResponse = res;
	
	switch (res.CODE) {
		case MSG.OK: {
			// pkg[3] = Date.now - pkg[2]
			this._lastConfirmed = req;
			this._remoteOffset = req.byteEnd;
			
			if (this.isRecovering()) {
				this.setState(STATE.READY);
			};
			break;
		}
		case MSG.UNAUTHORIZED: {
			console.warn("got message from server that we are unauthorized!");
			// If we are wrongfully trying to push to stream - force sync back to
			// last verified offset (local trim - and resync from server)
			this;
			break;
		}
		case MSG.ERR_OUT_OF_RANGE: {
			console.warn("server said we are out of range!",this.isRecovering());
			
			if (!(this.isRecovering())) {
				// set state to recovering and reset to the last
				// offset we know that the server has confirmed
				
				// if the server returns another out of range
				// something more serious must be going on
				this.setState(STATE.RECOVERING);
				this._lastOffset = this._remoteOffset;
				this.sync();
			};
			this;
			break;
		}
	};
	return this;
};

StreamSyncer.prototype.ontrim = function (offset){
	this._stream.api().log('syncer','ontrim',offset,this._lastOffset,this._remoteOffset);
	this._lastOffset = Math.min(this._lastOffset,offset);
	this._remoteOffset = Math.min(this._buffer._verifiedOffset,offset);
	this._lastConfirmed = null;
	this._requests = [];
	return this;
};

StreamSyncer.prototype.getPayload = function (){
	// let realFrom = channel.get(@buffer.id) or 0
	let from = this._lastOffset;
	let to = len$(this._buffer) - 1;
	
	if (this._buffer._verifiedOffset > this._lastOffset) {
		this._stream.api().log('syncer',"buffer already has a confirmed remote offset",this._lastOffset,this._buffer._verifiedOffset);
		from = this._lastOffset = this._buffer._verifiedOffset;
	};
	
	if (from >= to) {
		return;
	};
	
	let key = this.stream().id();
	let pars = msgpack.encode([MSG.STREAMAPPEND,key,from]);
	var chunk = this._buffer.slice(from);
	var payload = StreamBuffer.concat([pars,chunk]);
	return payload;
};

StreamSyncer.prototype.sync = function (force){
	if(force === undefined) force = false;
	if (this.branch().isLocal()) {
		return;
	};
	
	if (!force && this.branch().recording() && !this.branch().recording().live()) {
		return;
	};
	
	var pkg = this.getPayload();
	var byteEnd = len$(this._buffer);
	
	if (pkg) {
		this._lastOffset = byteEnd;
		var req = {byteEnd: byteEnd,handler: this._callback};
		this._requests.push(req);
		return this.channel().send(pkg,req);
	};
};

StreamSyncer.prototype.schedule = function (){
	if (this._timeout) { return };
	return this._timeout = setTimeout(this._tick,0);
};

StreamSyncer.prototype.persist = function (){
	return this.sync(true);
};

StreamSyncer.prototype.dispose = function (){
	this._buffer.un('trim',this._ontrim);
	return this;
};
