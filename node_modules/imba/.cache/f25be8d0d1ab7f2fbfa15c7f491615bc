var Imba = require('imba'), _2 = Imba.createTagCache, _1 = Imba.createElement;
var protocol$ = require('../protocol'), POINTERMASK = protocol$.POINTERMASK, LAYOUTMASK = protocol$.LAYOUTMASK, ACTION = protocol$.ACTION;

var svg = '<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">\n<polygon points="35 35 29.2102052 35.6469727 24.9999029 39 24.9987284 25" fill="#8BB2FF" fill-rule="evenodd"/>\n</svg>';

var PointerView = Imba.defineTag('PointerView', function(tag){
	
	tag.prototype.keyframe = function(v){ return this._keyframe; }
	tag.prototype.setKeyframe = function(v){ this._keyframe = v; return this; };
	tag.prototype.__mask = {watch: 'maskDidSet',name: 'mask'};
	tag.prototype.mask = function(v){ return this._mask; }
	tag.prototype.setMask = function(v){
		var a = this.mask();
		if(v != a) { this._mask = v; }
		if(v != a) { this.maskDidSet && this.maskDidSet(v,a,this.__mask) }
		return this;
	};
	tag.prototype.__hidden = {watch: 'hiddenDidSet',name: 'hidden'};
	tag.prototype.hidden = function(v){ return this._hidden; }
	tag.prototype.setHidden = function(v){
		var a = this.hidden();
		if(v != a) { this._hidden = v; }
		if(v != a) { this.hiddenDidSet && this.hiddenDidSet(v,a,this.__hidden) }
		return this;
	};
	tag.prototype.__hover = {watch: 'hoverDidSet',name: 'hover'};
	tag.prototype.hover = function(v){ return this._hover; }
	tag.prototype.setHover = function(v){
		var a = this.hover();
		if(v != a) { this._hover = v; }
		if(v != a) { this.hoverDidSet && this.hoverDidSet(v,a,this.__hover) }
		return this;
	};
	tag.prototype.__target = {watch: 'targetDidSet',name: 'target'};
	tag.prototype.target = function(v){ return this._target; }
	tag.prototype.setTarget = function(v){
		var a = this.target();
		if(v != a) { this._target = v; }
		if(v != a) { this.targetDidSet && this.targetDidSet(v,a,this.__target) }
		return this;
	};
	
	tag.prototype.space = function (){
		return this.data();
	};
	
	tag.prototype.build = function (){
		var $ = ($_ = this.$).$build$ || ($_.$build$ = _2(this)), t0;
		this.$open('build0').setChildren(
			t0 = $[0] || (t0=_1('div',$,0,this)).flag('pointer-body').setContent(
				this._svg = this._svg||_1('div',t0).flag('svg').flag('Vector').flag('pointer-shape')
			,2)
		,2).synced();
		
		this._svg.dom().innerHTML = svg;
		this._sx = this._sy = 1;
		return this;
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self.space().on('resized',function() {
			self._frame = null;
			return self.render();
		});
		// schedule(raf: yes)
		self.space().on('ticked',function(offset) {
			return self.render(offset);
		});
		return self;
	};
	
	// def unmount
	// 	unschedule
	
	tag.prototype.render = function (){
		var hover_;
		var frame = this.keyframe();
		var prev = this._frame;
		// no need to check again until invalidated?
		
		if (!frame || this.space().recording() || frame._branch != this.space().branch() || this.space().isEditing()) {
			this.setHidden(true);
			return;
		};
		
		this.setHidden(false);
		
		// should have a more consistent concept for invalidating
		if (this.space().counter('locals') != this._v) {
			this._v = this.space().counter('locals');
			prev = null;
		};
		
		var x = frame.x();
		var y = frame.y();
		let currOffset = this.space().timeline().currentOffset();
		// check if the target layout is different?
		if (frame == prev) {
			let next = frame.nextFrame();
			
			if (next && currOffset != this._currOffset) {
				this._currOffset = currOffset;
				let dist = next.offset() - frame.offset();
				let prog = Math.max(Math.min((currOffset - frame.offset()) / dist,1),0);
				if (dist < 140) {
					x = x + (next.x() - x) * prog;
					y = y + (next.y() - y) * prog;
					this.drawTarget(x,y);
				} else {
					return this.draw();
				};
			} else {
				return this.draw();
			};
		};
		
		this._frame = frame;
		
		var pos;
		var over;
		
		if (prev && prev.sref() && prev.sref() == frame.sref()) {
			over = this._target;
		};
		
		over || (over = this.space().view().lookup(frame.sref()));
		
		// legacy
		if (!over && (typeof (hover_ = frame.hover())=='number'||hover_ instanceof Number)) {
			over = this.space().__lookup(frame.hover());
		};
		
		this.flag('local',!!frame.LOCAL);
		
		var rel = over || this._target; // no no!?
		
		var remRect = frame ? frame.targetLayout() : null;
		var locRect = over ? this.space().view().layoutForNode(over) : null;
		
		if (rel && rel.posToScreen) {
			pos = rel.posToScreen(x,y);
		};
		
		if (!pos && over && remRect && locRect) {
			// let x = frame.x
			// let y = frame.y
			let lt = locRect[0];
			let ll = locRect[1];
			let lw = locRect[2];
			let lh = locRect[3];
			
			let rt = remRect[0];
			let rl = remRect[1];
			let rw = remRect[2];
			let rh = remRect[3];
			
			let dt = lt - rt;
			let dl = ll - rl;
			let dw = lw - rw;
			let dh = lh - rh;
			let rMask = remRect[4];
			
			// adjust for legacy bug where we included layouts
			//
			if (rMask == null) {
				dt += 54;
				rMask = 0;
			};
			// hardcode issue from before
			// console.log "converting poitner",remRect,locRect
			// if size is the same - just morph position
			
			if (dw == 0 && dh == 0) {
				// if dl == 0 and dt == -54
				// 	# console.log "correct legacy pointer issue",remRect,locRect,frame.x,frame.y
				// 	dt = 0
				pos = [x + dl,y + dt];
			} else if (rMask & LAYOUTMASK.SCALED) {
				// find the relative distance from center remote and locally
				let remRelX = (x - (rl + rw * 0.5)) / rw;
				let remRelY = (y - (rt + rh * 0.5)) / rh;
				
				// convert x and y
				x = (ll + lw * 0.5) + (remRelX) * lw;
				y = (lt + lh * 0.5) + (remRelY) * lh;
				pos = [x,y];
			};
			// possibly convert some relative positioning?
		};
		
		if (pos) { this.drawTarget(pos[0],pos[1],over) };
		this.flag('out-of-bounds',!over || !pos);
		// log "render",!!over,!!rel,pos,frame.sref, prev and prev.sref
		this.setMask(frame.flags());
		
		if (over && this._target != over) {
			this.setTarget(over);
			// console.log "changed target"
			this._sx = 0.2;
			this._sy = 0.2;
		};
		this.draw();
		return this;
	};
	
	tag.prototype.draw = function (){
		var dx = this._x1 - this._x;
		var dy = this._y1 - this._y;
		
		if (dx == 0 && dy == 0) {
			return;
		};
		
		if (Math.abs(dx) < 5 && Math.abs(dy) < 5) {
			this._x = this._x1;
			this._y = this._y1;
			this._sx = 1;
			this._sy = 1;
		} else {
			this._x = this._x + dx * this._sx;
			this._y = this._y + dy * this._sy;
			if (this._sx < 0.6) { this._sx += 0.03 };
			if (this._sy < 0.6) { this._sy += 0.03 };
		};
		
		this._dom.style.transform = ("translate3d(" + (this._x) + "px," + (this._y) + "px,0px)");
		return;
	};
	
	tag.prototype.drawTarget = function (x,y){
		this._x1 = x;
		this._y1 = y;
		this._x || (this._x = x);
		this._y || (this._y = y);
		return;
	};
	
	tag.prototype.drawAt = function (x,y){
		return this._dom.style.transform = ("translate3d(" + (this._x = x) + "px," + (this._y = y) + "px,0px)");
	};
	
	tag.prototype.targetDidSet = function (curr,prev){
		// log "targetDidSet",curr,prev
		var $1, $2, $3, $4;
		if (prev) {
			($1 = prev) && $1.unflag  &&  $1.unflag('agent-over');
			($2 = prev) && $2.setHasPointerFocus  &&  $2.setHasPointerFocus(false);
		};
		
		if (curr) {
			($3 = curr) && $3.flag  &&  $3.flag('agent-over');
			($4 = curr) && $4.setHasPointerFocus  &&  $4.setHasPointerFocus(true);
		};
		return this;
	};
	
	tag.prototype.hiddenDidSet = function (bool){
		var target_;
		this.flag('hidden',!!bool);
		if (this.target()) { return (target_ = this.target()) && target_.flag  &&  target_.flag('agent-over',!bool) };
		// stop highlighting target as well?
	};
	
	tag.prototype.maskDidSet = function (mask){
		return this.flag('left-button-pressed',mask & POINTERMASK.LEFT_BUTTON);
	};
	
	
	// Where does this belong?
	tag.prototype.retargetStream = function (){
		let stream = this.space().trunk().stream();
		let pointers = stream.actionsOfType(ACTION.POINTER_UPDATE);
		
		// Let's say we have updates with these targets:
		// [-7, -7, -7, -9, -9, -9, -9, -9, -7, -7]
		//           ^ idx               ^ ret
		//
		// The following function takes an `idx` to the update
		// right before the target changes and will check if
		// it is right to change the target. It then returns
		// the index of where the next change happens
		let patchAt = function(idx) {
			var $1;
			let startIdx = idx;
			let before = pointers[idx];
			let current = pointers[idx + 1];
			// console.log("Patching at idx={idx} offset={current.timeOffset} between {before.sref} and {current.sref}")
			let after;
			
			// We're using a cost model where we say that:
			// - Every time the target changes it costs alpha
			// - Every millisecond where we are retargeting costs beta
			
			// In the example above we then have two choice:
			// - We can keep the current targets and pay alpha*2 since
			//   the target changes once to -9 and then to -7
			// - We can change all the -9 to -7 and pay beta*time
			
			// We will then choose whatever choice is cheapest
			let alpha = 8000;
			let beta = 10;
			
			while (idx + 1 < pointers.length){
				let next = pointers[idx + 1];
				if (next.sref() == current.sref()) {
					// continue looking for the change
					idx++;
					current = next;
				} else {
					after = next;
					break;
				};
			};
			
			let time = current.timeOffset() - before.timeOffset();
			
			// Cost for doing nothing
			let keepCost = alpha * 2;
			
			// Cost for changing all the srefs
			let changeCost = beta * time;
			if (($1 = after) && $1.target  &&  $1.target() != before.target()) {
				changeCost += alpha;
			};
			
			// console.log("time={time} keep={keepCost} change={changeCost}")
			
			if (changeCost < keepCost) {
				let patchIdx = startIdx + 1;
				while (patchIdx <= idx){
					pointers[patchIdx].setSref(before.sref());
					patchIdx++;
				};
			};
			return idx;
		};
		
		
		// Find the first index where the type changes
		let patchIdx = 0;
		while (patchIdx + 1 < pointers.length){
			if (pointers[patchIdx].sref() != pointers[patchIdx + 1].sref()) {
				break;
			};
			patchIdx++;
		};
		
		// And the patch everything
		var res = [];while (patchIdx + 1 < pointers.length){
			res.push((patchIdx = patchAt(patchIdx)));
		};return res;
	};
})
exports.PointerView = PointerView;
