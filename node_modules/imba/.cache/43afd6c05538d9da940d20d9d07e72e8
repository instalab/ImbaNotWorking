function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');

var msgpack = require('msgpack-lite');
var Bufferish = msgpack.Decoder.prototype.bufferish;
var Decoder = new (msgpack.Decoder)({});

function StreamMissingRangeError(start,end){
	this.start = start;
	this.end = end;
	this;
};
Imba.subclass(StreamMissingRangeError,Error);
exports.StreamMissingRangeError = StreamMissingRangeError; // export class 


function StreamFragments(buffer){
	this._buffer = buffer;
	this._offsets = {};
	this._chunks = [];
	this._holes = null;
	this;
};

exports.StreamFragments = StreamFragments; // export class 
StreamFragments.prototype.add = function (chunk,offset){
	var len = chunk.length;
	
	if (!this._last) {
		this._chunks.push(this._last = [chunk,offset,offset + len]);
		return new StreamMissingRangeError(this._buffer.size(),offset - 1);
	};
	
	let currOffset = this._last[1];
	let nextOffset = this._last[2];
	// ensure that chunks are always sorted by offset
	// we can just append to the previous chunk here
	// make sure that we deal with errors
	
	
	if (offset == nextOffset) {
		// we can happily append!
		this._last[0] = Bufferish.concat([this._last[0],chunk]);
		this._last[2] += len;
		return true;
	} else if (offset > nextOffset) {
		// there is now another hole!
		this._chunks.push(this._last = [chunk,offset,offset + len]);
		return new StreamMissingRangeError(nextOffset,offset - 1);
	} else if (offset == currOffset) {
		console.log("already received this fragment",offset,len,this._last);
		// we're re-receiving the same parts. Nothing to see here
		if ((offset + len) > nextOffset) {
			console.log("got a longer fragment now");
		};
		return true;
	} else {
		console.log("fragment cannot even be handled");
		return true;
	};
};

StreamFragments.prototype.pull = function (offset){
	var first = this._chunks[0];
	if (first) {
		// console.log "try to pull",offset,first[1]
		if (first[1] == offset) {
			return this._chunks.shift()[0];
		} else if (first[2] <= offset) {
			//  console.log "we already have this"
			this._chunks.shift();
			return this.pull(offset);
		};
		// what if we have already filled? parts?
	};
	return null;
};


StreamFragments.prototype.len = function (){
	return this._chunks.length;
};


/*

Represents the raw binary buffer for a cast.
Has no understanding of the encoded data, but
has helper methods for encoding/decoding to/from
msgpack.

When adding chunks to the buffer at wrong offsets
it will also create and store these fragments, while
exposing details about missing ranges etc.

*/

function StreamBuffer(buffer,model){
	this._model = model;
	this._decoder = new (msgpack.Decoder)({});
	this._decoder.buffer = this._buffer = (buffer || null); // or msgpack.encode(protocol))
	this._readyState = 0;
	this._fragments = new StreamFragments(this);
	this._version = 0;
	this._size = 0;
	this._verifiedOffset = 0;
	this;
};

exports.StreamBuffer = StreamBuffer; // export class 
StreamBuffer.OK = 3;
StreamBuffer.FRAGMENTED = 4;

StreamBuffer.decode = function (binary,stats){
	if(stats === undefined) stats = true;
	var decoder = new (msgpack.Decoder)({});
	decoder.write(binary);
	var items = [];
	while (decoder.offset < binary.byteLength){
		
		let start = decoder.offset;
		let item = decoder.fetch();
		
		if (stats && (item instanceof Array)) {
			item.START = start;
			item.END = decoder.offset;
		};
		
		items.push(item);
	};
	
	return items;
};

StreamBuffer.encode = function (chunks,protocol){
	if(protocol === undefined) protocol = 0;
	var encoder = new (msgpack.Encoder)({});
	// if protocol and protocol isa Number
	//	encoder.write(protocol)
	for (let i = 0, items = iter$(chunks), len = items.length; i < len; i++) {
		encoder.write(items[i]);
	};
	var binary = encoder.read();
	binary.PROTOCOL = protocol;
	return binary;
};

StreamBuffer.concat = function (buffers){
	return Bufferish.concat(buffers);
};

StreamBuffer.alloc = function (size){
	return Bufferish.alloc(size);
};

StreamBuffer.prototype.buffer = function(v){ return this._buffer; }
StreamBuffer.prototype.setBuffer = function(v){ this._buffer = v; return this; };
StreamBuffer.prototype.readyState = function(v){ return this._readyState; }
StreamBuffer.prototype.setReadyState = function(v){ this._readyState = v; return this; };

StreamBuffer.prototype.state = function (){
	if (len$(this._fragments)) {
		return 'fragmented';
	} else {
		return 'synced';
	};
};

StreamBuffer.prototype.id = function (){
	return this._model.id + ":stream";
};

StreamBuffer.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
StreamBuffer.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
StreamBuffer.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

// same as add - but used when writing to buffer locally
StreamBuffer.prototype.write = function (chunk,offset){
	if(offset === undefined) offset = 0;
	return this;
};

StreamBuffer.prototype.resize = function (size){
	let prev = this._buffer;
	if (this._buffer.length < size) {
		this._buffer = Bufferish.alloc(size);
		this._buffer.set(prev,0);
	};
	return this._buffer;
};

StreamBuffer.prototype.set = function (chunk,offset){
	let chunkSize = chunk.length;
	if ((offset + chunkSize) >= this._buffer.length) {
		// console.log "need to resize buffer to hold this!"
		// add 10kb every time
		this.resize(offset + chunkSize + 10000);
	};
	this._buffer.set(chunk,offset);
	this._size = offset + chunkSize;
	return this;
};

StreamBuffer.prototype.add = function (chunk,offset){
	if(offset === undefined) offset = 0;
	if (chunk instanceof Array) { // what if it is a struct?
		chunk = msgpack.encode(chunk);
	};
	
	var chunkLen = chunk.length;
	
	if (this._buffer) {
		var end = this._size; // or @buffer:byteLength
		
		// we just have the existing protocol
		if (offset == 0 && end == 1) {
			// console.log "replace buffer from start"
			// TODO check if protocol matches
			this._buffer = chunk;
			this._size = chunkLen;
		} else if (offset == end) {
			// everything is okay
			this.set(chunk,offset);
			// @buffer = Bufferish.concat([@buffer,chunk])
		} else if (offset < end) {
			//  we already  have this whole chunk
			if (end >= (offset + chunkLen)) {
				return true;
			};
			
			let k = offset;
			while (k++ < (end - 1)){
				if (this._buffer[k] != chunk[k - offset]) {
					console.warn("the buffer is incorrect!!",offset,k,end,this,chunk);
					// this is a critical states
					return false;
				};
			};
			
			// now just add the last part
			// console.log "add remaining part of the chunk",k,end
			return this.add(chunk.subarray(k - offset),end);
		} else {
			// console.warn "cannot append to buffer",chunk,offset,self
			// what if we already have this fragment?
			return this._fragments.add(chunk,offset);
		};
	} else if (offset == 0) {
		// should read protocol here already?
		this._buffer = chunk;
		this._size = chunkLen;
	} else {
		return this._fragments.add(chunk,offset);
		//  console.warn "cannot append to buffer",chunk,offset,self
		//  return false
	};
	this._decoder.buffer = this._buffer;
	this.emit('add',this);
	this.repair();
	return true;
};

StreamBuffer.prototype.repair = function (){
	var end = this._size;
	var chunk = this._fragments.pull(end);
	if (chunk) {
		// console.log "successfully repairing",end
		return this.add(chunk,end);
	};
};

StreamBuffer.prototype.len = function (){
	return this.size();
};

StreamBuffer.prototype.size = function (){
	return this._size;
};

StreamBuffer.prototype.slice = function (start,end){
	return end ? this._buffer.slice(start,end) : this._buffer.slice(start,this._size);
};

StreamBuffer.prototype.trim = function (end){
	if (len$(this) > end) {
		// should just change the size param and let the buffer overwrite 
		this._buffer = this._buffer.slice(0,end);
		this._size = end;
		this._fragments = new StreamFragments(this);
		this._verifiedOffset = Math.min(this._verifiedOffset,end);
		this._version++;
		this.emit('trim',end,this);
	};
	return this;
};

StreamBuffer.prototype.toJSON = function (){
	var raw = StreamBuffer.decode(this._buffer,false);
	return raw;
};
