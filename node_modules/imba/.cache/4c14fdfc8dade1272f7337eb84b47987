function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');
var Resource$ = require('../store/Resource'), MASK = Resource$.MASK, ACCESS = Resource$.ACCESS;

var StreamBuffer = require('../scrimba/core/StreamBuffer').StreamBuffer;

var protocol$ = require('../scrimba/protocol'), MSG = protocol$.MSG, ROLES = protocol$.ROLES, ROLEFLAGS = protocol$.ROLEFLAGS, PERMISSIONS = protocol$.PERMISSIONS;
var Model = require('./Model').Model;
var Set = require('../store/collection').Set;

// group: eg
// org: eo
// scrim: es
// course: ec
// user: eu
// note: en
// repo: er
// issue: ei
// topic: et

var LetterToType = {
	g: 'group',
	o: 'org',
	u: 'user',
	i: 'issue',
	n: 'note',
	c: 'course',
	s: 'scrim'
};

var Categories = {
	HUB: ['o','g','h']
};

var Prefix = {
	User: {u: 1},
	Org: {o: 1},
	Hub: {u: 1,o: 1},
	Group: {o: 1,r: 1,u: 1},
	Project: {r: 1,p: 1},
	Scrim: {s: 1},
	Note: {n: 1,i: 1}
};

function Entity(data,store){
	this._children = new Set([]);
	data.roles || (data.roles = {});
	data.data || (data.data = {});
	Entity.prototype.__super__.constructor.apply(this,arguments);
	this;
};

Imba.subclass(Entity,Model);
exports.Entity = Entity; // export class 
Entity._serializer = {
	pid: MASK.ALWAYS,
	secret: MASK.NEVER
};

var subtypes = {};

// attr path
Entity.prototype.uid = function(v){ return this.getAttribute('uid'); }
Entity.prototype.setUid = function(v){ this.setAttribute('uid',v); return this; };
Entity.prototype.up = function(v){ return this.getAttribute('up'); }
Entity.prototype.setUp = function(v){ this.setAttribute('up',v); return this; };
Entity.prototype.visibility = function(v){ return this.getAttribute('visibility'); }
Entity.prototype.setVisibility = function(v){ this.setAttribute('visibility',v); return this; };
Entity.prototype.crets = function(v){ return this.getAttribute('crets'); }
Entity.prototype.setCrets = function(v){ this.setAttribute('crets',v); return this; };
Entity.prototype.pubts = function(v){ return this.getAttribute('pubts'); }
Entity.prototype.setPubts = function(v){ this.setAttribute('pubts',v); return this; };
Entity.prototype.pos = function(v){ return this.getAttribute('pos'); }
Entity.prototype.setPos = function(v){ this.setAttribute('pos',v); return this; };
Entity.prototype.title = function(v){ return this.getAttribute('title'); }
Entity.prototype.setTitle = function(v){ this.setAttribute('title',v); return this; };
Entity.prototype.body = function(v){ return this.getAttribute('body'); }
Entity.prototype.setBody = function(v){ this.setAttribute('body',v); return this; };
Entity.prototype.draft = function(v){ return this.getAttribute('draft'); }
Entity.prototype.setDraft = function(v){ this.setAttribute('draft',v); return this; };
Entity.prototype.state = function(v){ return this.getAttribute('state'); }
Entity.prototype.setState = function(v){ this.setAttribute('state',v); return this; };
Entity.prototype.secret = function(v){ return this.getAttribute('secret'); }
Entity.prototype.setSecret = function(v){ this.setAttribute('secret',v); return this; };
Entity.prototype.github = function(v){ return this.getAttribute('github'); }
Entity.prototype.setGithub = function(v){ this.setAttribute('github',v); return this; };
Entity.prototype.git = function(v){ return this.getAttribute('git'); }
Entity.prototype.setGit = function(v){ this.setAttribute('git',v); return this; };
Entity.prototype.roles = function(v){ return this.getAttribute('roles'); }
Entity.prototype.setRoles = function(v){ this.setAttribute('roles',v); return this; };
Entity.prototype.ghapp = function(v){ return this.getAttribute('ghapp'); }
Entity.prototype.setGhapp = function(v){ this.setAttribute('ghapp',v); return this; };
Entity.prototype.stripe = function(v){ return this.getAttribute('stripe'); }
Entity.prototype.setStripe = function(v){ this.setAttribute('stripe',v); return this; };
Entity.prototype.subscription = function(v){ return this.getAttribute('subscription'); }
Entity.prototype.setSubscription = function(v){ this.setAttribute('subscription',v); return this; };

Entity.prototype.__ref = {watch: 'refDidSet',name: 'ref'};
Entity.prototype.ref = function(v){ return this._ref; }
Entity.prototype.setRef = function(v){
	var a = this.ref();
	if(v != a) { this._ref = v; }
	if(v != a) { this.refDidSet && this.refDidSet(v,a,this.__ref) }
	return this;
};
Entity.prototype.__path = {watch: 'pathDidSet',name: 'path'};
Entity.prototype.path = function(v){ return this._path; }
Entity.prototype.setPath = function(v){
	var a = this.path();
	if(v != a) { this._path = v; }
	if(v != a) { this.pathDidSet && this.pathDidSet(v,a,this.__path) }
	return this;
};
Entity.prototype.children = function(v){ return this._children; }
Entity.prototype.setChildren = function(v){ this._children = v; return this; };

Entity.ins = async function (store,item,api){
	// console.log "Entity.ins",item
	var v_;
	if (true) {
		item.localid = item.id;
		
		if (api) {
			item.uid = api.uid();
			// item:up ||= await api.entities.entityIdForUid(item:uid)
		};
		
		(((v_ = item.id),delete item.id, v_));
		// validate
		let res = await store.table().returning('id').insert(item);
		let model = await store.table().where({id: res[0]}).first();
		return store.read(model);
	};
};

Entity.read = function (data,store){
	let id = data.id;
	let typ = this;
	
	// if id and id[1] == 's'
	//	typ = Entity.Scrim
	typ = subtypes[id[1]] || this;
	return new typ(data,store);
};

Entity.build = function (data,store,token){
	data.id = 'e' + data.type[0] + (data.pid ? (data.pid + '_' + token) : token);
	return data;
};


Entity.reg = function (k){
	return subtypes[this._prefix = this.prototype._prefix = k] = this;
};
// need options for these keys - telling whether they should set in draft or not

Entity.canPut = function (data,prev,scope){
	// TODO Write thorough tests
	// console.log "canPut",data,prev,scope.uid,prev.uid
	if (scope.pid() == prev.pid && (!data.pid || data.pid == prev.pid)) {
		return true;
	};
	
	if (scope.uid() == prev.uid() && (data.uid == prev.uid() || data.uid === undefined)) {
		return true;
	};
	
	// TODO filter which properties we can set
	return false;
};

Entity.prototype.patched = function (diff,values){
	this.setRef(this._data.ref);
	this.setPath(this._data.path);
	this.emit('patch',this,values);
	return this;
};

Entity.prototype.refDidSet = function (ref){
	var presenter;
	if (ref) {
		this._store.index('ref',ref,this);
	};
	if (false && window.App) {
		// hack
		// console.log "refDidSet with App",self:id,ref
		if (presenter = window.App._presenters[ref]) {
			presenter.setData(this);
		};
	};
	return;
};

Entity.prototype.pathDidSet = function (path){
	if (path && path.indexOf('.') > 0) {
		this.parent().children().add(this);
	};
	return this;
};

Entity.prototype.starred = function (uid){
	return this.roles()[uid || this.db().api().uid()] & ROLEFLAGS.FOLLOWER;
};

Entity.prototype.ts = function (){
	return this.pubts() || this.crets();
};

Entity.prototype.dependsOn = function (){
	return [this.user(),this.parents()];
};

Entity.prototype.entity = function (){
	return this;
};

Entity.prototype.isHub = function (){
	return /[ho]/.test(this.id[1]);
};

Entity.prototype.user = function (){
	return this._data.uid ? this.db().users().get(this._data.uid) : null;
};

Entity.prototype.parent = function (){
	return this.parents()[len$(this.parents()) - 1];
};

Entity.prototype.ns = function (){
	return this._data.ns || this._data.ref;
};

// return the hub for entity
Entity.prototype.hub = function (){
	var p, m;
	return this == this.isHub();
	if (!(p = this.path())) { return null };
	// cache based on path?
	if (m = this.p().match(/\be[ho][^\.]+/)) {
		return this.db().get(m[0]);
	};
};

Entity.prototype.parents = function (){
	var self = this;
	return self._cache.parents || (self._cache.parents = (self.path() ? self.path().split(".").slice(0,-1).map(function(id) { return self.db().entities().get(id); }) : []));
};

Entity.prototype.parentsAndSelf = function (){
	var self = this;
	return self._cache.chain || (self._cache.chain = (self.path() ? self.path().split(".").map(function(id) { return self.db().entities().get(id); }) : [self]));
};

// TODO this is half broken - write tests and fix
Entity.prototype.isDescendantOf = function (str){
	let entity = str;
	if ((typeof str=='string'||str instanceof String)) {
		let ns = this.ns();
		
		if (ns && ns.indexOf(str) == 0 && (ns == str || ns[str.length] == '/') && this._data.ref != str) {
			return true;
		};
		// entity = db.entities.index('ref',@data:ns) or db.entities.get(str)
	} else {
		return this.parents().indexOf(entity) >= 0;
	};
};

Entity.prototype.isHidden = function (){
	return false;
};

Entity.prototype.isPrivate = function (){
	return this.visibility() > 0;
};

Entity.prototype.isRemote = function (){
	// isLocal and peer and peer != db.api.peer
	return this.host() && this.host() != this.db().api().peer();
};

Entity.prototype.contains = function (entity){
	return entity.path().indexOf(this.path()) == 0 && entity != this;
};

Entity.prototype.belongsTo = function (user){
	return this.user() && user == this.user();
};

// permission name, roles
Entity.prototype.link = function (uid){
	if(uid === undefined) uid = this.db().api().uid();
	uid || (uid = 'unull');
	return this._cache[uid] || (this._cache[uid] = this.db().links().read({id: ("l-" + uid + "-" + (this.id)),uid: uid,eid: this.id}));
};

Entity.prototype.level = function (){
	return this._cache.level || (this._cache.level = len$(this.parentsAndSelf()));
};

Entity.prototype.descendants = function (){
	var self = this;
	return self._cache.descendants || (self._cache.descendants = self.db().entities().sel(function(_0) { return self.contains(_0); }));
};

Entity.prototype.entities = function (){
	return this.descendants();
};

Entity.prototype.repos = function (){
	return this._cache.repos || (this._cache.repos = this.children().sel(function(_0) { return _0.type() == 'repo'; }));
};

Entity.prototype.issues = function (){
	return this._cache.issues || (this._cache.issues = this.children().sel(function(_0) { return _0.type() == 'issue'; }));
};

Entity.prototype.members = function (){
	// extremely expensive on server?
	var self = this;
	return self._cache.members || (self._cache.members = self.db().links().sel(function(_0) { return _0.eid == self.id && _0.role() > 0; }));
};

Entity.prototype.users = function (flag){
	var $1;
	if(flag === undefined) flag = 0;
	if (!this._cache[$1 = 'users' + flag]) { let res = [];
	for (let o = this._data.roles, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];if (k[0] != 'u') { continue; };
		if (flag && (v & flag) != flag) { continue; };
		res.push(this.db().users().get(k));
	};
	return this._cache[$1] = res; } else {
		return this._cache[$1]
	};
};

Entity.prototype.topics = function (){
	var self = this;
	let raw = self._data.topics;
	return raw ? ((raw.TOPICS || (raw.TOPICS = raw.map(function(_0) { return self.db().topics().get(_0); })))) : [];
};

Entity.prototype.owner = function (){
	return this.db().get(this.uid());
};

Entity.prototype.allowed = function (action,actor){
	if (false) {};
	var role = this.roleFor(actor);
	var perm = PERMISSIONS[action.toUpperCase()] || PERMISSIONS.WRITE;
	return (role & perm) > 0;
};

Entity.prototype.can = function (actor,action){
	return this.allowed(action,actor);
};

Entity.prototype.preload = async function (){
	var self = this;
	await Promise.all(self._data.path.split(".").map(function(id) { return self.db().entities().summon(id); }));
	return self;
};

// roles for entities should be cached globally and the whole cache can be flushed
// when visibility is set for an entity (maybe all cached paths could be invalidated)
// or when the role of a link is edited (this should invalidate all permissions involving)
// that user and that entity (in all entity-paths)
Entity.prototype.roleFor = function (actor){
	
	
	var uid = (actor && actor.user()) ? actor.user().id : null;
	var secrets = actor && actor.secrets(); // 
	var cacheKey = ("" + (this.id) + ":" + uid + ":role");
	
	if (false) {};
	// if you have a role 
	var role = ROLEFLAGS.GUEST;
	var chain = this.parentsAndSelf();
	
	for (let i = 0, items = iter$(chain), len = items.length; i < len; i++) {
		let d = items[i]._data;
		let guard = d.visibility || 0; // 0 is public?
		let perms = d.roles[uid] || d.roles.guest || 0;
		// reset role if entity is guarded
		if (guard && (role & guard) == 0) {
			role = 0;
		};
		
		// accessing through secret will always grant reporter access atm
		if (!perms && secrets[d.id] && d.secret == secrets[d.id]) {
			perms = ROLEFLAGS.REPORTER;
		};
		
		// WARN with this concept users will always keep their outer roles
		role = role | perms;
	};
	
	if (false) {};
	
	return role;
	
	
	if (uid && this.uid() == uid) {
		return ROLES.OWNER;
	};
	
	chain = this.parentsAndSelf();
	var links = this.db().links()._map;
	role = ROLES.GUEST;
	
	for (let i = 0, items = iter$(chain), len = items.length, item; i < len; i++) {
		item = items[i];
		let visibility = item.visibility();
		
		if (visibility > role) {
			role = 0;
		};
		
		let link = uid ? links[("l-" + uid + "-" + (item.id))] : null;
		
		if (link && link.role()) {
			role = Math.max(link.role(),role);
		} else if (secrets[item.id] && item.secret() == secrets[item.id]) {
			role = ROLES.GUEST;
		};
	};
	
	// if self:id == 'es9j'
	// console.log "handled roleFor",uid,role,chain.map(|item| item:id),self:v,@data
	return role;
};


Entity.prototype.url = function (){
	if (this.ref() && this.isGroup()) {
		return ("/" + this.ref());
	} else {
		return ("/" + (this._prefix) + "/" + this.id.slice(2)); // "/entity/{self:id}"
	};
};

// def path
// 	@data:path or ""

Entity.prototype.type = function (){
	return this._data.type;
};

Entity.prototype.name = function (){
	return this.title();
};

Entity.prototype.get = function (key){
	return this._data[key];
	// what about draft?
	// @data:data ? @data:data[key] : @data[key]
};

Entity.prototype.set = function (key,value,mod){
	if(mod === undefined) mod = {};
	if (key instanceof Object) {
		for (let v, i = 0, keys = Object.keys(key), l = keys.length, k; i < l; i++){
			k = keys[i];v = key[k];this.set(k,v,mod);
		};
		return this;
	};
	
	
	let dict = this._data; // :data or @data:draft
	// should probably track which changes are local - and then access these with get?
	let prev = dict[key];
	if (mod.nx && prev != undefined) {
		return this;
	};
	
	dict[key] = value;
	return this;
};

Entity.prototype.setnx = function (key,value){
	return this.set(key,value,{nx: true});
};

Entity.prototype.serialize = function (scop){
	var s = this.constructor._serializer;
	var uid;
	
	// somewhere else?
	if (true) {
		scop || (scop = this._db.scope());
		if (!this.allowed('read',scop)) { return null };
	};
	
	if (false) {};
	
	var obj = {};
	var raw = this._data;
	var id = this._data.id;
	for (let v, i = 0, keys = Object.keys(raw), l = keys.length, k; i < l; i++){
		k = keys[i];v = raw[k];if (s && s[k] !== undefined) {
			if (v === undefined) {
				v = null;
			};
			if (s[k] == MASK.NEVER) {
				continue;
			};
		} else if (k[0] == '_' || v == undefined) {
			continue;
		};
		obj[k] = v;
	};
	return obj;
};

Entity.prototype.match = function (query){
	if (typeof query == 'string') {
		return this.textindex().indexOf(query) >= 0;
	} else if (query instanceof RegExp) {
		return query.test(this.textindex());
	};
	return false;
};

Entity.prototype.textindex = function (){
	return this._cache.textindex || (this._cache.textindex = [
		this._data.ref,
		this._data.title,
		this._data.desc,
		this.user() ? this.user().shortName() : ''
	].join(' ').split(' ').sort().join(' ').toLowerCase());
};

Entity.prototype.inScope = function (items){
	let uid = App.uid();
	if (!uid) { return false };
	// console.log "inScope",items
	for (let i = 0, ary = iter$(this.parentsAndSelf()), len = ary.length, item; i < len; i++) {
		item = ary[i];
		if (item.roles()[uid] || item._data.uid == uid) {
			return true;
		};
	};
	return false;
};

Entity.prototype.isNote = function (){
	return Prefix.Note[this.id[1]];
};

Entity.prototype.isHub = function (){
	return Prefix.Hub[this.id[1]];
};

Entity.prototype.isScrim = function (){
	return Prefix.Scrim[this.id[1]];
};

Entity.prototype.isGroup = function (){
	return Prefix.Group[this.id[1]];
};

Entity.prototype.isProject = function (){
	return Prefix.Project[this.id[1]];
};

Entity.prototype.isUser = function (){
	return Prefix.User[this.id[1]];
};

Entity.prototype.isOrg = function (){
	return Prefix.Org[this.id[1]];
};

Entity.prototype.isPublished = function (){
	// is published if it has data? really?
	return !(!(this.pubts()));
};

Entity.prototype.isDraft = function (){
	return !(this.isPublished());
};

Entity.prototype.meta = function (){
	return this._data.meta;
};

Entity.prototype.shortName = function (){
	return this.name();
};

Entity.prototype.color = function (){
	// should traverse upwards to get closest color?
	return this._data.data && this._data.data.color;
};

Entity.prototype.art = function (name){
	if(name === undefined) name = 'logo';
	return this._data.data && this._data.data[name];
};

Entity.prototype.avatar = function (size){
	return this.art('logo',size) || this.avatarUrl(size) || (this.parent() ? this.parent().avatar(size) : null);
};

Entity.prototype.avatarUrl = function (s){
	if(s === undefined) s = 64;
	if (this.isHub()) {
		return ("https://avatars.githubusercontent.com/" + this.ref() + "?s=" + s);
	} else if (this.parent()) {
		return this.parent().avatarUrl(s);
	} else {
		return null;
	};
	
	// if !self:username and var gravatar = gravatarHash
	// 	"https://www.gravatar.com/avatar/{gravatar}?s={s}"
	// else
	// 	"https://avatars.githubusercontent.com/{self:username}?s={s}"
};

Entity.prototype.styleFlag = function (){
	var self = this, m, m2, m3;
	if (self._styleFlag) { return self._styleFlag };
	// inject into stylesheet!!
	
	let vars = Object.assign({},{color: self.color() || 'black'});
	let logo = self.art('logo');
	let params = [];
	let colors = [];
	
	if (vars.color) {
		// dont support this here?
		// let hsl = color-convert:hex.hsl(vars:color.replace('#',''))
		// vars:hue = hsl[0]
	};
	
	let sel = ("." + (self.id)) + '{';
	
	if (logo && false) {
		if (m = logo.match(/viewBox=[\"\']0 0 (\d+) (\d+)/)) {
			vars.logoWidth = parseInt(m[1]);
			vars.logoHeight = parseInt(m[2]);
		} else if (m2 = logo.match(/svg\" height=\"(\d+)\" width=\"(\d+)\"/)) {
			vars.logoWidth = parseInt(m2[2]);
			vars.logoHeight = parseInt(m2[1]);
		} else if (m3 = logo.match(/svg\" width=\"(\d+)\" height=\"(\d+)\"/)) {
			vars.logoWidth = parseInt(m3[1]);
			vars.logoHeight = parseInt(m3[2]);
		};
		
		logo.replace(/\#([a-fA-F0-9]{3,6})/g,function(_0,_1) {
			let hsl = self.colorConvert().hex.hsl(_1);
			return colors.push(hsl);
		});
		
		// sort colors by lightness - nearest to 50% lightness
		colors.sort(function(a,b) { return Math.abs(a[2] - 50) - Math.abs(b[2] - 50); });
		
		for (let i = 0, len = colors.length, color; i < len; i++) {
			color = colors[i];
			vars[("color" + (i || ''))] = ("hsl(" + (color[0]) + "," + (color[1]) + "%," + (color[2]) + "%)");
		};
		
		vars.logo = ("url('data:image/svg+xml;utf8," + logo + "')");
	};
	
	for (let val, i = 0, keys = Object.keys(vars), l = keys.length, name; i < l; i++){
		name = keys[i];val = vars[name];sel += ("--ent-" + name + ": " + val + ";\n");
	};
	sel += '}\n';
	
	if (false) {};
	
	return self._styleFlag = ("" + (self.id)); // include the path
};

if (false) {};

Entity.Group = function Group(){ return Entity.apply(this,arguments) };

Imba.subclass(Entity.Group,Entity);


Entity.Hub = function Hub(){ return Entity.Group.apply(this,arguments) };

Imba.subclass(Entity.Hub,Entity.Group);
Entity.Hub.reg('h');

Entity.Org = function Org(){ return Entity.Group.apply(this,arguments) };

Imba.subclass(Entity.Org,Entity.Group);
Entity.Org.reg('o');

Entity.User = function User(){ return Entity.Group.apply(this,arguments) };

Imba.subclass(Entity.User,Entity.Group);
Entity.User.reg('u');

Entity.Course = function Course(){ return Entity.Group.apply(this,arguments) };

Imba.subclass(Entity.Course,Entity.Group);
Entity.Course.reg('c');

Entity.Repo = function Repo(){ return Entity.Group.apply(this,arguments) };

Imba.subclass(Entity.Repo,Entity.Group);
Entity.Repo.reg('r');

Entity.Note = function Note(){ return Entity.apply(this,arguments) };

Imba.subclass(Entity.Note,Entity);
Entity.Note.reg('n');

Entity.Message = function Message(){ return Entity.apply(this,arguments) };

Imba.subclass(Entity.Message,Entity);
Entity.Message.reg('m');

Entity.Scrim = function Scrim(){ return Entity.apply(this,arguments) };

Imba.subclass(Entity.Scrim,Entity);
Entity.Scrim.reg('s');

Entity.Scrim.prototype.cli = function (){
	return this._data.data ? this._data.data.cli : null;
};

Entity.Scrim.prototype.isLive = function (){
	return !!this._data.pid;
};

Entity.Scrim.prototype.isEnded = function (){
	let s = this.state();
	return s == 'ended' || s == 'published';
};

Entity.Scrim.prototype.isHidden = function (){
	let s = this.state();
	return s == 'disposed' || s == 'waiting' || s == 'preparing';
};

Entity.Scrim.prototype.duration = function (){
	return this._data.data.duration || 0;
};

Entity.Scrim.prototype.peers = function (){
	var self = this;
	return self._cache.peers || (self._cache.peers = self.db().peers().sel(function(_0) { return _0.eid == self.id && !_0.closed; }));
};

Entity.Scrim.prototype.peer = function (){
	return this.db().peers().get(this._data.pid);
};

Entity.Scrim.prototype.host = function (){
	return this._host || this.peer();
};

/*
	# SCRIM related methods
	*/

Entity.Scrim.prototype.stream = function (){
	return this._cache.stream || (this._cache.stream = new StreamBuffer(null,this));
};

Entity.Scrim.prototype.buffer = function (){
	return this.stream();
};

Entity.Scrim.prototype.end = function (o){
	if(o === undefined) o = {};
	return this.rpc('scrimEnd',o);
};

Entity.Scrim.prototype.channelRef = function (){
	return ("" + (this.id) + "." + (this.v) + (this.buffer().FETCHING ? '' : ('.' + len$(this.buffer()))));
};

Entity.Scrim.prototype.onpacket = function (packet){
	if (packet.CODE >= 100 && this._branch) {
		return this._branch.onpacket(packet);
	} else {
		// console.log "entity.onpacket",packet
		// maybe send to space no matter what?
		return this.buffer().onpacket(packet);
	};
};

Entity.Scrim.prototype.fetchStreamBuffer = function (api,byteOffset){
	var self = this;
	if(byteOffset === undefined) byteOffset = 0;
	return new Promise(async function(resolve,reject) {
		self.buffer().FETCHING = true;
		var draft = self._data.draft;
		var action;
		
		if (true) {
			action = api.scrimFetchStream(self.id,byteOffset);
		};
		
		var chunk = await action;
		var ary = new Uint8Array(chunk);
		if (ary.length > 1) {
			self.buffer().add(ary,byteOffset);
			if (false) {};
		};
		self.buffer().FETCHING = false;
		return resolve(self.buffer());
	});
};
