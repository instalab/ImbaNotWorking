function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba'), _1 = Imba.createElement;


var protocol$ = require('../protocol'), MSG = protocol$.MSG, ACTION = protocol$.ACTION, CAST = protocol$.CAST, SCON = protocol$.SCON;

var util = require('../util');

var delayPromise = function(ms) {
	if(ms === undefined) ms = 1000;
	return new Promise(function(resolve,reject) {
		return setTimeout(resolve,ms);
	});
};

var RecDoneDialog = require('../views/RecDoneDialog').RecDoneDialog;
var MediaRecording = require('../util/MediaRecording').MediaRecording;
var List = require('../util/List').List;

// externs;

function Recording(branch,options){
	var self = this;
	if(options === undefined) options = {};
	self._branch = branch;
	self._state = 'ready';
	self._options = options;
	self._live = options.live || false;
	branch.setRecording(self);
	self._startTimeOffset = branch.currentOffset();
	self._startTime = branch.timeline().endTime();
	self._draftEnd = branch.draft().end;
	self._initialState = branch.state();
	self._mediaStreams = new List(self);
	
	self._mediaStreams.on('add',function(stream) {
		console.log("added media-stream",stream);
		if (!(self.isPersisting())) { return };
		
		let rec = stream._recording || (stream._recording = new MediaRecording(
			{stream: stream,
			space: self.space(),
			owner: self,
			data: {
				pid: stream._peer.id
			}}
		));
		return rec.start();
	});
	
	self._mediaStreams.on('remove',function(stream) {
		return console.log("removed media-stream",stream);
	});
	
	self;
};

// directly from peer
// onaddstream

exports.Recording = Recording; // export class 
Recording.prototype.branch = function(v){ return this._branch; }
Recording.prototype.setBranch = function(v){ this._branch = v; return this; };
Recording.prototype.state = function(v){ return this._state; }
Recording.prototype.setState = function(v){ this._state = v; return this; };
Recording.prototype.options = function(v){ return this._options; }
Recording.prototype.setOptions = function(v){ this._options = v; return this; };
Recording.prototype.audio = function(v){ return this._audio; }
Recording.prototype.setAudio = function(v){ this._audio = v; return this; };
Recording.prototype.live = function(v){ return this._live; }
Recording.prototype.setLive = function(v){ this._live = v; return this; };
Recording.prototype.startTimeOffset = function(v){ return this._startTimeOffset; }
Recording.prototype.setStartTimeOffset = function(v){ this._startTimeOffset = v; return this; };
Recording.prototype.media = function(v){ return this._media; }
Recording.prototype.setMedia = function(v){ this._media = v; return this; };
Recording.prototype.mediaStreams = function(v){ return this._mediaStreams; }
Recording.prototype.setMediaStreams = function(v){ this._mediaStreams = v; return this; };

Recording.prototype.space = function (){
	return this.branch().space();
};

Recording.prototype.log = function (){
	var api_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (api_ = this.api()).log.apply(api_,[].concat(['rec'], [].slice.call(params)));
};

Recording.prototype.api = function (){
	return this.space().api();
};

Recording.prototype.stream = function (){
	return this.branch().stream();
};

Recording.prototype.model = function (){
	return this.branch().model();
};

Recording.prototype.duration = function (){
	return this._startAt ? (((this._stopAt || Date.now()) - this._startAt)) : 0;
};

Recording.prototype.startTime = function (){
	return this._startTime;
};

Recording.prototype.currentTime = function (){
	return this.duration();
};

Recording.prototype.isRecording = function (){
	return this.state() == 'recording';
};

Recording.prototype.isPersisting = function (){
	return this._options.persist;
};

Recording.prototype.broadcastAudio = function (){
	return this.options().broadcastAudio;
};

Recording.prototype.start = function (){
	var self = this;
	return self._start || (self._start = new Promise(async function(resolve,reject) {
		self.space().setRecording(self);
		self._origin = self.space().cursor().current();
		self._startTimeOffset = self.stream().lastTimeOffset(); // not based on timeline/cues
		self._isFirstRecording = len$(self.stream().recordings()) == 0; // lastActions[CAST.RECSTART]
		
		self.api().analytics().castRecStart(self.branch().id());
		
		self.setState('starting');
		// should contact server and ask for the exclusive right
		// to editing this stream starting now (with a timeout)
		// var wait = Math.max(-duration,200)
		var start = util.delay(100);
		
		if (self.options().mic) {
			let mediaStream = await self.api().media().getUserMedia({video: false,audio: self.options().mic});
			self.api().setMic(mediaStream);
			
			if (self.isPersisting()) {
				await util.delay(250);
				self.setAudio(new MediaRecording(
					{chunkSize: 2400,
					stream: mediaStream,
					constraints: self.options().mic,
					space: self.space(),
					owner: self,
					data: {pid: self.api().pid()}}
				));
				
				start = self.audio().start();
			};
		};
		
		let catcher = function(e) {
			self.space().setRecording(null);
			self.teardown();
			return reject(e);
		};
		
		start.then(function() {
			self._startAt = self.audio() ? self.audio().startedAt() : Date.now();
			self.setState('recording');
			self.options().startTime = self._startAt;
			
			// set the audio stream for local peer
			if (self.broadcastAudio() && self.api().mic()) {
				self.api().peer().rtc().setMedia(self.api().mic());
			};
			
			if (self.audio()) {
				self.options().audiofile = self.audio()._model.toJSON();
			};
			
			let op = [{},self.options()];
			self.stream().anchorTime({offset: self._startTimeOffset,now: self._startAt});
			
			self.stream().freezeTime(self._startAt,function() {
				// console.log "setMode recording from",branch.mode
				self.branch().setMode('recording');
				self._recEvent = self.branch().push_(ACTION.RECSTART,op,{timeOffset: self._startTimeOffset}); // force offset?
				self.api().setBroadcasting(self);
				// WARN should happen immediately when we go live -- otherwise other peers might connect too early
				
				// this is an example of a point where it would be nice to batch timing
				// console.log "flush locals!"
				self.space().view().focusViewport(); // weird thing to do? The focus should go directly to file?
				// space.client.flushLocals # again
				if (self.options().pointer) { self.space().pointerTracker().start() };
				return resolve(self);
			});
			
			// console.warn "stream.nextOffset",stream.nextOffset
			return self._interval = setInterval(function() {
				self.branch().push_(ACTION.PING,[Date.now()]);
				return self.ping();
			},2000);
		},catcher);
		return self;
	}));
};

Recording.prototype.onaudioerror = function (e){
	return console.log("audio-error!",e);
};

Recording.prototype.ping = function (o){
	
	// should include details about the peers we maintain a connection to
	// for this specific scrim
	if(o === undefined) o = {};
	let live = Object.assign({
		ts: Date.now(),
		offset: this.stream().nextTimeOffset(),
		state: this.branch().mode(),
		pid: this.api().pid(),
		peers: this.api().peers().toArray(),
		host: true
	},o);
	
	for (let i = 0, items = iter$(this.api().peers()), len = items.length; i < len; i++) {
		items[i].send([MSG.AGENTLIVE,this.branch().id(),live]);
	};
	return this;
};

Recording.prototype.stop = async function (){
	if (this._stopAt) {
		return this;
	};
	
	clearInterval(this._interval);
	
	this.setState('stopping');
	this._stopAt = Date.now();
	
	this.space().browser().stop();
	// this should now stop by itself when space.me is suddenly set back to spectator
	this.space().pointerTracker().stop();
	
	// we should not allow any more events for some time - to make sure
	// that the real duration of the audio won't end before the last few events
	this.log('stop',this._stopAt);
	
	await Promise.all(this._mediaStreams.map(function(stream) { var _recording_;
	return (_recording_ = stream._recording) && _recording_.stop  &&  _recording_.stop(); }));
	await (this.audio() ? this.stopAudio() : Promise.resolve({}));
	
	// what about remote audio-streams?
	this._stopTimeOffset = Math.round(this._startTimeOffset + (this._stopAt - this._startAt));
	this.stream().anchorTime({offset: this._stopTimeOffset,now: this._stopAt});
	this._stopEvent = this.branch().push_(ACTION.RECSTOP,[],{timeOffset: this._stopTimeOffset});
	// should we not stop here already?
	this.branch().timeline().pause();
	this.ping({end: true});
	
	if (this.isPersisting()) {
		// make sure syncer is saved
		await this.branch().syncer().persist(true);
	};
	
	await this.api().request([MSG.SCRIMSTOP,this.model().id]);
	
	if (this.api().broadcasting() == this) {
		this.api().setBroadcasting(null);
		// App.router.replace(branch.model.url)
	};
	return ((_1(RecDoneDialog).flag('modal')).setData(this).end()).show();
};

Recording.prototype.stopAudio = async function (){
	// give the audio 300ms extra time to end
	await delayPromise(300);
	await this.audio().stop();
	
	this._stopAt = this._startAt + this.audio().duration();
	console.log("audio.duration",this.audio().duration());
	return this;
};

Recording.prototype.discard = async function (){
	var audio_;
	this.branch().timeline().pause();
	// if we were live - dont trim
	// await branch.trimToAction(@origin)
	// discard the audio recording as well
	(audio_ = this.audio()) && audio_.discard  &&  audio_.discard();
	await this.api().request([MSG.SCRIMDISPOSE,this.model().id]);
	if (this.branch().timeline().duration() == 0) {
		this.branch().timeline().setState('watching');
	};
	this.teardown();
	// api.analytics.castRecDiscard(branch.id)
	return Promise.resolve(this);
};

Recording.prototype.uploadStream = async function (){
	this._streamFile = await this.api().db().files().ins(
		{id: ("fo" + (this.branch().id()) + ".scrim"),
		uid: this.api().uid(), // should belong to a different user no?
		eid: this.branch().id(),
		type: 'application/x.scrim',
		state: 'streaming',
		size: 0,
		metadata: {}}
	);
	var buffer = this.branch().stream().buffer().slice(0);
	return await this._streamFile.upload(buffer);
};

Recording.prototype.finish = async function (){
	var user = await this.api().tryLogin();
	if (!user) {
		console.warn("You cannot persist without being logged in!");
		return this.discard();
	};
	
	if (!(this.isPersisting())) {
		console.warn("Must choose to record upon starting (during alpha)");
		return this.discard();
	};
	
	// upload stream
	await this.uploadStream();
	
	var upload = await ((this.audio() && this.isPersisting()) ? this.audio().upload() : {});
	
	if (this.audio() && this.isPersisting()) {
		// don't use this anymore -- will want to get audio from stream
		var audioMarker = [1,this._startTimeOffset,this._stopTimeOffset - this._startTimeOffset,this.audio()._model.id];
		console.log("audioMarker",audioMarker,this.audio().duration(),this._stopTimeOffset - this._startTimeOffset);
		this.branch().draft().audio.push(audioMarker);
	};
	
	await Promise.all(this._mediaStreams.map(function(stream) { var _recording_;
	return (_recording_ = stream._recording) && _recording_.upload  &&  _recording_.upload(); }));
	
	// update the end-item here
	// TODO possibly end it at the audio-marker
	if (this._isFirstRecording) {
		this.branch().draft().start = this._startTimeOffset;
	};
	
	this.branch().draft().end = this._stopTimeOffset;
	this.branch().draft().stream = this._streamFile.id;
	console.log("finishing",this._stopTimeOffset,this._startTimeOffset);
	await this.branch().save();
	
	// TODO include duration and other metadata?
	// await branch.save({pid: null, draft: SCON.clone(branch.draft)})
	this.setState('stopped');
	this.branch().setMode('paused');
	await this.api().request([MSG.SCRIMPERSIST,this.model().id,SCON.clone(this.branch().draft())]);
	this.teardown();
	Imba.Scheduler.event({type: "recstop"});
	// api.analytics.castRecSave(branch.id)
	// log("CASTREC",stream.lastActions[ACTION.RECSTART],stream.lastActions[ACTION.RECSTOP])
	return Promise.resolve(this);
};

Recording.prototype.teardown = function (){
	var v_;
	clearInterval(this._interval);
	this.branch().setRecording(null);
	return (this.space().setRecording(null),null);
};
