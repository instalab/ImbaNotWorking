function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _1 = Imba.createElement;

var util = require('../util');

var protocol$ = require('./protocol'), ACTION = protocol$.ACTION, CAST = protocol$.CAST, WIDGET = protocol$.WIDGET, SCON = protocol$.SCON, MSG = protocol$.MSG;

var List = require('./util/List').List;
var Branch$ = require('./Branch'), Branch = Branch$.Branch, Trunk = Branch$.Trunk;
var Widget = require('./widgets/index').Widget;
var Widgets = require('./widgets/widgets').Widgets;
var SpaceView = require('./views/SpaceView').SpaceView;
var Action$ = require('./util/Action'), Action = Action$.Action, ActionManager = Action$.ActionManager;
var Client = require('./core/Client').Client;

var AudioManager = require('./util/AudioManager').AudioManager;
var Cursor = require('./core/Cursor').Cursor;
var Dimensions = require('./core/Dimensions').Dimensions;

var Cast = require('../models/Cast').Cast;
var PointerTracker = require('./util/PointerTracker').PointerTracker;


var FileSystemWidget = require('./widgets/DirWidget').FileSystemWidget;
var SlidesWidget = require('./widgets/SlidesWidget').SlidesWidget;
var EditorWidget = require('./widgets/EditorWidget').EditorWidget;

var SidebarWidget = require('./widgets/SidebarWidget').SidebarWidget;
var ExplorerPanel = require('./widgets/ExplorerPanel').ExplorerPanel;
var DependenciesPanel = require('./widgets/DependenciesPanel').DependenciesPanel;

var tracking = require('./tracking');

require('./actions');

// Should be moved elsewhere
Imba.extendTag('element', function(tag){
	
	tag.prototype.sref = function (){
		return this._sref || (this._sref = this.dataset('sref'));
	};
	
	tag.prototype.setSref = function (ref){
		if (this._sref != ref) {
			this.dataset('sref',this._sref = ref);
		};
		return this;
		return this;
	};
});

/*

A space is stored and constructed from a single list of sequential
events. At any point in time it might have multiple active participants,
multiple files etc, but only the stream of events will ever be saved.

The state at any specific time can always be constructed by applying
all events up until that point in the stream.

*/


var SpaceInstanceCounter = 0;

function Space(data,options){
	var self = this;
	if(options === undefined) options = {};
	if (false) {};
	// should abstract this out into its own class
	self._data = {};
	self._model = data; // should be certain that this is correct already
	self._id = self._model.id;
	self._promises = {};
	
	self._options = options;
	self._playlist = options.playlist || self._model.playlist();
	self._namespace = ("sp" + (SpaceInstanceCounter++));
	self._randomIncr = 0;
	self._stats = {viewers: 0};
	self._counters = {ticks: 0};
	self._client = new Client(self);
	self._toucher = function() { return self.dirty(); };
	self.setReadyState('init');
	self;
};

exports.Space = Space; // export class 
Space.prototype.options = function(v){ return this._options; }
Space.prototype.setOptions = function(v){ this._options = v; return this; };
Space.prototype.playlist = function(v){ return this._playlist; }
Space.prototype.setPlaylist = function(v){ this._playlist = v; return this; };
Space.prototype.stats = function(v){ return this._stats; }
Space.prototype.setStats = function(v){ this._stats = v; return this; };
Space.prototype.offset = function(v){ return this._offset; }
Space.prototype.setOffset = function(v){ this._offset = v; return this; };

Space.prototype.trunk = function(v){ return this._trunk; }
Space.prototype.setTrunk = function(v){ this._trunk = v; return this; };
Space.prototype.branch = function(v){ return this._branch; }
Space.prototype.setBranch = function(v){ this._branch = v; return this; };

// the branch we are currently scoped into
Space.prototype.cursor = function(v){ return this._cursor; }
Space.prototype.setCursor = function(v){ this._cursor = v; return this; };

Space.prototype.__agent = {watch: 'agentDidSet',name: 'agent'};
Space.prototype.agent = function(v){ return this._agent; }
Space.prototype.setAgent = function(v){
	var a = this.agent();
	if(v != a) { this._agent = v; }
	if(v != a) { this.agentDidSet && this.agentDidSet(v,a,this.__agent) }
	return this;
};

// the main timeline in focus
Space.prototype.__timeline = {watch: 'timelineDidSet',name: 'timeline'};
Space.prototype.timeline = function(v){ return this._timeline; }
Space.prototype.setTimeline = function(v){
	var a = this.timeline();
	if(v != a) { this._timeline = v; }
	if(v != a) { this.timelineDidSet && this.timelineDidSet(v,a,this.__timeline) }
	return this;
};
Space.prototype.__annotation = {watch: 'annotationDidSet',name: 'annotation'};
Space.prototype.annotation = function(v){ return this._annotation; }
Space.prototype.setAnnotation = function(v){
	var a = this.annotation();
	if(v != a) { this._annotation = v; }
	if(v != a) { this.annotationDidSet && this.annotationDidSet(v,a,this.__annotation) }
	return this;
};

Space.prototype.widgets = function(v){ return this._widgets; }
Space.prototype.setWidgets = function(v){ this._widgets = v; return this; };
Space.prototype.files = function(v){ return this._files; }
Space.prototype.setFiles = function(v){ this._files = v; return this; };
Space.prototype.observers = function(v){ return this._observers; }
Space.prototype.setObservers = function(v){ this._observers = v; return this; };
Space.prototype.recording = function(v){ return this._recording; }
Space.prototype.setRecording = function(v){ this._recording = v; return this; };

// default singleton widgets
Space.prototype.fs = function(v){ return this._fs; }
Space.prototype.setFs = function(v){ this._fs = v; return this; };
Space.prototype.layout = function(v){ return this._layout; }
Space.prototype.setLayout = function(v){ this._layout = v; return this; };
Space.prototype.console = function(v){ return this._console; }
Space.prototype.setConsole = function(v){ this._console = v; return this; };
Space.prototype.simulator = function(v){ return this._simulator; }
Space.prototype.setSimulator = function(v){ this._simulator = v; return this; };
Space.prototype.inspector = function(v){ return this._inspector; }
Space.prototype.setInspector = function(v){ this._inspector = v; return this; };
Space.prototype.browser = function(v){ return this._browser; }
Space.prototype.setBrowser = function(v){ this._browser = v; return this; };
Space.prototype.pointerTracker = function(v){ return this._pointerTracker; }
Space.prototype.setPointerTracker = function(v){ this._pointerTracker = v; return this; };
Space.prototype.primaryEditor = function(v){ return this._primaryEditor; }
Space.prototype.setPrimaryEditor = function(v){ this._primaryEditor = v; return this; };
Space.prototype.explorerPanel = function(v){ return this._explorerPanel; }
Space.prototype.setExplorerPanel = function(v){ this._explorerPanel = v; return this; };
Space.prototype.dependenciesPanel = function(v){ return this._dependenciesPanel; }
Space.prototype.setDependenciesPanel = function(v){ this._dependenciesPanel = v; return this; };
Space.prototype.slides = function(v){ return this._slides; }
Space.prototype.setSlides = function(v){ this._slides = v; return this; };
Space.prototype.sidebar = function(v){ return this._sidebar; }
Space.prototype.setSidebar = function(v){ this._sidebar = v; return this; };
Space.prototype.readyState = function(v){ return this._readyState; }
Space.prototype.setReadyState = function(v){ this._readyState = v; return this; };

Space.prototype.client = function(v){ return this._client; }
Space.prototype.setClient = function(v){ this._client = v; return this; };

Space.load = async function (id,api){
	// rewriting legacy int-ids
	if (("" + id).match(/^\d+$/)) { id = ("cast-" + id) };
	
	var data = await api.load(id);
	// make sure we have pub or draft - should always be included though?
	await (data.pub || data.draft || data.fetch());
	if (!data || data.CODE == 404) {
		return null;
	};
	return new this(data,{api: api});
};

Space.prototype.id = function (){
	return this._model.id;
};
Space.prototype.model = function (){
	return this._model;
};
Space.prototype.data = function (){
	return this._data;
};
Space.prototype.namespace = function (){
	return this._namespace;
};
Space.prototype.state = function (){
	return this.model().state;
};
Space.prototype.type = function (){
	return this.model().type;
};

Space.prototype.touch = function (type){
	var num = this._counters[type] || (this._counters[type] = 0);
	this._counters[type] += 1;
	this._dirty = true;
	return this;
};

Space.prototype.counter = function (type){
	return this._counters[type] || 0;
};

Space.prototype.isEditing = function (){
	return this.branch().isEditing();
};

Space.prototype.actions = function (){
	return this._actions || (this._actions = new ActionManager(this));
};

Space.prototype.api = function (){
	return this._options.api;
};

Space.prototype.socket = function (){
	return this.api().socket();
};

Space.prototype.audio = function (){
	return AudioManager.instance();
};

Space.prototype.space = function (){
	return this;
};

Space.prototype.branch = function (){
	return this.cursor().branch();
};

Space.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
Space.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
Space.prototype.once = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.once.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
Space.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

Space.prototype.log = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	if (false) {};
};

Space.prototype.async = function (name){
	var self = this;
	self._asyncTriggers || (self._asyncTriggers = {});
	var fn = self._asyncTriggers[name] || (self._asyncTriggers[name] = function() { return self[name](); });
	Imba.TICKER.add(fn);
	return self;
};

Space.prototype.generateRandomId = function (){
	var start = this._randomIncr++;
	return start + "" + util.uuid().substr(0,8);
};

Space.prototype.timelineDidSet = function (new$,old){
	var $1, $2;
	($1 = old) && $1.deactivate  &&  $1.deactivate();
	($2 = new$) && $2.activate  &&  $2.activate();
	return this.dirty();
};

Space.prototype.annotationDidSet = async function (new$,old){
	var self = this, file_, offset_;
	self.log("annotationDidSet",new$);
	
	var seed = self._preAnnotationAnchor;
	
	self._preAnnotationAnchor = {
		branch: self.branch(),
		offset: self.timeline().currentOffset()
	};
	
	// remove decorations from previous annotations no matter what?
	// BUG if you toggle petween
	if (old) {
		(file_ = self.agent().file()) && file_.deltaDecorations  &&  file_.deltaDecorations(old.id,[]);
	};
	
	// find the correct branch
	if (!(new$)) { return };
	
	await self.navigateTo(new$.cast());
	
	if (new$) {
		// should rather be solved by setting the uri in hash
		var anchor = new$.anchor || {};
		let ref = SCON.decodeURI(anchor.uri);
		
		if ((typeof (offset_ = new$.offset)=='number'||offset_ instanceof Number)) {
			self.timeline().pause();
			self.timeline().seek(new$.offset);
			self.tick();
		};
		
		// disable annotation immediately if we are resyncing
		// let curr = cursor.current
		
		if (ref && ref.path && ref.selection) {
			// throw if wrong event-index?
			// get file at this path(!)
			let file = self.space().fs().find(ref.path);
			self.agent().setFile(file);
			// log "setting range!",anchor,file
			
			var decoration = {
				range: ref.selection,
				options: {
					className: 'question',
					stickiness: 1, // no stickiness
					isWholeLine: !(!ref.selection[4]),
					// inlineClassName: 'question-token'
					hoverMessage: {value: new$.body || "Hlelo"},
					glyphMarginClassName: 'question',
					linesDecorationsClassName: 'question',
					marginClassName: 'question'
				}
			};
			
			file.deltaDecorations(new$.id,[decoration]);
		};
		
		self.cursor().once('sync:start',function() {
			var $1, v_;
			($1 = self.agent().file()) && $1.deltaDecorations  &&  $1.deltaDecorations(new$.id,[]);
			if (self.annotation() == new$) {
				return (self.setAnnotation(null),null);
			};
		});
	};
	
	
	return self;
};

Space.prototype.clone = function (o){
	if(o === undefined) o = {};
	this.log("clone",o);
	
	// var confirm = window.confirm("Are you sure you want to create a copy of this cast, at the current offset?")
	// return unless confirm
	
	var data = Branch.modelDataFromEvent(this.cursor().current());
	var snap = this.cursor().branch().toSnapshot();
	
	data.title = this.model().title;
	data.state = 'draft'; // not possible to follow live?
	data.privacy = 'public';
	data.type = 'lab';
	data.parent_id = this.branch().model().id;
	data.snapshot = snap;
	
	return data;
};


Space.prototype.fork = async function (o){
	var self = this;
	if(o === undefined) o = {};
	var user = await self.api().tryLogin();
	
	if (!user) {
		return window.alert("Not allowed to fork without logging in");
	};
	
	self.navigateTo(self.trunk());
	
	return self.trunk().upsertResponse().then(function(fork) {
		return self.navigateTo(fork);
	});
	return self;
};

Space.prototype.simulator = function (){
	return this.__lookup(CAST.SIMULATOR);
};

Space.prototype.setup = function (){
	var self = this;
	return self._promises.setup || (self._promises.setup = new Promise(function(resolve,reject) {
		self.setReadyState('setup');
		// return same promise every time?
		
		self._offset = 0;
		self._widgets = new Widgets(self);
		self._files = new List(self);
		self._observers = new List(self);
		self._trunk = new Trunk(self,null,self.model());
		self._cursor = new Cursor(self);
		if (false) {};
		// setting up default widgets
		
		// setting up the default widgets before loading stream
		self.setLayout(self.widgets().add(self.widgets().create('layout',{id: CAST.WORKSPACE})));
		self.setConsole(self.widgets().add(self.widgets().create('console',{id: CAST.CONSOLE})));
		// self.simulator = widgets.add widgets.create(:simulator, id: CAST.SIMULATOR)
		self.setInspector(self.widgets().add(self.widgets().create('inspector',{id: CAST.INSPECTOR})));
		self.setAgent(self.widgets().add(self.widgets().create('agent',{id: CAST.AGENT})));
		self.setFs(self.widgets().add(new FileSystemWidget(self,{id: CAST.FS,expanded: true})));
		self.setPrimaryEditor(self.widgets().add(new EditorWidget(self,{id: CAST.PRIMARY_EDITOR})));
		
		self.setSidebar(self.widgets().add(new SidebarWidget(self,{id: CAST.SIDEBAR})));
		self.setExplorerPanel(self.widgets().add(new ExplorerPanel(self,{id: CAST.EXPLORER_PANEL})));
		self.setDependenciesPanel(self.widgets().add(new DependenciesPanel(self,{id: CAST.DEPENDENCIES_PANEL})));
		self.setSlides(self.widgets().add(new SlidesWidget(self,{id: CAST.SLIDES})));
		
		// default layout for browser - weird place?
		var dims = Dimensions.build(
			{left: (1024 - 300 - 40),
			top: Math.round((768 - 300) * 0.3),
			width: 300,
			height: 300,
			vw: 1024,
			vh: 768,
			scaleX: 100,
			scaleY: 100,
			targetRef: CAST.BROWSER}
		).round();
		
		self.setBrowser(self.widgets().add(self.widgets().create('browser',{
			id: CAST.BROWSER,
			layout: dims._data,
			url: "index.html"
		})));
		
		self.setTimeline(self.trunk().timeline());
		self.view().render();
		return resolve(self);
	}));
};

/*
	Called with the whole stream etc
	*/

Space.prototype.load = function (){
	var self = this;
	return self._promises.load || (self._promises.load = new Promise(async function(resolve) {
		if (false) {};
		
		await self.setup();
		// view.render # setup takes care of this
		await self.trunk().load();
		// if $web$
		//	console.log "loaded cast",window:performance.now
		
		if (false) {};
		self.view().render();
		self.setReadyState('complete');
		// now set the timeline
		if (false) {};
		Imba.listen(Imba,'commit',self._toucher);
		
		
		if (false) {};
		
		
		return resolve(self);
	}));
};

// proxying to branch
Space.prototype.isEditing = function (){
	return this.branch().isEditing();
};
Space.prototype.isRecording = function (){
	return this.branch().isRecording();
};
Space.prototype.isWatching = function (){
	return this.branch().isWatching();
};
Space.prototype.isPlaying = function (){
	return this.branch().isPlaying();
};
Space.prototype.isLive = function (){
	return this.branch().isLive();
};
Space.prototype.isPaused = function (){
	return this.branch().isPaused();
};
Space.prototype.isAnnotating = function (){
	return this.branch().isAnnotating();
};

/*
	This should ideally first find the whole tree
	of ascendants - and then walk inwards - fetching and loading
	branches along the way
	*/

Space.prototype.resolveBranchForModel = function (model){
	var root = this._trunk.model();
	
	if (model == root) {
		return Promise.resolve(this._trunk);
	};
	
	if (model.parent_id == root.id) {
		return this._trunk.loadChildBranch(model);
	};
};

// centralized method to switch branch
Space.prototype.navigateTo = function (branch,mode){
	var self = this;
	if (branch instanceof Cast) {
		// if this other cast is unrelated?
		// should we not just change the url?
		// console.log "try to navigate to a cast",branch
		// what if target branch is not a child of trunk?
		self.log("resolve branch for model",branch);
		self._isNavigating = true;
		return self.resolveBranchForModel(branch).then(function(branch) {
			self._isNavigating = false;
			return self.navigateTo(branch,mode);
		});
	};
	
	self.log("navigate to branch",branch);
	
	if (branch != self.branch()) {
		self.api().sendTracking(tracking.TYPES.BRANCH,[branch.id()]);
		branch.enter();
		if (mode) { branch.setMode(mode) };
		
		let url = branch.model().url(self.playlist());
		// log "should set url of router",url
		if (!branch.isLocal()) {
			// replace state directly - should be silent(!)
			let rewrite = self.trunk().type() == 'lab';
			if (self.view().router().path() != url) { self.view().router().go(url,{},rewrite) };
		};
	};
	return self;
};

Space.prototype.sendStats = function (){
	var stats = this.timeline().stats();
	if (!SCON.compare(stats,this._sentStats) && stats.played != 0) {
		this._sentStats = stats;
		this._sentStatsAt = Date.now();
		this.log("sendStats",stats);
		this.api().send([MSG.VIEWSTATE,stats]);
	};
	return this;
};

// method for parsing/handing an event.
// takes care of bringing the local state
// of the space up-to-date with supplied event

Space.prototype.apply = function (action){
	return;
};

Space.prototype.revert = function (action){
	return;
};

Space.prototype.reset = function (snapshot){
	this.deserialize(snapshot,{});
	return this;
};

Space.prototype.synced_ = function (){
	return this;
};

Space.prototype.createWidget = function (pkg,extra){
	if(extra === undefined) extra = {};
	pkg.id || (pkg.id = this.widgets().getNextId());
	return this.branch().push_(ACTION.WIDGET_CREATE,[0,pkg],extra);
};

/*
	Method for adding new events to the stream
	*/

Space.prototype.__push = function (action,o){
	
	var current;
	if(o === undefined) o = {};
	/*
			if we are currently processing an event, this will
			be appended as a temporary subevent. It will also
			be automatically reverted when the parent event is reverted.
			*/
	
	if (current = this.cursor().stack()[0]) {
		return current.addSubAction(action,this.cursor());
	};
	
	// console.log "Space.__push",action
	action.LOCAL = o;
	
	/*
			If we are not currently at the end of the stream (mode == live)
			AND allowed to edit - we should automatically enter fork-mode
			*/
	
	
	let currBranch = this.cursor().branch();
	
	if (!this.cursor().canPush(action)) {
		// log "cursor cannot push",action,branch.mode,cursor.current,cursor.current.@next
		
		if (currBranch.isWatching() && currBranch.canContribute() && !this.cursor().current()._next) {
			this.log("could be able to contribute??",action);
			// show alert here? stack up the changes?
			currBranch.addLocalEvent(action,o);
			return action;
		};
		
		var branch = Branch.branchFromEvent(this.cursor().current());
		this.api().analytics().castBranch(this.id());
		// console.log "created branch!",branch
		if (branch.head()) { this.cursor().sync(branch.head()) };
		this.client().flushLocals(); // really though? - these events will be added to the fork?
		// is it not here we should really pick this up?
		branch.addLocalEvent(action,o);
		
		this.api().sendTracking(tracking.TYPES.BRANCH,[branch.id()]);
		
		// console.log "pushed the triggering event",event
		return action;
	};
	
	// should push to the current branch
	if (this.cursor().canPush(action)) {
		// if $verbose$
		// 	console.log "push",action
		this.cursor().branch().addLocalEvent(action,o);
		this._dirty = true;
	} else {
		action.discard();
		this.log("CANNOT __push",action);
	};
	return action;
};

Space.prototype.__lookup = function (ref,idx){
	if(idx === undefined) idx = 0;
	var item;
	if (ref instanceof Array) {
		item = this.widgets().get(ref[idx++]);
		return (idx == ref.length) ? item : item.__lookup(ref,idx);
	};
	return this.widgets().get(ref);
};

Space.prototype.record = function (o){
	this.log("start recording!",o);
	this.cursor().branch().record(o);
	return this;
};

// method for serializing
Space.prototype.serialize = function (o){
	if(o === undefined) o = {};
	var snapshot = {
		id: this.id(),
		index: this.stream().index()
	};
	
	var widgets = this.widgets().map(function(item) {
		if (!(o.exclude && Imba.indexOf(item.TYPE,o.exclude) >= 0)) {
			return item.serialize(o,snapshot);
		};
	});
	
	snapshot.widgets = widgets.filter(function(item) { return item; });
	return snapshot;
};

Space.prototype.deserialize = function (o,e){
	this._deserialized = true;
	o = SCON.clone(o);
	// should extract into Serializer and Deserializer
	var state = {
		event: e,
		items: [],
		stack: [this]
	};
	
	// e.SNAPSHOT = yes
	for (let i = 0, items = iter$(o.widgets), len = items.length, item; i < len; i++) {
		// hardcoded workaround
		item = items[i];
		if (item.type == 'audio') { continue; };
		Widget.load(this,item,e).deserialize(item,state);
	};
	
	for (let i = 0, items = iter$(state.items), len = items.length; i < len; i++) {
		items[i].deserialized(state);
	};
	return this;
};

Space.prototype.isDeserialized = function (){
	return !!this._deserialized;
};

Space.prototype.dirty = function (){
	return this._dirty = true;
};

Space.prototype.toRunStaticSnapshot = function (){
	var browser_, $1, $2;
	var files = [];
	
	for (let i = 0, items = iter$(this.files()), len = items.length, file; i < len; i++) {
		file = items[i];
		files.push(
			{path: file.path(),
			body: file.body(),
			blobId: file.blobId()}
		);
	};
	
	return {
		files: files,
		npmPackages: (browser_ = this.space().browser()) && browser_.npmPackages  &&  browser_.npmPackages(),
		rootPath: ($1 = this.space().browser()) && $1.rootPath  &&  $1.rootPath(),
		catchallPath: ($2 = this.space().browser()) && $2.catchallPath  &&  $2.catchallPath()
	};
};

/* tick

	*/

Space.prototype.tick = function (){
	var timeline_, branch_, pointerTracker_;
	if (this.readyState() == 'disposing') {
		return;
	};
	
	this._counters.ticks++;
	
	// let the current timeline tick.
	// it might set a new targetEvent
	// what if we have already asked for a new timeline?
	(timeline_ = this.timeline()) && timeline_.tick  &&  timeline_.tick();
	(branch_ = this.branch()) && branch_.tick  &&  branch_.tick();
	(pointerTracker_ = this.pointerTracker()) && pointerTracker_.tick  &&  pointerTracker_.tick();
	
	// synced offset now
	var offset = this._offset = this.timeline().currentOffset();
	var last = this._currentEvent;
	var targets = this.cursor().sync(this.cursor()._target,0); // max 10ms
	
	
	// check if are at a different event than before
	if (last != this.cursor().current()) {
		this._currentEvent = this.cursor().current();
		this._dirty = true;
	};
	
	if (offset != this._lastOffset) {
		this._lastOffset = offset;
		this._dirty = true;
	};
	
	if (this.api()._touches != this._lastApiTouches) {
		this._lastApiTouches = this.api()._touches;
		this._dirty = true;
	};
	
	// observers  should belong to each branch instead
	for (let i = 0, items = iter$(this.observers()), len = items.length; i < len; i++) {
		items[i].tick_(offset,this);
	};
	
	
	// this should happen in the view directly
	var mode = this.branch().mode();
	var modeDirty = false;
	
	if (mode != this._mode) {
		let prev = this._mode;
		modeDirty = true;
		this._mode = mode;
		this._dirty = true;
		this.emit('viewmode',mode,prev);
	};
	
	if (this._dirty || this.timeline().isPlaying()) { // or recording
		this._dirty = false;
		this.view().render();
	};
	
	this.emit('ticked',offset);
	
	if (false) {};
	return this;
};

// terminate should be called before disposing space
// ideally this should return false if not allowed to terminate?
Space.prototype.terminate = function (){
	
	var _tag_, timeline_;
	if (this.recording()) {
		this.recording().stop();
	};
	
	if (false) {};
	
	var dialogs = document.body.querySelectorAll((".Dialog." + this.id()));
	
	for (let i = 0, items = iter$(dialogs), len = items.length; i < len; i++) {
		(_tag_ = items[i]._tag) && _tag_.terminate  &&  _tag_.terminate();
	};
	
	(timeline_ = this.timeline()) && timeline_.pause  &&  timeline_.pause();
	return this;
};

/*
	Should teardown and free the memory of everything related to this cast
	*/

Space.prototype.dispose = function (){
	if (this.isDisposing()) {
		return this;
	};
	
	this.setReadyState('disposing');
	this.emit('dispose');
	Imba.unlisten(Imba,'commit',this._toucher);
	// @socket?.close
	
	this.tick = function() { return; };
	
	for (let i = 0, items = iter$(this.widgets()), len = items.length; i < len; i++) {
		items[i].dispose();
	};
	
	this._trunk && this._trunk.dispose  &&  this._trunk.dispose();
	this._view && this._view.dispose  &&  this._view.dispose();
	this._actions && this._actions.dispose  &&  this._actions.dispose();
	this._widgets = null;
	
	this.emit('disposed');
	
	this.__listeners__ = null;
	
	if (false) {};
	return this;
};

Space.prototype.isDisposing = function (){
	return this.readyState() == 'disposing';
};

Space.prototype.isSyncing = function (){
	return this.cursor().syncing();
};

Space.prototype.view = function (){
	let $ = this.$$ || (this.$$ = {});
	return this._view || (this._view = this._view||_1(SpaceView,this).flag('view')).setData(this).end();
};

Space.prototype.pointer = function (){
	return this._view ? this._view._pointer : null;
};

Space.prototype.vw = function (){
	return this.view().box().width;
};

Space.prototype.vh = function (){
	return this.view().box().height;
};
