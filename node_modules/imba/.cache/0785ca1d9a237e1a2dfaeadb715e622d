function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var SCON = require('../protocol').SCON;
var StreamAction$ = require('./StreamAction'), StreamAction = StreamAction$.StreamAction, TextAction = StreamAction$.TextAction, TextEdit = StreamAction$.TextEdit, TextInsert = StreamAction$.TextInsert, TextDelete = StreamAction$.TextDelete, TextSelection = StreamAction$.TextSelection, RejectAction = StreamAction$.RejectAction;

function Stash(stream){
	this._stream = stream;
	this._actions = [];
	this._conflict = false;
	this._counter = 1;
	this._batchnr = 1;
	this;
};

exports.Stash = Stash; // export class 
Stash.prototype.stream = function(v){ return this._stream; }
Stash.prototype.setStream = function(v){ this._stream = v; return this; };

Stash.prototype.cursor = function (){
	return this._stream.space().cursor();
};

Stash.prototype.push = function (action,meta){
	// mark some sort of id?
	// if action isa TextEdit
	if (action instanceof TextAction) {
		let prev = this.filter(function(_0) { return (_0 instanceof TextAction) && _0.target() == action.target(); }).pop();
		
		if (prev && prev._freezeStash) {
			console.warn("rejecting this action");
			action.discard();
			return null;
		};
		
		if (prev && prev.meta().batch) {
			meta.batch = prev.meta().batch;
		} else {
			meta.batch = this._batchnr++;
			// if action isa TextSelection
			// console.warn "must wait to sync"
			// prev.@freezeStash = Date.now
			// action.discard
			// should automatically make editor readOnly
			// this is committed by default - no?
			// return null
		};
	};
	
	meta.id = this._counter++;
	meta.index = len$(this.stream().actions());
	meta.stashed = this._actions.length;
	action._stream = this._stream;
	action._prev = this._tail;
	if (this._tail) { this._tail._next = action };
	this._actions.push(this._tail = action);
	action.commitWithCursor(this.cursor());
	// action.space.cursor.commitOne(action)
	return action;
};

Stash.prototype.pop = function (){
	let action = this._actions.pop();
	if (action) { this._tail = action._prev };
	return action;
};

Stash.prototype.len = function (){
	return this._actions.length;
};

Stash.prototype.actionsOfType = function (type){
	return this._actions.filter(function(action) { return action instanceof type; });
};

Stash.prototype.filter = function (fn){
	return this._actions.filter(fn);
};

Stash.prototype.rollback = function (){
	var action;while (action = this.pop()){
		action.revertWithCursor(this.cursor());
	};
	return this;
};

Stash.prototype.rejectBatch = function (nr){
	let actions = this.filter(function(_0) { return _0.meta().batch == nr && !_0._rejected; });
	
	var action;while (action = actions.pop()){
		// remove from actions
		// @actions.splice(@actions.indexOf(action),1)
		action.revertWithCursor(this.cursor());
		action._rejected = true;
	};
	
	return this;
};

Stash.prototype.compare = function (a,b){
	let ap = a._params;
	let bp = b._params;
	for (let i = 0, items = iter$(ap), len = items.length, param; i < len; i++) {
		param = items[i];
		if (typeof param != 'object') {
			if (bp[i] != param) { return false };
		};
		if (!SCON.compare(param,bp[i])) { return false };
	};
	return true;
};

Stash.prototype.rebase = function (actions,block){
	console.group("rebase");
	
	let i = len$(actions);
	while (i > 0){
		let action = actions[--i];
		action.revertWithCursor(this.cursor());
	};
	
	block(actions);
	
	while (i < len$(actions)){
		let action = actions[i++];
		action.rebaseWithCursor(this.cursor());
		action.commitWithCursor(this.cursor());
	};
	
	console.groupEnd("rebase");
	return this;
};

Stash.prototype.merge = function (remote){
	var self = this, next;
	if (next = self._actions[0]) {
		let mine = remote.agent() == next.agent();
		
		if (!mine && (remote instanceof TextEdit)) {
			// console.log "found remote TextEdit"
			let edits = self._actions.filter(function(_0) { return (_0 instanceof TextEdit) && _0.target() == remote.target(); });
			
			if (len$(edits)) {
				self.rebase(edits,function() { return self.cursor().sync(remote); });
			};
		};
		
		if (mine) {
			// only supposed to rollback certain items?
			if (remote instanceof RejectAction) {
				console.warn("rejecting",next.meta().batch,next._params,next);
				// we need to revert the whole stack
				self.rejectBatch(next.meta().batch);
			} else if (!self.compare(remote,next)) {
				console.warn("action was transformed by host",next._params,'->',remote._params);
				self.rollback();
				return self;
			} else {
				remote._stashed = next;
			};
			self._actions.shift();
		};
	};
	// we should commit it no matter what - only 
	return self;
};
