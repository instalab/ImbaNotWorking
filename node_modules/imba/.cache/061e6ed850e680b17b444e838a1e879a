function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');
var Resource$ = require('../store/Resource'), Resource = Resource$.Resource, MASK = Resource$.MASK, ACCESS = Resource$.ACCESS;
var StreamBuffer = require('../scrimba/core/StreamBuffer').StreamBuffer;

var protocol$ = require('../scrimba/protocol'), MSG = protocol$.MSG, VERSION = protocol$.VERSION;

if (true) {
	var rdb = require("../server/db").rdb;
};

function Cast(){ return Resource.apply(this,arguments) };

Imba.subclass(Cast,Resource);
exports.Cast = Cast; // export class 
Cast._serializer = {
	featured_at: MASK.ALWAYS,
	archived_at: MASK.ALWAYS,
	search_vector: MASK.NEVER
};

Cast.prototype.dependsOn = function (){
	return [this.owner(),(this.type == 'fork') ? this.parent() : null];
};

Cast.prototype.isPublic = function (){
	return !this.archived_at && this.privacy == 'public';
};

Cast.prototype.isPublished = function (){
	return !!this.published_at;
};

Cast.prototype.isTutorial = function (){
	return this.type == 'tutorial';
};

Cast.prototype.isDraft = function (){
	return this.isTutorial() && !this.published_at;
};

Cast.prototype.isFork = function (){
	return this.type == 'fork';
};

Cast.prototype.isNote = function (){
	return this.type == 'note';
};

Cast.prototype.isForkable = function (){
	return this.spiv == VERSION && this.type != 'fork';
};

Cast.prototype.hasMember = function (uid){
	return this.uid == uid || (this.members && this.members.indexOf(uid) >= 0);
};

Cast.prototype.permissions = function (user){
	if (user && (this.hasMember(user.id) || user.isMod())) {
		return ACCESS.ALL;
	} else if (this.privacy == 'private') {
		return ACCESS.NONE;
	} else {
		return ACCESS.READ;
	};
};

Cast.prototype.owner = function (){
	return this.db().get(this.uid);
};

Cast.prototype.parent = function (){
	return this.parent_id ? this.db().get(this.parent_id) : null;
};

Cast.prototype.group = function (){
	return this.gid ? this.db().get(this.gid) : null;
};

Cast.prototype.playlist = function (){
	return this.pid ? this.db().get(this.pid) : null;
};

Cast.prototype.viewing = function (uid){
	if (false && uid == null) {
		uid = this.db().api().uid();
	};
	
	if (!uid) { return };
	let key = ("y" + (this.id) + "-" + uid);
	return this.db().viewings().has(key) ? this.db().viewings().get(key) : null;
};

Cast.prototype.trunk = function (){
	// should it not be basically everything but tutorials,labs,template?
	return (this.isFork() || this.isNote()) ? this.parent() : this;
};

Cast.prototype.branches = function (){
	var self = this;
	return self._cache.branches || (self._cache.branches = self.db().casts().sel(function(c) { return (c.parent_id == self.id) && !c.archived_at; }));
};

Cast.prototype.notes = function (){
	return this._cache.notes || (this._cache.notes = this.branches().sel(function(c) { return c.type == 'note'; }));
};

Cast.prototype.forks = function (){
	return this._cache.forks || (this._cache.forks = this.branches().sel(function(c) { return c.type == 'fork'; }));
};

Cast.prototype.messages = function (){
	var self = this;
	return self._cache.messages || (self._cache.messages = self.db().messages().sel({sort: '-ts'},function(c) { return c.cid == self.id; }));
};

Cast.prototype.questions = function (){
	var self = this;
	return self._cache.questions || (self._cache.questions = self.db().messages().sel({sort: '-ts'},function(c) { return c.cid == self.id && c.parent_id == null; }));
};

Cast.prototype.topic = function (){
	return this.topic_id && this.db().get(this.topic_id);
};

Cast.prototype.feature = function (){
	return this.update({featured_at: new Date()});
};

Cast.prototype.unfeature = function (){
	return this.update({featured_at: null});
};

Cast.prototype.destroy = function (){
	return this.update({archived_at: new Date()});
};

Cast.prototype.stream = function (){
	return this._cache.stream || (this._cache.stream = new StreamBuffer(null,this));
};

Cast.prototype.buffer = function (){
	return this.stream();
};

Cast.prototype.fulltext = function (){
	return this._cache.fulltext || (this._cache.fulltext = ('' + this.title + this.description).toLowerCase());
};

Cast.prototype.url = function (playlist){
	if (playlist) {
		return ("/p/" + (playlist.id) + "/" + (this.id));
	} else {
		return ("/c/" + (this.id));
	};
};

// handle packet delegated to cast
Cast.prototype.onpacket = function (packet){
	
	switch (packet.CODE) {
		case MSG.STREAMAPPEND: {
			var offset = packet[2];
			// console.log "MSG.STREAMAPPEND",offset,packet.payload:byteLength
			// need to signal that this comes from a trusted / remote source
			var result = this.buffer().add(packet.payload(),offset);
			
			if (result instanceof Error) {
				console.log("missingrange",result.start,result.end);
				packet.reply([MSG.STREAMGETRANGE,this.id,result.start,result.end]);
			};
			break;
		}
		case MSG.STREAMTRIM: {
			let offset = packet[2];
			console.warn("streamtrim!",packet,offset);
			result = this.buffer().trim(offset);
			
			if (packet.payload() && packet.payload().length > 0) {
				this.buffer().add(packet.payload(),offset);
			};
			break;
		}
		case MSG.STREAMRANGE: {
			offset = packet[2];
			result = this.buffer().add(packet.payload(),offset);
			break;
		}
	};
	return this;
};

Cast.prototype.integrity = function (){
	return this._cache.integrity || (this._cache.integrity = {});
};

Cast.prototype.checkIntegrity = async function (){
	var integrity = await this._db.api().rpc('castCheckIntegrity',[this.id]);
	return this;
};

Cast.prototype.channelRef = function (){
	return ("" + (this.id) + "." + (this.v) + (this.buffer().FETCHING ? '' : ('.' + len$(this.buffer()))));
};

Cast.prototype.fetchStreamBuffer = function (api,byteOffset){
	var self = this;
	if(byteOffset === undefined) byteOffset = 0;
	return new Promise(async function(resolve,reject) {
		self.buffer().FETCHING = true;
		var action;
		if (true) {
			action = rdb.getrangeBuffer(("" + (self.id) + ":stream3"),byteOffset,-1);
		};
		
		var chunk = await action;
		// if $web$
		//	console.log "returned from fetchStreamBuffer",chunk
		// var chunk = await api.rpc(:streamRead,[self:id,byteOffset,-1], type: 'arraybuffer', raw: yes)
		var ary = new Uint8Array(chunk);
		if (ary.length > 1) {
			self.buffer().add(ary,byteOffset);
			if (false) {};
		};
		self.buffer().FETCHING = false;
		return resolve(self.buffer());
	});
};

Cast.prototype.open = function (source){
	if(source === undefined) source = null;
	if (App.router().path() != this.url()) {
		return App.router().go(this.url());
	};
};
