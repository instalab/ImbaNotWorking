var Imba = require('imba');
var MSG = require('../scrimba/protocol').MSG;
var Resource = require('../store/Resource').Resource;

function WriteStream(file,api){
	this._file = file;
	this._chunks = [];
	this._size = 0;
	this._api = api;
	this._blob = null;
	this;
};

WriteStream.prototype.write = function (chunk){
	this._chunks.push(chunk);
	this._size += chunk.size;
	return this;
};

WriteStream.prototype.blob = function (){
	return this._blob;
};

WriteStream.prototype.close = function (blob){
	this._file._blob = this._blob = (blob || (blob = new Blob(this._chunks,{type: this._file.type})));
	// not saving it locally now
	// var key = @file:id + "_body"
	// var res = await @file.@db.cacheSet(key,{body: blob})
	return this._file;
};

// mo669-842ab13bd6da
function File(){ return Resource.apply(this,arguments) };

Imba.subclass(File,Resource);
exports.File = File; // export class 
File.prototype.createWriteStream = function (api){
	return new WriteStream(this,api);
};

File.prototype.upload = function (state){
	// first save locally
	var self = this;
	if(state === undefined) state = {};
	return self._cache.uploader || (self._cache.uploader = new Promise(async function(resolve,reject) {
		var res = await self.save();
		console.log("saved to server");
		var blob = await self.fetchLocalBlob();
		var req = new XMLHttpRequest();
		
		req.upload.addEventListener('progress',function(e) {
			var loaded = e.loaded;
			var tot = e.total;
			var progress = loaded / tot;
			state.loaded = e.loaded;
			state.total = e.total;
			state.progress = progress;
			
			return console.log('progress',e,req.upload.loaded,req.upload.total,loaded,tot,loaded / tot);
		});
		
		req.onload = function(e) {
			console.log("request finished uploading!!",e,req.response);
			return resolve(req.response);
		};
		
		req.open('POST',("/upload/" + (self.id)));
		return req.send(blob);
	}));
};

File.prototype.fetchLocalBlob = async function (){
	if (this._blob) { return Promise.resolve(this._blob) };
	var res = await this._db.cacheGet(this.id + "_body");
	return res ? res.body : null;
};

File.prototype.fetchAsArrayBuffer = function (path){
	var self = this;
	if(path === undefined) path = null;
	return self._fetcher || (self._fetcher = new Promise(async function(resolve) {
		var localBuffer = await self.fetchLocalBlob();
		
		if (localBuffer) {
			var reader = new FileReader();
			reader.onloadend = function(e) {
				self._arraybuffer = e.target.result;
				return resolve(self._arraybuffer);
			};
			return reader.readAsArrayBuffer(localBuffer);
		} else {
			var xhr = new XMLHttpRequest();
			xhr.open('GET',path || ("/cdn/" + (self.id)),true);
			xhr.responseType = 'arraybuffer';
			xhr.onload = function() {
				return resolve(self._arraybuffer = xhr.response);
			};
			return xhr.send();
		};
	}));
};

File.prototype.repair = async function (){
	var integrity = await this._db.api().rpc('checkIntegrity',[this.id]);
	// console.log "integrity from server!",integrity
	if (integrity.realSize == 0) {
		var localBlob = await this.fetchLocalBlob();
		if (localBlob) {
			console.log("found local file! - try to upload");
			return this.upload();
		} else {
			return {error: "file not found"};
		};
	} else {
		return this;
	};
};

if (true) {
	var fs = require('fs');
	File.prototype.systemPath = function (){
		return global.FILES_DIR + '/' + this.id;
	};
	
	File.prototype.checkIntegrity = function (){
		var self = this;
		console.log("system path is",self.systemPath());
		
		var health = {
			type: 'file',
			fid: self.id,
			realSize: 0
		};
		
		return new Promise(async function(resolve,reject) {
			await self.fetch(); // ensure we have latest version
			health.size = self.size;
			return fs.stat(self.systemPath(),function(err,stat) {
				if (err) {
					health.error = 404;
				};
				health.realSize = stat && stat.size || 0;
				return resolve(health);
			});
		});
		// change status / update object in db?
	};
};

