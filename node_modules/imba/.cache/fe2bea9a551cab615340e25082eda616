function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
/*

The format for storing events is a highly minified msgpack array in
the following format:

[OFFSET,AGENT,TARGET,TYPE, [PARAM1,PARAM2,...] ]

1 OFFSET  Milliseconds since the previous event in the stream
2 AGENT   Session id of the actor responsible for the event
3 TARGET  Widget/File/Object target of the event
4 TYPE    An integer event code
5 PARAMS  Supplied to the event

Whenever an event has the same AGENT,TARGET,TYPE as the previous event
it will be compacted to [OFFSET,[PARAM1,PARAM2,...]]

Every type of widget can define their own custom event-codes from int 60 and up
Every widget shares event-codes 30-49

Event codes >= 100 will be trigger append

*/


var VERSION = exports.VERSION = 2;
var SPIV = exports.SPIV = 2;

/* MSG

Messages can be sent to and from the socket server with the following format:

[MSGCODE,PARAMS(Array),MSGREF,TIME++]

*/

var MSG = exports.MSG = {
	AUTH: 1,
	PUSH: 2, // [push,index,EVENT,state,uniqref]
	STATS: 3,
	PING: 4,
	PONG: 5,
	CHANGE: 6, // [change,index,NEW EVENT]
	STATE: 7,
	PREPARE: 8,
	RECSTART: 9,
	RECSTOP: 10,
	CALLBACK: 11,
	PUBLISH: 12,
	CONNECTED: 13,
	FORK: 15,
	AUTOSAVE: 16,
	RECREVERT: 17,
	ROLLBACK: 18, // [index]
	JOIN: 20,
	LEAVE: 21,
	SYNC: 22,
	SYNCED: 23,
	ERROR: 24,
	ALERT: 25,
	SID: 26,
	TRACKING: 27,
	VIEWSTATE: 28,
	// STREAM_REQUEST: 100 # [CODE,CID,FROM_BYTE]
	
	// all message codes from 100 > are directly mapping to a model
	STREAMAPPEND: 100, // [CODE,CID,OFFSET](BYTES)
	STREAMSTATE: 101, // [CODE,CID,LENGTH]
	STREAMRANGE: 102, // [CODE,CID,OFFSET])(BYTES)
	STREAMGETRANGE: 103, // [CODE,CID,START,END]
	STREAMTRIM: 104, // [CODE,STREAMID(with version?),END]
	STREAMERROR: 105,
	STREAMFLATTEN: 106,
	CASTLOCK: 110,
	
	OK: 200,
	UNAUTHORIZED: 401,
	ERR_NOTFOUND: 404,
	REQUEST_TIMEOUT: 408,
	ERR_PAYLOAD_TOO_LARGE: 413,
	ERR_LOCKED: 423,
	ERR_OUT_OF_RANGE: 416,
	
	RELOAD_STYLES: 1000,
	UPDATES_AVAILABLE: 1001
};

// Action classes can register in this map
// as handlers for specific types
var ACTION_MAP = exports.ACTION_MAP = {};

var WIDGET_TYPE_MAP = exports.WIDGET_TYPE_MAP = {};

var GRANT = exports.GRANT = {
	SHOW: 1,
	EDIT: 2
};

var DIRTY = exports.DIRTY = {
	SIZE: 1,
	LAYOUT: 2
};

// global actions
var ACTION = exports.ACTION = {};

if (false) {};

/* WIDGET
*/

var WIDGET = exports.WIDGET = {
	CREATE: 15,
	FLAG: 17,
	UNFLAG: 18,
	UPDATE: 20,
	APPEND: 21, // Appending nested events for widget [offset,[events]]
	CONFIGURE: 25,
	BATCH: 27,
	LAYOUT: 28
};

WIDGET.FLAGS = {
	Created: 1,
	Enabled: 2,
	Deleted: 4
};

var CAST = exports.CAST = Object.create(WIDGET);
var FILE = exports.FILE = Object.create(WIDGET);
var LAYOUT = exports.LAYOUT = Object.create(WIDGET);
var AGENT = exports.AGENT = Object.create(WIDGET);
var POINTER = exports.POINTER = Object.create(WIDGET);
var SIMULATOR = exports.SIMULATOR = Object.create(WIDGET);
var CONSOLE = exports.CONSOLE = Object.create(WIDGET);
var STREAM = exports.STREAM = {};
var DOM = exports.DOM = {};



// WARN only append - never change!
var KEYS = exports.KEYS = ACTION.KEY_TYPES = [
	'state', // 0
	'pointer', // 1
	'layout', // 2
	'selection', // 3
	'file', // 4
	'focus', // 5
	'hover',
	'active',
	'enabled',
	'visible',
	'busy',
	'fontSize',
	'width', // 2
	'height', // 3
	'resizing',
	'baseStyle',
	'area',
	'externaljs',
	'colspan',
	'hoverEntry',
	'viewbox', // legacy
	'class',
	'style',
	'title',
	'log',
	'info',
	'warn',
	'error',
	'alert',
	'meta',
	'function',
	'element',
	'instance',
	'udef',
	'more',
	'array',
	'div',
	'p',
	'h1',
	'h2',
	'h3',
	'h4',
	'h5',
	'h6',
	'span',
	'b',
	'i',
	'u',
	'get',
	'post',
	'put',
	'options',
	'left',
	'top',
	'contentLeft',
	'contentTop',
	'contentWidth',
	'contentheight',
	'scrollTop',
	'scrollLeft',
	'scrollWidth',
	'scrollHeight',
	'lineHeight',
	'maxWidth',
	'maxHeight'
];

for (let i = 0, items = iter$(KEYS), len = items.length; i < len; i++) {
	KEYS[items[i].toUpperCase()] = i;
};

// SCRIMBA OBJECT NOTATION
var SCON = exports.SCON = {
	parsedURICache: {},
	clone: function(item) { return JSON.parse(JSON.stringify(item)); },
	compare: function(a,b) { return JSON.stringify(a) == JSON.stringify(b); },
	keyToRef: function(k) { return (KEYS.indexOf(k) >= 0) ? KEYS.indexOf(k) : k; },
	refToKey: function(k) { return (typeof k == 'number') ? ((KEYS[k] || k)) : k; },
	paths: {},
	strToPath: function(str) {
		if (this[str]) { return this[str] };
		let parts = str.split(".");
		parts = parts.map(function(part) {
			if ((/^\-?\d+$/).test(part)) {
				return parseInt(part);
			};
			return part;
		});
		return this[str] = (len$(parts) == 1) ? parts[0] : parts;
	},
	
	pathToStr: function(path) {
		return (path instanceof Array) ? path.join(".") : String(path);
	},
	
	decodeURI: function(str) {
		var ary;
		if (!((typeof str=='string'||str instanceof String))) {
			return null;
		};
		
		let cached = this.parsedURICache[str];
		
		if (cached) {
			return cached;
		};
		
		let m = str.match(/(scrimba\:\/\/)?(c[\w\-]+)(\@(\d+))?/);
		let obj = {
			cid: m[2],
			index: m[4]
		};
		var ary = iter$(str.substr(m[0].length).split("#"));let path = ary[0],sel = ary[1];
		
		obj.path = path;
		if (sel) {
			obj.rangeString = sel;
			obj.selection = this.decodeRangeString(sel);
		};
		
		return this.parsedURICache[str] = obj;
	},
	
	decodeRangeString: function(str) {
		let m = str.match(/L(\d+)(\:(\d+))?(-L?(\d+)(\:(\d+))?)?/).map(function(part) {
			return part ? parseInt(part) : null;
		});
		
		let l0 = m[1],c0 = m[3],l1 = m[5],c1 = m[7];
		
		// the 5th argument is a boolean that declares whether range is whole line
		
		if (!l1) {
			// a single 
			return [l0,c0 || 1,l0,c0 || 1,!c0];
		};
		
		return [l0,c0 || 1,l1,c1 || 1,!c0 && !c1];
	}
};



/* LCRange
[LINE, COL, COL_MOVE, LINE_MOVE]
*/

function LCRange(){ };

exports.LCRange = LCRange; // export class 
LCRange.lclcToArray = function (l1,c1,l2,c2){
	if (l2 == l1 && c2 == c1 || (l2 == null && c2 == null)) {
		return [l1,c1];
	} else if (l2 == l1) {
		return [l1,c1,c2 - c1];
	} else {
		return [l1,c1,c2 - c1,l2 - l1];
	};
};

LCRange.rangeToArray = function (range){
	var ary = [
		range.startLineNumber,
		range.startColumn,
		range.endColumn - range.startColumn,
		range.endLineNumber - range.startLineNumber
	];
	if (ary[3] == 0) {
		ary.pop();
		if (ary[2] == 0) { ary.pop() };
	};
	
	return ary;
	// return ary[2] == ary[3] == 0 ? ary.slice(0,2) : ary
};

LCRange.selectionToArray = function (val){
	var ary = [
		val.selectionStartLineNumber,
		val.selectionStartColumn,
		val.positionColumn - val.selectionStartColumn,
		val.positionLineNumber - val.selectionStartLineNumber
	];
	
	if (ary[3] == 0) {
		ary.pop();
		if (ary[2] == 0) { ary.pop() };
	};
	
	return ary;
	// return ary[2] == ary[3] == 0 ? ary.slice(0,2) : ary
};

ACTION.SET = 1;
ACTION.PATCH = 2;
ACTION.WIDGET_CREATE = WIDGET.CREATE = 3;

/* LCINSERT

[ int_TARGETID, int_LINE, int_COL, str_TEXT, sel_CARET? ]
Dropping CARET if CARET == [ LINE, COL + TEXT.length ]
*/

ACTION.LCINSERT = FILE.LCINSERT = 4;

/* LCDELETE
[ int_TARGETID, int_LINE, int_COL, int_LINEDELTA, int_COLDELTA, sel_CARET?]
Dropping CARET if CARET == [LINE,COL]
*/

ACTION.LCDELETE = FILE.LCDELETE = 5;

ACTION.LCEDIT = FILE.LCEDIT = 6;
ACTION.LCSELECTION = FILE.LCSELECTION = 7;

/* LAYOUT
[target: WidgetRef, ]
*/

ACTION.LAYOUT = 8;
ACTION.BROWSER_LAYOUT = 9;
ACTION.NODE_LAYOUT = 10;

ACTION.POINTER_UPDATE = 12;

ACTION.CONSOLE_LOG = CONSOLE.LOG = 16;
ACTION.CONSOLE_CLEAR = CONSOLE.CLEAR = 17;
ACTION.CONSOLE_VAL_EXPAND = CONSOLE.VAL_EXPAND = 18;

ACTION.DOM_MUTATE = DOM.MUTATE = 21;
ACTION.DOM_EVENT = DOM.EVENT = 22;
ACTION.DOM_SCROLL = DOM.SCROLL = 23;
ACTION.DOM_SELECTION = DOM.SELECTION = 24; // [anchor: NodeRef, anchorOffset: Index, focusOffset: Index, focusNode: NodeRef]
ACTION.DOM_FOCUSIN = DOM.FOCUSIN = 25; // [NodeRef]
ACTION.DOM_HOVERIN = DOM.HOVERIN = 26; // [NodeRef]
ACTION.DOM_ACTIVEIN = DOM.ACTIVEIN = 27; // [NodeRef]

ACTION.PAGE_LOAD = 28;
ACTION.PAGE_LOADED = 29;
ACTION.PAGE_LOG = 30;
ACTION.PAGE_REQUEST = 31;

ACTION.RECSTART = CAST.RECSTART = 33;
ACTION.RECSTOP = CAST.RECSTOP = 34;
ACTION.PING = CAST.PING = 35;
ACTION.SNAPSHOT = CAST.SNAPSHOT = 36; // [snapshot]
ACTION.FORK = CAST.FORK = 37; // [parent_id,parent_index,snapshot]
ACTION.BRANCH = CAST.BRANCH = 38;

ACTION.TRIM = 39;

ACTION.PAGE_UNLOAD = 50;

ACTION.LOCK = 100; // [socketId, userId, serverTime, agentTime]
ACTION.UNLOCK = 101;


ACTION.FS_RENAME = 110;
ACTION.FS_REMOVE = 111;
ACTION.FS_MOVE = 112;

ACTION.WIDGET_FLAG = WIDGET.FLAG = 126; // deprecated
ACTION.WIDGET_UNFLAG = WIDGET.UNFLAG = 127; // deprecated
ACTION.WIDGET_APPEND = WIDGET.APPEND = 128; // deprecated

ACTION.SIM_BUILD = SIMULATOR.BUILD = 200; // deprecated
ACTION.SIM_RESULT = SIMULATOR.RESULT = 201; // deprecated
ACTION.DOM_FOCUSOUT = DOM.FOCUSOUT = 202; // [path]
ACTION.DOM_HOVEROUT = DOM.HOVEROUT = 203;
ACTION.DOM_ACTIVEOUT = DOM.ACTIVEOUT = 204;
ACTION.DOM_INSERT = DOM.INSERT = 206;
ACTION.DOM_RESET = DOM.RESET = 207; // dom reset deprecated

ACTION.LCSCROLL = FILE.SCROLL = 210; // deprecated


// subcomponents
CAST.WORKSPACE = -1;
CAST.CONSOLE = -2;
CAST.SIMULATOR = -3;
CAST.INSPECTOR = -4;
CAST.AGENT = -5;
CAST.STREAM = -6;
CAST.BROWSER = -7;
CAST.FS = -8;
CAST.PRIMARY_EDITOR = -9;
CAST.EXPLORER_PANEL = -10;
CAST.DEPENDENCIES_PANEL = -11;
CAST.SLIDES = -12;
CAST.SIDEBAR = -13;

STREAM.TRIM = 50;


CONSOLE.LOG_TYPES = {
	LOG: 60,
	WARN: 61,
	ERROR: 62,
	RESULT: 63,
	INFO: 71,
	META: 72,
	META_ERROR: 73
};

CONSOLE.TYPES = {
	MARKER: '~',
	NULL: 1,
	UNDEFINED: 2,
	ELEMENT: 3,
	FUNCTION: 4,
	INSTANCE: 5,
	ERROR: 6
};

POINTER.STATEFLAGS = {
	LEFT_BUTTON: 1, // : Left button
	RIGHT_BUTTON: 2, // : Right button
	MIDDLE_BUTTON: 4, // : Wheel button or middle button
	HIDDEN: 8,
	TRANSITION: 16,
	HIGHLIGHT: 32,
	CTRL: 64,
	ALT: 128,
	SHIFT: 256
};

POINTER.FLAGS = {
	Created: 1,
	Enabled: 2,
	Deleted: 4,
	Visible: 8
};

POINTER.STYLES = {
	DEFAULT: 0,
	ROW: 1,
	SMALL_FLIPPED: 2
};


var POINTERMASK = exports.POINTERMASK = {
	LEFT_BUTTON: 1, // : Left button
	RIGHT_BUTTON: 2, // : Right button
	MIDDLE_BUTTON: 4 // : Wheel button or middle button
};

var LAYOUTMASK = exports.LAYOUTMASK = {
	SCALED: 1,
	BOUNDLESS: 2
};
/* FILE
*/


DOM.MUTS = {
	RESET: 1, // []
	INSERT: 2, // [parent: NodeRef, insertAt: Index, node: Node]
	// INSERT is deprecated, but still implemented in player
	
	REMOVE: 3, // [node: NodeRef]
	INIT: 4, // [body: Node]
	
	INSERT_AFTER: 5, // deprecated
	INSERT_ADJACENT: 6, // [rel: NodeRef, pos: Pos, node: Node]
	
	SETATTR: 10, // [node: NodeRef, key: KeySymbol, value: string]
	SETPROP: 11, // [node: NodeRef, key: KeySymbol, value: string]
	SETTEXT: 12, // [node: NodeRef, content: TextPatch]
	
	// Node:
	// - number: exisiting node index
	// - string: serialized node (can be multiple elements)
	// - {text: ""}: plain text
	// - array: nested
	
	// KeySymbol:
	// - string: literal key
	// - integer: entry in M.NAME_MAP
	
	POS: ['beforebegin','afterbegin','beforeend','afterend'],
	
	NAMES: {
		class: 1,
		value: 2,
		checked: 3,
		style: 4
	},
	
	NAME_MAP: {
		1: 'class',
		2: 'value',
		3: 'checked',
		4: 'style'
	}
};


var msgpack = require('msgpack-lite');
var Bufferish = exports.Bufferish = msgpack.Decoder.prototype.bufferish;

function Packet(data,socket){
	this._socket = socket;
	
	if (true) {
		// @data = Buffer.new(data,'binary')
		this._data = Buffer.from(data);
	};
	
	var decoder = new (msgpack.Decoder)();
	decoder.write(this._data);
	this._params = decoder.fetch();
	
	if ((typeof this._params=='number'||this._params instanceof Number)) {
		// console.log "found packet-reference!!!"
		let offset = decoder.offset;
		this._ref = this._params;
		this._data = (false ? true : this._data.slice(offset));
		this._params = decoder.fetch();
		this._offset = decoder.offset - offset;
	} else {
		this._offset = decoder.offset;
	};
	
	this.CODE = this._params[0];
	this[1] = this._params[1];
	this[2] = this._params[2];
	this[3] = this._params[3];
	this[4] = this._params[4];
	this;
};

exports.Packet = Packet; // export class 
Packet.prototype.params = function(v){ return this._params; }
Packet.prototype.setParams = function(v){ this._params = v; return this; };
Packet.prototype.socket = function(v){ return this._socket; }
Packet.prototype.setSocket = function(v){ this._socket = v; return this; };
Packet.prototype.data = function(v){ return this._data; }
Packet.prototype.setData = function(v){ this._data = v; return this; };

Packet.prototype.payloadSize = function (){
	return this._data.byteLength - this._offset;
};

Packet.prototype.retain = function (){
	// packets are inited with data from an arraybuffer
	// that is reused across requests. If we do anything
	// asynchronous with the data, we need to retain it
	if (true) {
		this._data = Buffer.from(this._data);
		this._payload = null;
	};
	return this;
};

Packet.prototype.payload = function (){
	if (true) {
		return this._payload || (this._payload = this._data.slice(this._offset));
	};
};

Packet.prototype.reply = function (msg){
	if (this._ref) {
		msg = Bufferish.concat([msgpack.encode(this._ref),msg]);
	};
	this.socket().send(msg);
	return this;
};

Packet.prototype.sid = function (){
	return this.socket().sid;
};

