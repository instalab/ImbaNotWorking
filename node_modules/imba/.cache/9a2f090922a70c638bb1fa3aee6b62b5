function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };

var DOM = require('../../protocol').DOM;
var M = DOM.MUTS;

var patchString = require('./differ').patchString;

var parentForNodeType = {
	head: 'html',
	body: 'html',
	thead: 'table',
	tbody: 'table',
	tr: 'tbody',
	td: 'tr',
	th: 'td',
	option: 'select'
};

function DOMPlayer(owner,options){
	if(options === undefined) options = {};
	this._owner = owner;
	this._listener = null;
	this._options = options;
	this._queue = [];
	
	if (false) {};
	this;
};

exports.DOMPlayer = DOMPlayer; // export class 
DOMPlayer.prototype.root = function(v){ return this._root; }
DOMPlayer.prototype.setRoot = function(v){ this._root = v; return this; };

DOMPlayer.prototype.__focusNode = {watch: 'focusNodeDidSet',name: 'focusNode'};
DOMPlayer.prototype.focusNode = function(v){ return this._focusNode; }
DOMPlayer.prototype.setFocusNode = function(v){
	var a = this.focusNode();
	if(v != a) { this._focusNode = v; }
	if(v != a) { this.focusNodeDidSet && this.focusNodeDidSet(v,a,this.__focusNode) }
	return this;
};
DOMPlayer.prototype.__hoverNode = {watch: 'hoverNodeDidSet',name: 'hoverNode'};
DOMPlayer.prototype.hoverNode = function(v){ return this._hoverNode; }
DOMPlayer.prototype.setHoverNode = function(v){
	var a = this.hoverNode();
	if(v != a) { this._hoverNode = v; }
	if(v != a) { this.hoverNodeDidSet && this.hoverNodeDidSet(v,a,this.__hoverNode) }
	return this;
};
DOMPlayer.prototype.__activeNode = {watch: 'activeNodeDidSet',name: 'activeNode'};
DOMPlayer.prototype.activeNode = function(v){ return this._activeNode; }
DOMPlayer.prototype.setActiveNode = function(v){
	var a = this.activeNode();
	if(v != a) { this._activeNode = v; }
	if(v != a) { this.activeNodeDidSet && this.activeNodeDidSet(v,a,this.__activeNode) }
	return this;
};
DOMPlayer.prototype.scrollNode = function(v){ return this._scrollNode; }
DOMPlayer.prototype.setScrollNode = function(v){ this._scrollNode = v; return this; };
DOMPlayer.prototype.__selection = {watch: 'selectionDidSet',name: 'selection'};
DOMPlayer.prototype.selection = function(v){ return this._selection; }
DOMPlayer.prototype.setSelection = function(v){
	var a = this.selection();
	if(v != a) { this._selection = v; }
	if(v != a) { this.selectionDidSet && this.selectionDidSet(v,a,this.__selection) }
	return this;
};

DOMPlayer.prototype.attachTo = function (win,root){
	
	if (this._root) { // .hasChildNodes
		// console.warn 'already have a root!!!'
		var body = win.document.body;
		win.document.adoptNode(this._root);
		root.parentNode.replaceChild(this._root,root);
		this.reindexNodes();
	} else {
		this._root = root;
	};
	
	this._context = win;
	
	// should not be able to submit anyhow no?
	this._context.onsubmit = function(e) {
		e.stopPropagation();
		e.preventDefault();
		return false;
	};
	
	return this;
};

DOMPlayer.prototype.win = function (){
	return this._context;
};

DOMPlayer.prototype.doc = function (){
	return this.win().document;
};

DOMPlayer.prototype.indexNode = function (node,includeSelf){
	if(includeSelf === undefined) includeSelf = true;
	if (!node.hasChildNodes()) {
		if (!includeSelf) { return this };
		let len = this._nodes.push(node);
		node.SCRIMBA_INDEX = len - 1;
		return this;
	};
	
	var show = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT;
	var walker = this.doc().createNodeIterator(node,show,null);
	var item;
	while (item = walker.nextNode()){
		if (includeSelf || item != node) {
			item.SCRIMBA_INDEX = this._nodes.push(item) - 1;
		};
	};
	
	return this;
};

DOMPlayer.prototype.reindexNodes = function (){
	this._nodes = [];
	this.indexNode(this.root());
	return this;
};

DOMPlayer.prototype.nodeForPath = function (path){
	return this._nodes ? this._nodes[path] : null;
};

DOMPlayer.prototype.deserializeNode = function (value){
	if ((typeof value=='number'||value instanceof Number)) {
		return this.nodeForPath(value);
	} else {
		return this.nodeForHTML(value);
	};
};

DOMPlayer.prototype.serializeRoot = function (){
	// should remove certain classes etc?
	return this.root().innerHTML;
};

DOMPlayer.prototype.toSnapshot = function (o){
	// how will this work with
	if(o === undefined) o = {};
	return {html: this.serializeRoot()};
};

DOMPlayer.prototype.fromSnapshot = function (o){
	if (o && o.html) {
		this.root().innerHTML = o.html;
	};
	return this;
};

DOMPlayer.prototype.nodeForHTML = function (html){
	if (html instanceof Array) {
		// really?
		html = "<div>placeholder</div>";
	} else if (html.text) {
		return this.doc().createTextNode(html.text);
	} else if (html.comment) {
		return this.doc().createComment(html.comment);
	} else if (html.TYPE == 8) {
		return this.doc().createComment(html.value);
	};
	
	var type = html.slice(1).match(/^\w+/)[0];
	var wrap = this.doc().createElement(parentForNodeType[type] || 'div');
	wrap.innerHTML = html;
	return (type == 'body') ? wrap.lastElementChild : wrap.firstElementChild;
};


DOMPlayer.prototype.cleanTextSplitters = function (node){
	
	var walker = this.doc().createNodeIterator(node,NodeFilter.SHOW_COMMENT,null);
	var item;
	while (item = walker.nextNode()){
		if (item.textContent == '§S§') {
			item.parentNode.removeChild(item);
		} else if (item.textContent == '§S§B') {
			item.parentNode.replaceChild(this.doc().createTextNode(""),item);
		};
	};
	return node;
};


DOMPlayer.prototype.applyMutations = function (muts){
	// console.log 'applying mutations!!',muts
	var node;
	var reindex = false;
	
	for (let i = 0, items = iter$(muts), len = items.length, mut; i < len; i++) {
		mut = items[i];
		if (mut[0] == M.INIT) {
			// we do want to reuse the same nodes on subsequent loads
			reindex = true;
			this.setSelection(null);
			mut.PREV || (mut.PREV = [].slice.call(this.root().childNodes));
			
			// could the init refer to nodes that already exist?
			if (mut.NODES) {
				this.root().innerHTML = '';
				for (let j = 0, ary = iter$(mut.NODES), len = ary.length; j < len; j++) {
					this.root().appendChild(ary[j]);
				};
			} else {
				this.root().innerHTML = mut[1];
				if (mut[1].indexOf('§S§') >= 0) {
					this.cleanTextSplitters(this.root());
				};
				
				mut.NODES = [].slice.call(this.root().childNodes);
			};
		} else if (mut[0] == M.INSERT) {
			reindex = true;
			var parentNode = this.nodeForPath(mut[1]);
			var insertIndex = mut[2];
			var nodeToInsert = mut.NODE || (mut.NODE = this.deserializeNode(mut[3]));
			
			var rel = parentNode.childNodes[insertIndex];
			if (rel) {
				// console.log 'insert at index?',rel
				parentNode.insertBefore(nodeToInsert,rel);
			} else {
				parentNode.appendChild(nodeToInsert);
			};
			
			this.indexNode(nodeToInsert);
		} else if (mut[0] == M.INSERT_ADJACENT) {
			// console.log 'INSERT_ADJACENT',mut
			reindex = true;
			
			let relNode = mut.RELNODE || (mut.RELNODE = this.nodeForPath(mut[1]));
			let relPos = M.POS[mut[2]];
			
			// if this has already been applied before - just redo
			if (mut.NODES) {
				for (let j = 0, ary = iter$(mut.NODES), len = ary.length, el; j < len; j++) {
					el = ary[j];
					if (mut[2] == 0) { // beforebegin
						relNode.parentNode.insertBefore(el,relNode);
					} else if (mut[2] == 2) { // beforeend
						relNode.appendChild(el); // .insertAdjacentElement( relPos, el )
					} else {
						console.log("node not added in M.INSERT_ADJACENT!!",mut);
					};
				};
				// continue?
				continue;
			};
			
			let elements = mut[3];
			let relPrev = relNode.previousSibling;
			let relNext = relNode.nextSibling;
			let relPar = relNode.parentNode;
			let relLastChild = relNode.lastChild;
			let mockNode;
			let mockHTML = '';
			
			// if we have preindexed items -- skip indexing these
			let skipIndexing = [];
			
			/*
							We need to track which events we are adding. Since
							insertAdjacentHTML could add several elements we want a
							clean general way to track it. The easiest is to simply
							look at the common parent -- then iterate over all of them
							at the end
							*/
			
			
			// if we are supposed to insert before a non-element node
			// we need to hack around it to still allow using insertAdjacent
			if (mut[2] == 0 && relNode.nodeType != Node.ELEMENT_NODE) {
				mockNode = document.createElement('span');
				relPar.insertBefore(mockNode,relNode);
				relNode = mockNode;
			};
			
			if (typeof elements == 'number') {
				let insNode = this.nodeForPath(elements);
				relNode.insertAdjacentElement(relPos,insNode);
				skipIndexing.push(insNode); // should it skip though?
				mut.NODES = [insNode];
				if (mockNode) { relPar.removeChild(mockNode) };
				continue;
			} else if (typeof elements == 'string') {
				
				relNode.insertAdjacentHTML(relPos,elements);
				mockHTML += elements;
			} else {
				// add all the nodes into a shared node first?
				// or add a helpernode at the first place and remove it later
				for (let i = 0, ary = iter$(elements), len = ary.length, el; i < len; i++) {
					el = ary[i];
					if (typeof el == 'string') {
						relNode.insertAdjacentHTML(relPos,el);
						mockHTML += el;
					} else if (typeof el == 'number') {
						let insNode = this.nodeForPath(el);
						relNode.insertAdjacentElement(relPos,insNode);
						skipIndexing.push(insNode);
					};
				};
			};
			
			// not needed for single preindexed elements
			let addEl;
			let addedElements = [];
			
			// are there textsplitters here we need to erase?
			if (mockHTML.indexOf('§S§') >= 0) {
				this.cleanTextSplitters(relPar);
			};
			
			if (relPos == 'beforeend') {
				addEl = relLastChild ? relLastChild.nextSibling : relNode.firstChild;
			} else if (relPos == 'beforebegin') {
				addEl = relPrev ? relPrev.nextSibling : relPar.firstChild;
			};
			
			while (addEl){
				if (addEl == relNode) { break; };
				
				if (skipIndexing.indexOf(addEl) < 0) {
					// should we really skip?
					this.indexNode(addEl);
				};
				
				addedElements.push(addEl);
				addEl = addEl.nextSibling;
			};
			
			if (mockNode) {
				relPar.removeChild(mockNode);
			};
			// console.log "added elements",addedElements
			mut.NODES = addedElements;
		} else if (mut[0] == M.REMOVE) {
			reindex = true;
			// var node = nodeForPath(mut[1])
			if (node = (mut.NODE || (mut.NODE = this.nodeForPath(mut[1])))) {
				// to remember where to reinsert it?
				// what if the sibling is also altered within the same mutation?
				mut.REL || (mut.REL = node.nextSibling);
				mut.PARENT || (mut.PARENT = node.parentNode);
				
				if (node.parentNode) {
					node.parentNode.removeChild(node);
				} else {
					console.warn("M.REMOVE has no parent",node,node.parentNode,mut,mut.PARENT);
				};
			};
		} else if (mut[0] == M.SETTEXT) {
			if (node = mut.NODE = this.nodeForPath(mut[1])) {
				mut.PREV = node.textContent;
				node.textContent = patchString(mut.PREV,mut[2]);
			};
		} else {
			node = mut.NODE = this.nodeForPath(mut[1]);
			
			if (node && mut[0] == M.SETPROP) {
				var key = M.NAME_MAP[mut[2]] || mut[2];
				mut.PREV || (mut.PREV = node[key]);
				node[key] = mut[3];
			} else if (node && mut[0] == M.SETATTR) {
				key = M.NAME_MAP[mut[2]] || mut[2];
				mut.PREV || (mut.PREV = node.getAttribute(key));
				
				if (key == 'class') {
					mut.STATEFLAGS || (mut.STATEFLAGS = node.className.split(" ").filter(function(f) { return f.match(/^__\w+/); }));
				};
				
				if (mut[3] == null) {
					node.removeAttribute(key);
				} else {
					node.setAttribute(key,mut[3]);
				};
				
				if (mut.STATEFLAGS) {
					// add stateflags afterwards
					mut.STATEFLAGS.map(function(f) { return node.classList.add(f); });
				};
			};
		};
	};
	
	if (reindex) this.reindexNodes();
	return this;
};

DOMPlayer.prototype.revertMutations = function (muts){
	var node;
	var reindex = false;
	var nr = len$(muts) - 1;
	
	while (nr >= 0){
		var mut = muts[nr--];
		
		// we should remove it instead
		if (mut[0] == M.INIT) {
			this.root().innerHTML = '';
			for (let i = 0, items = iter$(mut.PREV), len = items.length; i < len; i++) {
				this.root().appendChild(items[i]);
			};
			this.setSelection(null);
			reindex = true;
		} else if (mut[0] == M.INSERT) {
			reindex = true;
			if (node = mut.NODE) {
				if (node.parentNode) {
					node.parentNode.removeChild(node);
				} else {
					console.warn("revert INSERT - no parent!",node);
				};
			};
		} else if (mut[0] == M.INSERT_ADJACENT) {
			reindex = true;
			for (let i = 0, items = iter$(mut.NODES), len = items.length, node; i < len; i++) {
				node = items[i];
				if (node.parentNode) {
					node.parentNode.removeChild(node);
				} else {
					console.warn("revert INSERT_ADJACENT - no parent!",node,mut);
				};
			};
		} else if (mut[0] == M.REMOVE) {
			reindex = true;
			// insert it where it was when removed.. including index?
			var par = mut.PARENT;
			mut.REL ? par.insertBefore(mut.NODE,mut.REL) : par.appendChild(mut.NODE);
		} else if (mut[0] == M.SETTEXT && mut.NODE) {
			mut.NODE.textContent = mut.PREV;
		} else if (mut[0] == M.SETPROP && mut.NODE) {
			var key = M.NAME_MAP[mut[2]] || mut[2];
			mut.NODE[key] = mut.PREV;
		} else if (mut[0] == M.SETATTR && mut.NODE) {
			key = M.NAME_MAP[mut[2]] || mut[2];
			
			if (mut.PREV == null) {
				mut.NODE.removeAttribute(key);
			} else {
				mut.NODE.setAttribute(key,mut.PREV);
			};
		};
	};
	
	if (reindex) this.reindexNodes();
	return this;
};

DOMPlayer.prototype.synced_ = function (){
	return this;
};

DOMPlayer.prototype.refreshPseudoClass = function (flag,new$,old){
	// remove hover classes upwards
	while (old && old != this.root() && (!(new$) || !old.contains(new$))){
		if (old.classList) {
			old.classList.remove(flag);
		};
		old = old.parentNode;
	};
	
	// old.removeAttribute('mhover') if old
	// new.setAttribute('mhover','hover') if new
	while (new$ && new$ != this.root() && this.root().contains(new$)){
		if (new$.classList) { new$.classList.add(flag) };
		new$ = new$.parentNode;
	};
	return;
};

DOMPlayer.prototype.focusNodeDidSet = function (new$,old){
	// refreshPseudoClass('__focus',new,old)
	if (old && old.classList) {
		old.classList.remove('__focus');
	};
	if (new$ && new$.classList) {
		return new$.classList.add('__focus');
	};
};


DOMPlayer.prototype.hoverNodeDidSet = function (new$,old){
	// TODO should happen async?
	return this.refreshPseudoClass('__hover',new$,old);
};

DOMPlayer.prototype.activeNodeDidSet = function (new$,old){
	// TODO should happen async?
	return this.refreshPseudoClass('__active',new$,old);
};

DOMPlayer.prototype.selectionDidSet = function (op,old){
	// TODO should happen async?
	if (this.win() == window || !(this.win()) || !this.win().getSelection) {
		// console.log 'in local window -- dropping'
		return this;
	};
	
	var sel = this.win().getSelection();
	
	if (!sel) { return };
	
	if (!op || !op.NODE || op.NODE == this.root()) {
		if (sel) { sel.removeAllRanges() };
		return this;
	};
	
	var anchor = op.NODE;
	var a = op[1];
	var b = op[2];
	// FIXME should we not cache the endNode as well?
	var endNode = op[3] ? this.nodeForPath(op[3]) : anchor;
	
	if (anchor.nodeName == 'INPUT' || anchor.nodeName == 'TEXTAREA') {
		var reg = /text|search|password|tel|url/;
		
		if (anchor.nodeName == 'INPUT' && !reg.test(anchor.type)) {
			return;
		};
		
		if (a < b) {
			anchor.setSelectionRange(a,b,'forward');
		} else if (a > b) {
			anchor.setSelectionRange(b,a,'backward');
		} else {
			anchor.setSelectionRange(a,b,'none');
		};
	} else {
		// if anchor:nodeType == 3
		var range = this.doc().createRange();
		
		if (anchor != endNode) {
			var diff = anchor.compareDocumentPosition(endNode); //  & Node.DOCUMENT_POSITION_FOLLOWING
			var preceding = diff & Node.DOCUMENT_POSITION_PRECEDING;
			// console.warn "SELECTION",diff,preceding
			
			if (preceding) {
				range.setStart(endNode,b);
				range.setEnd(anchor,a);
			} else {
				range.setStart(anchor,a);
				range.setEnd(endNode,b);
			};
		} else {
			// text
			if (anchor.nodeType == 3) {
				a = Math.min(anchor.length,a);
				b = Math.min(anchor.length,b);
			};
			
			if (a <= b) {
				range.setStart(anchor,a);
				range.setEnd(anchor,b);
			} else {
				range.setStart(anchor,b);
				range.setEnd(anchor,a);
			};
			if (a == b) {
				range.collapse();
			};
		};
		
		sel.removeAllRanges();
		sel.addRange(range);
	};
	
	return;
};

DOMPlayer.prototype.dispose = function (){
	this.setActiveNode(null);
	this.setFocusNode(null);
	this.setHoverNode(null);
	this.setSelection(null);
	this._nodes = [];
	this._context = null;
	return this;
};
