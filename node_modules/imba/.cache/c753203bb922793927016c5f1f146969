function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');

var msgpack = require('msgpack-lite');
var Bufferish = msgpack.Decoder.prototype.bufferish;
var Decoder = new (msgpack.Decoder)({});

var MSG = require('../protocol').MSG;

function StreamMissingRangeError(start,end){
	this.start = start;
	this.end = end;
	this;
};
Imba.subclass(StreamMissingRangeError,Error);
exports.StreamMissingRangeError = StreamMissingRangeError; // export class 


/*

Represents the raw binary buffer for a cast.
Has no understanding of the encoded data, but
has helper methods for encoding/decoding to/from
msgpack.

When adding chunks to the buffer at wrong offsets
it will also create and store these fragments, while
exposing details about missing ranges etc.

*/

function StreamBuffer(buffer,model){
	this._model = model;
	this._decoder = new (msgpack.Decoder)({});
	this._decoder.buffer = this._buffer = (buffer || Bufferish.alloc(1000)); // or msgpack.encode(protocol))
	this._readyState = 0;
	this._version = 0;
	this._size = 0;
	this._verifiedOffset = 0;
	this._head = {offset: 0,end: 0};
	this._holes = 0;
	this;
};

exports.StreamBuffer = StreamBuffer; // export class 
StreamBuffer.OK = 3;
StreamBuffer.FRAGMENTED = 4;

StreamBuffer.decode = function (binary,stats){
	if(stats === undefined) stats = true;
	var decoder = new (msgpack.Decoder)({});
	decoder.write(binary);
	var items = [];
	while (decoder.offset < binary.byteLength){
		
		let start = decoder.offset;
		let item = decoder.fetch();
		
		if (stats && (item instanceof Array)) {
			item.START = start;
			item.END = decoder.offset;
		};
		
		items.push(item);
	};
	
	return items;
};

StreamBuffer.encode = function (chunks,protocol){
	if(protocol === undefined) protocol = 0;
	var encoder = new (msgpack.Encoder)({});
	for (let i = 0, items = iter$(chunks), len = items.length; i < len; i++) {
		encoder.write(items[i]);
	};
	var binary = encoder.read();
	binary.PROTOCOL = protocol;
	return binary;
};

StreamBuffer.concat = function (buffers){
	return Bufferish.concat(buffers);
};

StreamBuffer.alloc = function (size){
	return Bufferish.alloc(size);
};

StreamBuffer.prototype.buffer = function(v){ return this._buffer; }
StreamBuffer.prototype.setBuffer = function(v){ this._buffer = v; return this; };
StreamBuffer.prototype.readyState = function(v){ return this._readyState; }
StreamBuffer.prototype.setReadyState = function(v){ this._readyState = v; return this; };

StreamBuffer.prototype.state = function (){
	return this._holes ? 'fragmented' : 'synced';
};

StreamBuffer.prototype.id = function (){
	return this._model.id + ":stream";
};

StreamBuffer.prototype.eid = function (){
	return this._model.id;
};

StreamBuffer.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
StreamBuffer.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
StreamBuffer.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

// same as add - but used when writing to buffer locally
StreamBuffer.prototype.write = function (chunk,offset){
	if(offset === undefined) offset = 0;
	return this;
};

StreamBuffer.prototype.registerChunk = function (offset,length){
	let to = offset + length;
	let frag = this._head;
	let startFrag = null;
	let result = null;
	// console.log "register",offset,to
	while (frag){
		let next = frag.next;
		
		if (startFrag) {
			if (frag.offset <= startFrag.end) {
				this._holes--;
				startFrag.end = Math.max(startFrag.end,frag.end);
				next = startFrag.next = frag.next;
			};
		} else if (offset <= frag.end) {
			frag.end = Math.max(frag.end,to);
			startFrag = frag;
		} else if (offset < frag.start) {
			frag.start = offset;
			frag.end = Math.max(frag.end,to);
			startFrag = frag;
		} else if (offset > frag.end && !next) {
			this._holes++;
			frag.next = {offset: offset,end: to};
			result = [frag.end,offset];
		};
		frag = next;
	};
	return result;
};

StreamBuffer.prototype.holes = function (){
	var holes = [];
	let frag = this._head;
	while (frag){
		let next = frag.next;
		if (next) {
			holes.push([frag.end,next.offset]);
		};
		frag = next;
	};
	return holes;
};

StreamBuffer.prototype.resize = function (size){
	let prev = this._buffer;
	if (this._buffer.length < size) {
		this._buffer = Bufferish.alloc(size);
		this._buffer.set(prev,0);
		this._decoder.buffer = this._buffer;
	};
	return this._buffer;
};

StreamBuffer.prototype.set = function (chunk,offset){
	let chunkSize = chunk.length;
	if ((offset + chunkSize) >= this._buffer.length) {
		this.resize(offset + chunkSize + 10000);
	};
	
	this._buffer.set(chunk,offset);
	
	let prevSize = this._head.end;
	let hole = this.registerChunk(offset,chunkSize);
	
	if (this._size < this._head.end) {
		this._size = this._head.end;
	};
	
	if (hole) {
		return new StreamMissingRangeError(hole[0],hole[1]);
	};
	
	return;
};

StreamBuffer.prototype.add = function (chunk,offset){
	if(offset === undefined) offset = 0;
	if (chunk instanceof Array) { // what if it is a struct?
		chunk = msgpack.encode(chunk);
	};
	
	// not validating the content now
	let size = this._head.end;
	let res = this.set(chunk,offset);
	
	// size changed now
	if (this._size > size) {
		this.emit('add',this);
		return true;
	};
	
	return res;
};

StreamBuffer.prototype.len = function (){
	return this.size();
};

StreamBuffer.prototype.size = function (){
	return this._size;
};

StreamBuffer.prototype.slice = function (start,end){
	return end ? this._buffer.slice(start,end) : this._buffer.slice(start,this._size);
};

StreamBuffer.prototype.trim = function (end){
	if (len$(this) > end) {
		// should just change the size param and let the buffer overwrite 
		this._buffer = this._buffer.slice(0,end);
		this._size = end;
		this._verifiedOffset = Math.min(this._verifiedOffset,end);
		this._version++;
		this.emit('trim',end,this);
	};
	return this;
};

StreamBuffer.prototype.toJSON = function (){
	var raw = StreamBuffer.decode(this._buffer,false);
	return raw;
};

StreamBuffer.prototype.onpacket = function (packet){
	switch (packet.CODE) {
		case MSG.STREAMAPPEND: {
			var offset = packet[2];
			var result = this.add(packet.payload(),offset);
			
			if (result instanceof Error) {
				console.log("missingrange",result.start,result.end,this.size()); // request the whole size
				// packet.reply([MSG.STREAMGETRANGE,eid,size,result:end])
				packet.peer().send([MSG.STREAMGETRANGE,this.eid(),this.size(),result.end]);
				return;
			};
			break;
		}
		case MSG.STREAMTRIM: {
			let offset = packet[2];
			console.warn("streamtrim!",packet,offset);
			result = this.trim(offset);
			
			if (packet.payload() && packet.payload().length > 0) {
				this.add(packet.payload(),offset);
			};
			break;
		}
		case MSG.STREAMRANGE: {
			offset = packet[2];
			console.log("received range",offset,packet[3]);
			result = this.add(packet.payload(),offset);
			// should not introduce another hole?
			break;
		}
		case MSG.STREAMGETRANGE: {
			offset = packet[2];
			var to = packet[3] || this.size();
			// console.log "reply to request for range!!",offset,to,@buffer
			// BT = self
			// BPT = packet
			// must make syre that we have it
			
			// need to do it in 
			while ((to - offset) > 0){
				let chunkTo = Math.min(to,offset + 60000);
				var chunk = this.slice(offset,chunkTo);
				let pars = msgpack.encode([MSG.STREAMRANGE,this.eid(),offset,chunkTo]);
				var reply = StreamBuffer.concat([pars,chunk]);
				offset = chunkTo;
				// BPTR = reply
				// console.warn 'sending packet now',BPTR,offset,chunkTo,to
				packet.peer().send(reply);
			};
			return;
			break;
		}
	};
	return this;
};
