function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _1 = Imba.createElement;
var protocol$ = require('../protocol'), ACTION = protocol$.ACTION, DOM = protocol$.DOM, KEYS = protocol$.KEYS, LAYOUTMASK = protocol$.LAYOUTMASK;

var Dimensions = require('../core/Dimensions').Dimensions;

var IconButton = require('uxa').IconButton;
var PaneWidget = require('./PaneWidget').PaneWidget;
var LayoutGesture = require('../util/LayoutGesture').LayoutGesture;
var Delay = require('../util/Delay').Delay;
var PlayerPage = require('./browser/PlayerPage').PlayerPage;
var History = require('./browser/History').History;

var ContentEditable = require('../util/ContentEditable').ContentEditable;

var Indicator = require('uxa').Indicator;

var SpinKit$ = require('../../site/components/SpinKit'), SKCubeGrid = SpinKit$.SKCubeGrid, SKCubeMove = SpinKit$.SKCubeMove, SKDoubleBounce = SpinKit$.SKDoubleBounce;

var BrowserConfigurationDialog = require('../views/BrowserConfigurationDialog').BrowserConfigurationDialog;

var styleProcessor = require('./browser/styleProcessor');

var BROWSER_MAX = exports.BROWSER_MAX = 'max';
var BROWSER_MIN = exports.BROWSER_MIN = 'min';
var BROWSER_WINDOWED = exports.BROWSER_WINDOWED = 'win';


// externs;

var BrowserPathField = Imba.defineTag('BrowserPathField', function(tag){
	
	tag.prototype.ontap = function (e){
		e.halt();
		new ContentEditable(this.dom(),{pattern: /\w+/});
		return this;
	};
	
	tag.prototype.ontouchstart = function (t){
		return this;
	};
});

Imba.extendTag('iframe', function(tag){
	tag.prototype.srcdoc = function(v){ return this.getAttribute('srcdoc'); }
	tag.prototype.setSrcdoc = function(v){ this.setAttribute('srcdoc',v); return this; };
});

var PlayerFrame = Imba.defineTag('PlayerFrame', 'iframe', function(tag){
	
	tag.prototype.__data = {watch: 'dataDidSet',name: 'data'};
	tag.prototype.data = function(v){ return this._data; }
	tag.prototype.setData = function(v){
		var a = this.data();
		if(v != a) { this._data = v; }
		if(v != a) { this.dataDidSet && this.dataDidSet(v,a,this.__data) }
		return this;
	};
	
	tag.prototype.build = function (){
		var self = this;
		self._dom.onload = function() {
			self._loaded = true;
			return self.render();
		};
		return self;
	};
	
	tag.prototype.dataDidSet = function (data){
		return this;
	};
	
	tag.prototype.render = function (){
		if (this._loaded && this.data() && this.dom().contentWindow) {
			this.data().render(this.dom().contentWindow);
		};
		return this;
	};
});

var RunnerFrame = Imba.defineTag('RunnerFrame', 'iframe', function(tag){
	
	tag.prototype.page = function (){
		return this.data().browser().page();
	};
	
	tag.prototype.build = function (){
		var self = this;
		self._queuedMessages = [];
		self._onmessage = function(e) {
			if (self.parent() && e.source === self.dom().contentWindow) {
				if (self._winUnload && (Date.now() - self._winUnload) < 5000) {
					self.log("winUnload",Date.now() - self._winUnload);
					return self._queuedMessages.push(e);
				} else {
					return self.data().onrunnermessage(e,e.data);
				};
			};
		};
		
		self._onunload = function(e) {
			self._winUnload = Date.now();
			return setTimeout(function() {
				self.log("removed winUnload again",Date.now() - self._winUnload);
				return self._winUnload = null;
			},100);
		};
		
		self.dom().onload = function(e) {
			self.log('onload',e);
			clearTimeout(self._timeout);
			return self._timeout = setTimeout(function() {
				if (self.page() && !self.page().status()) {
					self.log("loaded without tracker");
					return self.trigger('loadexternal');
				};
			},20);
			// trigger('runnerload',e)
		};
		return self;
	};
	
	tag.prototype.onloadexternal = function (e){
		e.halt();
		this.page().setStatus(307);
		this.go(("" + (this.data().browser().baseURI()) + "index.html"));
		return this;
	};
	
	tag.prototype.post = function (msg){
		return this.dom().contentWindow.postMessage(msg,'*');
	};
	
	tag.prototype.isActive = function (){
		return !(!this.dom().offsetParent) && this.dom().contentWindow;
	};
	
	tag.prototype.start = function (){
		this.log('start');
		if (!(this.parent())) {
			this.data()._body.dom().appendChild(this.dom());
			this.data()._body.flag('running');
			window.addEventListener('message',this._onmessage);
			window.addEventListener('beforeunload',this._onunload,true);
		};
		return this;
	};
	
	tag.prototype.stop = function (){
		this.log('stop');
		if (this.parent()) {
			this.parent().unflag('running');
			this.parent().dom().removeChild(this.dom());
			window.removeEventListener('message',this._onmessage);
			window.removeEventListener('beforeunload',this._onunload,true);
		};
		return this;
	};
	
	tag.prototype.go = function (url){
		this.stop();
		this.setSrc(url);
		return this.start();
	};
});

var BrowserFrame = Imba.defineTag('BrowserFrame', function(tag){
	
	tag.prototype.layoutMask = function (){
		return LAYOUTMASK.SCALED | LAYOUTMASK.BOUNDLESS;
	};
});

var BrowserView = Imba.defineTag('BrowserView', function(tag){
	
	tag.prototype.__autoPos = {'default': true,name: 'autoPos'};
	tag.prototype.autoPos = function(v){ return this._autoPos; }
	tag.prototype.setAutoPos = function(v){ this._autoPos = v; return this; }
	tag.prototype._autoPos = true;
	tag.prototype.__autoSize = {'default': true,name: 'autoSize'};
	tag.prototype.autoSize = function(v){ return this._autoSize; }
	tag.prototype.setAutoSize = function(v){ this._autoSize = v; return this; }
	tag.prototype._autoSize = true;
	tag.prototype.__autoMinimize = {'default': false,name: 'autoMinimize'};
	tag.prototype.autoMinimize = function(v){ return this._autoMinimize; }
	tag.prototype.setAutoMinimize = function(v){ this._autoMinimize = v; return this; }
	tag.prototype._autoMinimize = false;
	tag.prototype.__page = {watch: 'pageDidSet',name: 'page'};
	tag.prototype.page = function(v){ return this._page; }
	tag.prototype.setPage = function(v){
		var a = this.page();
		if(v != a) { this._page = v; }
		if(v != a) { this.pageDidSet && this.pageDidSet(v,a,this.__page) }
		return this;
	};
	
	tag.prototype.__pipScale = {watch: 'pipScaleDidSet',name: 'pipScale'};
	tag.prototype.pipScale = function(v){ return this._pipScale; }
	tag.prototype.setPipScale = function(v){
		var a = this.pipScale();
		if(v != a) { this._pipScale = v; }
		if(v != a) { this.pipScaleDidSet && this.pipScaleDidSet(v,a,this.__pipScale) }
		return this;
	};
	tag.prototype.fullScale = function(v){ return this._fullScale; }
	tag.prototype.setFullScale = function(v){ this._fullScale = v; return this; };
	
	tag.prototype.__visible = {watch: 'visibleDidSet',name: 'visible'};
	tag.prototype.visible = function(v){ return this._visible; }
	tag.prototype.setVisible = function(v){
		var a = this.visible();
		if(v != a) { this._visible = v; }
		if(v != a) { this.visibleDidSet && this.visibleDidSet(v,a,this.__visible) }
		return this;
	};
	tag.prototype.__minimized = {watch: 'minimizedDidSet',name: 'minimized'};
	tag.prototype.minimized = function(v){ return this._minimized; }
	tag.prototype.setMinimized = function(v){
		var a = this.minimized();
		if(v != a) { this._minimized = v; }
		if(v != a) { this.minimizedDidSet && this.minimizedDidSet(v,a,this.__minimized) }
		return this;
	};
	tag.prototype.__windowed = {watch: 'windowedDidSet',name: 'windowed'};
	tag.prototype.windowed = function(v){ return this._windowed; }
	tag.prototype.setWindowed = function(v){
		var a = this.windowed();
		if(v != a) { this._windowed = v; }
		if(v != a) { this.windowedDidSet && this.windowedDidSet(v,a,this.__windowed) }
		return this;
	};
	tag.prototype.__focused = {watch: 'focusedDidSet',name: 'focused'};
	tag.prototype.focused = function(v){ return this._focused; }
	tag.prototype.setFocused = function(v){
		var a = this.focused();
		if(v != a) { this._focused = v; }
		if(v != a) { this.focusedDidSet && this.focusedDidSet(v,a,this.__focused) }
		return this;
	};
	tag.prototype.userMinimized = function(v){ return this._userMinimized; }
	tag.prototype.setUserMinimized = function(v){ this._userMinimized = v; return this; };
	tag.prototype.__hasUserFocus = {watch: 'hasUserFocusDidSet',name: 'hasUserFocus'};
	tag.prototype.hasUserFocus = function(v){ return this._hasUserFocus; }
	tag.prototype.setHasUserFocus = function(v){
		var a = this.hasUserFocus();
		if(v != a) { this._hasUserFocus = v; }
		if(v != a) { this.hasUserFocusDidSet && this.hasUserFocusDidSet(v,a,this.__hasUserFocus) }
		return this;
	};
	tag.prototype.__hasPointerFocus = {watch: 'hasPointerFocusDidSet',name: 'hasPointerFocus'};
	tag.prototype.hasPointerFocus = function(v){ return this._hasPointerFocus; }
	tag.prototype.setHasPointerFocus = function(v){
		var a = this.hasPointerFocus();
		if(v != a) { this._hasPointerFocus = v; }
		if(v != a) { this.hasPointerFocusDidSet && this.hasPointerFocusDidSet(v,a,this.__hasPointerFocus) }
		return this;
	};
	
	tag.prototype.__mode = {watch: 'modeDidSet',name: 'mode'};
	tag.prototype.mode = function(v){ return this._mode; }
	tag.prototype.setMode = function(v){
		var a = this.mode();
		if(v != a) { this._mode = v; }
		if(v != a) { this.modeDidSet && this.modeDidSet(v,a,this.__mode) }
		return this;
	};
	tag.prototype.runner = function(v){ return this._runner; }
	tag.prototype.setRunner = function(v){ this._runner = v; return this; };
	
	tag.prototype.__minWidth = {watch: 'syncStyleVar',unit: 'px',name: 'minWidth'};
	tag.prototype.minWidth = function(v){ return this._minWidth; }
	tag.prototype.setMinWidth = function(v){
		var a = this.minWidth();
		if(v != a) { this._minWidth = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__minWidth) }
		return this;
	};
	tag.prototype.__maxWidth = {watch: 'syncStyleVar',unit: 'px',name: 'maxWidth'};
	tag.prototype.maxWidth = function(v){ return this._maxWidth; }
	tag.prototype.setMaxWidth = function(v){
		var a = this.maxWidth();
		if(v != a) { this._maxWidth = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__maxWidth) }
		return this;
	};
	tag.prototype.__maxHeight = {watch: 'syncStyleVar',unit: 'px',name: 'maxHeight'};
	tag.prototype.maxHeight = function(v){ return this._maxHeight; }
	tag.prototype.setMaxHeight = function(v){
		var a = this.maxHeight();
		if(v != a) { this._maxHeight = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__maxHeight) }
		return this;
	};
	tag.prototype.__winHeight = {watch: 'syncStyleVar',unit: 'px',name: 'winHeight'};
	tag.prototype.winHeight = function(v){ return this._winHeight; }
	tag.prototype.setWinHeight = function(v){
		var a = this.winHeight();
		if(v != a) { this._winHeight = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__winHeight) }
		return this;
	};
	tag.prototype.__winWidth = {watch: 'syncStyleVar',unit: 'px',name: 'winWidth'};
	tag.prototype.winWidth = function(v){ return this._winWidth; }
	tag.prototype.setWinWidth = function(v){
		var a = this.winWidth();
		if(v != a) { this._winWidth = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__winWidth) }
		return this;
	};
	tag.prototype.__winTop = {watch: 'syncStyleVar',unit: 'px',name: 'winTop'};
	tag.prototype.winTop = function(v){ return this._winTop; }
	tag.prototype.setWinTop = function(v){
		var a = this.winTop();
		if(v != a) { this._winTop = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__winTop) }
		return this;
	};
	tag.prototype.__winLeft = {watch: 'syncStyleVar',unit: 'px',name: 'winLeft'};
	tag.prototype.winLeft = function(v){ return this._winLeft; }
	tag.prototype.setWinLeft = function(v){
		var a = this.winLeft();
		if(v != a) { this._winLeft = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__winLeft) }
		return this;
	};
	tag.prototype.__winScale = {watch: 'syncStyleVar',name: 'winScale'};
	tag.prototype.winScale = function(v){ return this._winScale; }
	tag.prototype.setWinScale = function(v){
		var a = this.winScale();
		if(v != a) { this._winScale = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__winScale) }
		return this;
	};
	
	tag.prototype.__winMinScale = {watch: 'syncStyleVar',name: 'winMinScale'};
	tag.prototype.winMinScale = function(v){ return this._winMinScale; }
	tag.prototype.setWinMinScale = function(v){
		var a = this.winMinScale();
		if(v != a) { this._winMinScale = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__winMinScale) }
		return this;
	};
	tag.prototype.__maxMinScale = {watch: 'syncStyleVar',name: 'maxMinScale'};
	tag.prototype.maxMinScale = function(v){ return this._maxMinScale; }
	tag.prototype.setMaxMinScale = function(v){
		var a = this.maxMinScale();
		if(v != a) { this._maxMinScale = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__maxMinScale) }
		return this;
	};
	tag.prototype.__maxScale = {watch: 'syncStyleVar',name: 'maxScale'};
	tag.prototype.maxScale = function(v){ return this._maxScale; }
	tag.prototype.setMaxScale = function(v){
		var a = this.maxScale();
		if(v != a) { this._maxScale = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__maxScale) }
		return this;
	};
	
	tag.prototype.browser = function (){
		return this.data();
	};
	
	tag.prototype.space = function (){
		return this.browser().space();
	};
	
	tag.prototype.syncStyleVar = function (value,prev,key){
		let name = key.name;
		let unit = key.unit;
		return this.dom().style.setProperty('--' + name,unit ? ((value + unit)) : value);
	};
	
	tag.prototype.setup = function (){
		this._sentStyleSheets = {};
		this._layoutMask = 0;
		this._runner = (_1(RunnerFrame).flag('runner')).setData(this).end();
		
		this.setSref(this.data().id());
		return this;
	};
	tag.prototype.stop = function (){
		return this.runner().stop();
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self.data().space().on('reflow',function() { return self.reflow(true); });
		
		self.data().space().on('playing',function() {
			return self.browser().options().discardLocals(['minimized','windowed','focused']);
		});
		
		self._mounted = true;
		self.reflow(true);
		return self;
	};
	
	tag.prototype.go = async function (url,nav){
		if(nav === undefined) nav = null;
		await this.browser().pushTmpState();
		
		if ((typeof url=='number'||url instanceof Number)) {
			nav = url;
			url = this.browser().history().relative(nav);
			this.log(("go(" + nav + ")"),url);
		};
		
		let src = ("" + (this.browser().baseURI()) + url);
		this.browser().push_(ACTION.PAGE_REQUEST,[KEYS.GET,url,nav]);
		this.runner().go(src);
		this.render();
		return this;
	};
	
	tag.prototype.refresh = function (){
		var self = this;
		self.go(self.browser().url(),0);
		return setTimeout(function() {
			if (!(self.windowed())) { return self._frame.dom().focus() };
		},20);
	};
	
	tag.prototype.onpathchange = function (e){
		// if path hasnt change - this is just like refreshing
		return (e.data() == this.browser().url()) ? this.refresh() : this.go(e.data());
	};
	
	tag.prototype.onrunnermessage = function (e,op){
		var self = this, hasBody, v_;
		if (op.type == 'actions') {
			let hasPointer = self.space().pointerTracker().isActive();
			
			let res = [];
			for (let i = 0, items = iter$(op.actions), len = items.length, item, content; i < len; i++) {
				item = items[i];
				let c = item[0];
				// dont include pointer-related events if we are in lab
				if (!hasPointer && (c == ACTION.DOM_ACTIVEIN || c == ACTION.DOM_HOVERIN || c == ACTION.DOM_FOCUSIN)) {
					continue;
				};
				
				self.data().push_(item[0],item[1]);
				res.push((item[0] == ACTION.PAGE_LOADED) ? (
					content = item[1][0],
					content = content.replace(/<script\b[^>]*>([^]*?)<\/script>/g,""),
					hasBody = !/<body\b[^>]*>\s*<\/body>/.test(content),
					hasBody && (
						self.browser().setVisible(true)
					)
				) : ((item[0] == DOM.MUTATE) ? (
					self.browser().setVisible(true)
				) : ((item[0] == ACTION.PAGE_LOG) && (
					true
				))));
			};
			return res;
		} else if (op.type == 'domevent') {
			return self.browser().space().emit('browserevent',op.data);
		} else if (op.type == 'location') {
			return (self.browser().setUrl(v_ = self.browser().normalizeURL(op.url)),v_);
		} else if (op.type == 'beforeunload') {
			self.log('beforeunload',op.predictedTarget);
			let url = self.browser().normalizeURL(op.predictedTarget || '');
			return self.browser().push_(ACTION.PAGE_REQUEST,[KEYS.GET,url || null]);
		} else if (op.type == 'cancelled') {
			self.log("cancelled");
			self.browser().page().setCancelled(true);
			self.runner().stop();
			return self.render();
		} else if (op.type == 'pageload') {
			var status = op.status;
			var url = self.browser().normalizeURL(op.url);
			return self.browser().push_(ACTION.PAGE_LOAD,[status,url]);
		} else if (op.type == 'loader:busy') {
			// console.log "loader:busy"
			self.browser().page().setLoading(true);
			return self.render();
		} else if (op.type == 'loader:done') {
			// console.log "loader:done"
			return setTimeout(function() {
				self.browser().page().setLoading(false);
				return self.render();
			},100);
		} else {
			return self.log("tracker message",op.type);
		};
	};
	
	tag.prototype.back = function (){
		return this.go(-1);
	};
	
	tag.prototype.forward = function (){
		return this.go(1);
	};
	
	tag.prototype.posToScreen = function (x,y){
		return this.data().posToScreen(x,y);
	};
	
	tag.prototype.sendStyleSheets = function (){
		var path, body;
		let res = [];
		for (let i = 0, items = iter$(this.data().space().files()), len = items.length, file; i < len; i++) {
			file = items[i];
			res.push((file.lang() == 'css') && (
				path = file.path(),
				body = file.currentBody(),
				(this._sentStyleSheets[path] != body) && (
					this._sentStyleSheets[path] = body,
					// what if we are not running?!?
					this.runner().post({type: 'stylesheet',path: path,body: styleProcessor.process(body)})
				)
			));
		};
		return res;
	};
	
	tag.prototype.isMovable = function (){
		return !this.api().isMobile();
	};
	
	tag.prototype.ontouchstart = function (t){
		// experimental - just a hacky way to make
		// the mobile experience work ok.
		if (this.autoMinimize()) {
			this.setHasUserFocus(!(this.hasUserFocus()));
			return this.render();
		};
		
		if (this.minimized()) {
			t.event().preventDefault();
			this._frame.dom().focus();
			return (this.browser().setMinimized(false),false);
		} else if (this.isMovable()) {
			let el = t.event().target;
			if (el && !el.matches('input,.tool')) {
				return LayoutGesture.wrap(t,{layout: this._layout});
			};
		};
	};
	
	tag.prototype.onmoveupdate = function (g,done){
		if(done === undefined) done = false;
		if (!(this.windowed() && !(this.minimized()))) { return };
		
		if (g.dx() || g.dy()) {
			this.setAutoPos(false);
		};
		
		if (this.autoPos() == false) {
			var mask = done ? this._layoutMask : Dimensions.MOVING;
			var x = Math.round(g.layout().left() + g.dx());
			var y = Math.round(Math.max(g.layout().top() + g.dy(),40));
			this._layout.set({left: x,top: y,targetRef: this.data().id(),mask: mask}).ensureInsideParent();
			this.data().setLayout(this._layout.clone());
			this.redraw();
			return this.data().space().emit('rearranging',this.data());
		};
	};
	
	tag.prototype.onmoveend = function (g){
		if (!(this.windowed() && !(this.minimized()))) { return };
		return this.onmoveupdate(g,true);
	};
	
	tag.prototype.onresizestart = function (g){
		this.flag('resizing');
		let pad = 40;
		let sbox = this.space().view().box();
		let x = g.x() - sbox.left;
		let y = g.y() - sbox.top;
		g._dxClamp = [sbox.width - x - pad,-x + pad];
		g._dyClamp = [sbox.height - y - pad,-y + pad];
		// log "onresizestart",g
		let mask = Dimensions.RESIZING;
		
		if (!(this.windowed())) {
			g._maxWidth = this.browser().maxWidth();
			g._maxHeight = this.browser().maxHeight();
		};
		
		if (g.ax()) {
			mask |= ((g.ax() > 0) ? Dimensions.PIN_LEFT : Dimensions.PIN_RIGHT);
		};
		if (g.ay()) {
			mask |= ((g.ay() > 0) ? Dimensions.PIN_TOP : Dimensions.PIN_BOTTOM);
		};
		return this._layoutMask = mask;
	};
	
	tag.prototype.clamp = function (min,val,max,round){
		if(round === undefined) round = 1;
		return Math.min(Math.max(Math.round(val / round) * round,min),max);
	};
	
	tag.prototype.onresizeupdate = function (g,done){
		if(done === undefined) done = false;
		this.setAutoSize(false);
		
		let dx = g.dx();
		let dy = g.dy();
		
		dx = Math.min(g._dxClamp[0],Math.max(dx,g._dxClamp[1]));
		dy = Math.min(g._dyClamp[0],Math.max(dy,g._dyClamp[1]));
		
		if (!(this.windowed())) {
			let w = g._maxWidth + (dx * g.ax() * 2);
			let h = g._maxHeight + (dy * g.ay() * 2);
			// should round to nearest 2 px
			this.browser().setMaxWidth(this.clamp(240,w,1280,2)); //  Math.round((g.@maxWidth + (dx * g.ax * 2)) / 2) * 2 
			this.browser().setMaxHeight(this.clamp(140,h,1080,2)); // Math.round((g.@maxHeight + (dy * g.ay * 2)) / 2) * 2
			return this;
		};
		
		
		// log "onresizeupdate",g
		let l = g.layout();
		let o = {
			width: l.width() + dx * g.ax(),
			height: l.height() + dy * g.ay(),
			left: l.left(),
			top: l.top(),
			targetRef: this.data().id(),
			mask: (this._layoutMask || 0)
		};
		
		o.width = Math.round(Math.max(o.width,120) / 2) * 2;
		o.height = Math.round(Math.max(o.height,80) / 2) * 2;
		
		if (g.ax() < 0) {
			o.left += (o.width - l.width()) * g.ax();
			o.left = Math.max(o.left,20);
		};
		
		if (g.ay() < 0) {
			o.top += (o.height - l.height()) * g.ay();
		};
		
		this.redraw(this._layout.set(o).ensureInsideParent());
		this.data().setLayout(this._layout.clone());
		return this.data().space().emit('rearranging',this.data());
	};
	
	tag.prototype.onresizeend = function (g){
		this.log("onresizeend",this._layoutMask);
		this._layoutMask = 0;
		this.onresizeupdate(g,true);
		return this.unflag('resizing');
	};
	
	tag.prototype.clientLayout = function (){
		return this._layout;
	};
	
	tag.prototype.redraw = function (layout){
		if(layout === undefined) layout = this._layout;
		let prev = this._prevLayout;
		
		let ax = layout.anchorX();
		let ay = layout.anchorY();
		let vw = this.space().vw();
		let vh = this.space().vh();
		
		let left = Math.round(layout.left()) + 'px';
		let top = Math.round(layout.top()) + 'px';
		
		// set css variables
		this.setMinWidth((vw < 500) ? 100 : 140);
		this.setWinHeight(Math.round(layout.height()));
		this.setWinWidth(Math.round(layout.width()));
		this.setWinMinScale(this.minWidth() / this.winWidth());
		this.setWinTop(Math.round(layout.top()) + (this.winHeight() * 0.5));
		this.setWinLeft(Math.round(layout.left()) + (this.winWidth() * 0.5));
		this.setWinScale((vw && vh) ? Math.min((vw - 40) / this.winWidth(),(vh - 100) / this.winHeight(),1) : 1);
		
		this.setAutoMinimize((this.winWidth() > vw * 0.3 && vw < 800));
		this.flag('autofit',this.autoMinimize());
		return this.flag('narrow',layout.width() < 150);
	};
	
	tag.prototype.reflow = function (force){
		if(force === undefined) force = false;
		var remote = this.browser().agentLayout();
		
		var vp = this.browser().space().view().box();
		var vw = vp.width;
		var vh = vp.height;
		
		this.setMinWidth((vw < 500) ? 100 : 140);
		this.setMaxWidth(this.browser().maxWidth() || Math.min(vw - 200,600));
		this.setMaxHeight(this.browser().maxHeight() || Math.min(vh - 200,460));
		this.setMaxMinScale(this.minWidth() / this.maxWidth()); // Math.min(vw / (maxWidth + ),yratio,1)
		this.setMaxScale((vw && vh) ? Math.min((vw - 40) / this.maxWidth(),(vh - 100) / this.maxHeight(),1) : 1);
		
		this.setWindowed(this.browser().windowed());
		this.setMinimized((this.browser().minimized() || (this.autoMinimize() && !(this.hasPointerFocus()) && !(this.hasUserFocus()))));
		this.setFocused(this.space().agent().focus() == this.browser());
		
		var v = remote._v;
		if (v == this._v && !force) { return };
		if (!remote._data) { return };
		
		var layout = this._layout || (this._layout = remote.clone());
		var mask = remote.mask();
		
		if (v != this._v || force) {
			if (this.autoPos() && this.autoSize()) {
				if (mask & Dimensions.RESIZING) {
					layout.resizeParent(vw,vh).resize(remote.width(),remote.height(),mask);
				} else {
					layout.set(remote.toObject()).resizeParent(vw,vh);
				};
			} else if (this.autoSize()) {
				layout.resizeParent(vw,vh).resize(remote.width(),remote.height());
				// should autosize no matter what?
			} else if (this.autoPos()) {
				this;
			};
		} else {
			layout.resizeParent(vw,vh);
		};
		
		this._v = v;
		layout.round();
		
		this.redraw(this._layout = layout);
		
		if (force || !this.browser().space().isEditing()) {
			this.data().setLayout(layout.clone());
		};
		return;
	};
	
	tag.prototype.visibleDidSet = function (bool){
		this.flag('visible',bool);
		if (this._layout) {
			var fit = this._layout.clone().ensureInsideParent();
			return this.data().setLayout(fit);
		};
	};
	
	
	tag.prototype.minimizedDidSet = function (bool){
		this.transitioning();
		this.flag('minimized',bool);
		return this;
	};
	
	tag.prototype.transitioning = function (time){
		var self = this;
		if(time === undefined) time = 400;
		let mode = self.space().timeline().mode();
		if (mode == 'seeking') { return };
		clearTimeout(self._transitioningTimeout);
		self.flag('transitioning');
		return self._transitioningTimeout = setTimeout(function() {
			return self.unflag('transitioning');
		},time);
	};
	
	tag.prototype.windowedDidSet = function (bool){
		this.transitioning();
		if (bool) {
			this.flag('windowed');
			return this.unflag('centered');
		} else {
			this.flag('centered');
			return this.unflag('windowed');
		};
	};
	
	
	tag.prototype.targetForPointer = function (){
		return this;
	};
	
	tag.prototype.nodeForLayout = function (){
		return this._frame;
	};
	
	tag.prototype.resetLayout = function (){
		this.setAutoSize(true);
		this.setAutoPos(true);
		this._v = -1;
		this.reflow(true);
		return this;
	};
	
	tag.prototype.hasLocalLayout = function (){
		return !this.data().space().isEditing() && (!(this.autoPos()) || !(this.autoSize()));
	};
	
	tag.prototype.dispose = function (){
		return this;
	};
	
	tag.prototype.isLoading = function (){
		return this.browser().page() && this.browser().page().isLoading();
	};
	
	tag.prototype.gotoUrlInput = function (e){
		try {
			e.stop().prevent();
			let url = e.target().value();
			if (url != this.browser().url()) { this.go(url) };
			return e.target().blur();
		} catch (e) { };
	};
	
	tag.prototype.showSettings = function (){
		return this.uxa().open((_1(BrowserConfigurationDialog).flag('modal')).bindData(this,'browser',[]).setFormData(this.browser().configurationData()).end());
	};
	
	tag.prototype.closeWindow = function (){
		this.browser().setVisible(false);
		return this;
	};
	
	tag.prototype.minimize = function (){
		this.browser().setMinimized(true);
		return this;
	};
	
	tag.prototype.toggleMinimized = function (){
		var v_;
		return (this.browser().setMinimized(v_ = !this.browser().minimized()),v_);
	};
	
	tag.prototype.toggleWindowed = function (){
		this.browser().setWindowed(!this.browser().windowed());
		
		if (this.browser().windowed()) {
			var fit = this._layout.clone().ensureInsideParent();
			fit.set({height: Math.min(this.space().vh() - 180,fit.height())});
			fit.set({width: Math.min(this.space().vw() - 80,fit.width())});
			this.redraw(this._layout = fit);
			this.browser().setLayout(this._layout.clone());
		} else if (!this.browser().maxWidth()) {
			this.browser().setMaxWidth(this.clamp(800,this._layout.width(),this.space().vw() - 200));
			this.browser().setMaxHeight(this.clamp(460,this._layout.height(),this.space().vh() - 200));
		};
		return;
		// console.log "set windowed layout",fit
		// browser.setLayout(fit)
	};
	
	
	tag.prototype.focusWidgetForNode = function (){
		return this.browser();
	};
	
	tag.prototype.render = function (){
		var $ = this.$, t0, t1, t2;
		if (true) {
			return this;
		};
		
		// decide on loading etc
		if (this.browser().page() != this.page()) {
			let live = this.space().isPlaying() || this.space().isLive();
			let req = this.browser().page();
			
			if (live) {
				this._indicator && this._indicator.start  &&  this._indicator.start();
			};
			
			if (req && req.loaded()) {
				this._indicator && this._indicator.stop  &&  this._indicator.stop();
				this.setPage(req);
			};
			
			this;
		};
		
		if (this.runner().isActive() && !(this.isLoading())) {
			this.sendStyleSheets();
		};
		
		if (this.page()) {
			this.page().syncStyleSheets(this.data().space().files());
		};
		
		
		
		var history = this.browser().history();
		
		if (this._mounted) {
			this.reflow();
			// sync properties from browser
		};
		
		// mode = browser.mode
		// how much if this do we need to render?
		
		return this.$open(0).flagIf('loading',this.isLoading()).dataset('gesture','move').setVisible(this.browser().visible()).flagIf('detached',this.hasLocalLayout()).setChildren($.$ = $.$ || [
			this._cover = this._cover||_1('div',this).flag('cover').on$(0,['tap','minimize'],this),
			t0 = this._frame = this._frame||(t0=_1(BrowserFrame,this)).flag('frame').setContent([
				t1 = this._chrome = this._chrome||(t1=_1('div',t0)).flag('chrome').setContent([
					_1('div',$,0,this._chrome).flag('resizer').flag('left').dataset('gesture','resize,l'),
					_1('div',$,1,this._chrome).flag('resizer').flag('right').dataset('gesture','resize,r'),
					this._header = this._header||_1('div',t1).flag('header').setContent([
						_1('div',$,2,this._header).flag('tools').setContent([
							_1('div',$,3,2).flag('tool').flag('round').flag('close').on$(0,['tap','stop','closeWindow'],this),
							_1('div',$,4,2).flag('tool').flag('round').flag('min').on$(0,['tap','stop','minimize'],this),
							_1('div',$,5,2).flag('tool').flag('round').flag('max').on$(0,['tap','stop','toggleWindowed'],this),
							_1('div',$,6,2).flag('tool').dataset('icon','browserback'),
							_1('div',$,7,2).flag('tool').on$(0,['tap','stop',['go',1]],this).dataset('icon','browserforward'),
							_1('div',$,8,2).flag('tool').on$(0,['tap','stop','refresh'],this).dataset('icon','browserrefresh')
						],2),
						
						// visible input elements 
						_1(BrowserPathField,$,9,this._header).flag('path').on$(0,['change','onpathchange'],this),
						// <input.path type='text' value=(browser.url or "") :keydown.enter.gotoUrlInput>
						_1('div',$,10,this._header).flag('tool').dataset('icon','morevert').on$(0,['tap','stop','showSettings'],this)
					],2),
					
					_1('div',$,11,t1).flag('resizer').flag('bottom').dataset('gesture','resize,b'),
					_1('div',$,12,t1).flag('resizer').flag('br').dataset('gesture','resize,b,r'),
					_1('div',$,13,t1).flag('resizer').flag('bl').dataset('gesture','resize,b,l')
				],2),
				
				t2 = this._body = this._body||(t2=_1('div',t0)).flag('body'),
				
				this._indicator = this._indicator||_1(Indicator,t0).flag('indicator').flag('abs').flag('manual').setType('forward')
			],2)
		],2).synced((
			this._frame.setTabindex(-1).end((
				$[0].end(),
				$[1].end(),
				$[5].flagIf('active',(!(this.windowed()))),
				$[6].on$(0,['tap','stop',['go',-1]],this).flagIf('disabled',!history.hasPrev()).end(),
				$[7].flagIf('disabled',!history.hasNext()).end(),
				$[8].end(),
				$[9].setContent(this.browser().url() || "index.html",3).end(),
				$[10].end(),
				$[11].end(),
				$[12].end(),
				$[13].end(),
				this._body.setContent([
					(this._frameCover = this._frameCover||_1('div',t2).flag('frameCover').flag('mainCover').setContent([
						_1('div',$,14,this._frameCover).flag('tool').flag('run').dataset('icon','browserrefresh').on$(0,['tap','stop','refresh'],this),
						_1('div',$,15,this._frameCover).flag('tool').flag('follow').dataset('icon','visibility').on$(0,['tap','stop','resetLayout'],this)
					],2)).end((
						$[14].end(),
						$[15].flagIf('disabled',(!(this.hasLocalLayout()))).end()
					,true)),
					
					(this.page() && this.page().loading()) ? (
						($[16] || _1('div',$,16,t2).flag('frameCover').flag('bundler').setContent(
							$[17] || _1(SKDoubleBounce,$,17,16)
						,2)).end((
							$[17].end()
						,true))
					) : void(0),
					
					(this.page() && this.page().cancelled()) ? (
						($[18] || _1('div',$,18,t2).flag('frameCover').flag('error').flag('sm').setContent($[19] || _1('div',$,19,18).setContent([
							_1('h2',$,20,19).setText("Something went wrong"),
							_1('p',$,21,19).setText("The tracker has stopped because of excessive amount of events originating from the page.\nThis could be due to certain browser extensions. Try disabling extensions to see if it helps."),
							_1('p',$,22,19).setContent([
								_1('span',$,23,22).setText("For more help, "),
								_1('a',$,24,22).setHref("https://gitter.im/scrimba_community/Lobby").setTarget("_blank").setText("chat with us"),
								_1('span',$,25,22).setText(" or "),
								_1('a',$,26,22).setHref("https://github.com/scrimba/community/issues").setTarget("_blank").setText("file an issue")
							],2)
						// For more help, [chat with us](https://gitter.im/scrimba_community/Lobby) or [file an issue](https://github.com/scrimba/community/issues).
						],2),2)).end((
							$[24].end(),
							$[26].end()
						,true))
					) : void(0),
					(this._player = this._player||_1(PlayerFrame,t2).flag('player').setSrc("about:blank").setSrcdoc("<!DOCTYPE html><html></html>").setSandbox("allow-same-origin")).bindData(this,'page',[]).end()
				],1),
				this._indicator.end()
			,true))
		,true));
	};
});

function Browser(){ return PaneWidget.apply(this,arguments) };

Imba.subclass(Browser,PaneWidget);
exports.Browser = Browser; // export class 
Browser.register('browser');

Browser.option('npmPackages');
Browser.option('layout',{overridable: true,type: Dimensions,action: ACTION.BROWSER_LAYOUT});
Browser.option('page',{type: PlayerPage});
Browser.option('url');
Browser.option('rootPath',{'default': '/'});
Browser.option('catchallPath');

Browser.option('visible',{'default': false});
Browser.option('minimized',{'default': false,overridable: true});
Browser.option('windowed',{'default': true,overridable: true});

Browser.option('maxWidth');
Browser.option('maxHeight');

Browser.prototype.isResolvingPackages = function(v){ return this._isResolvingPackages; }
Browser.prototype.setIsResolvingPackages = function(v){ this._isResolvingPackages = v; return this; };

Browser.prototype.configurationData = function (){
	return {
		rootPath: this.rootPath(),
		catchallPath: this.catchallPath()
	};
};

Browser.prototype.history = function (){
	return this._history || (this._history = new History(this));
};

Browser.prototype.browser = function (){
	return this;
};

Browser.prototype.posToScreen = function (x,y,sl,cl){
	
	// fallback to autopos?
	if (this.minimized() || !(this.windowed()) || this.node().autoMinimize()) {
		return null;
	};
	
	return Browser.prototype.__super__.posToScreen.apply(this,arguments);
};

Browser.prototype.setup = function (){
	var self = this;
	self.space().on('quicksave',function(file) {
		self.log("quicksave",file);
		if (file) { return self.fileDidSave(file) };
	});
	self.node();
	return self;
};

Browser.prototype.runDomain = function (){
	if (false) {} else {
		return "run.scrimba.com";
	};
};

Browser.prototype.pushURI = function (){
	return ("https://" + this.runDomain() + "/static/tmp/" + (this.space().branch().id()));
};

Browser.prototype.baseURI = function (idx){
	if(idx === undefined) idx = -1;
	if (this.space().branch().isLocal()) {
		return ("" + this.pushURI() + "/");
	} else {
		return ("https://" + this.runDomain() + "/static/" + (this.space().branch().id()) + "/" + idx + "/");
	};
};

Browser.prototype.normalizeURL = function (url){
	if (url.startsWith(this.baseURI())) {
		return url.slice(this.baseURI().length);
	} else {
		return url;
	};
};

Browser.prototype.pushTmpState = function (){
	var branch = this.space().branch();
	if (!branch.isLocal()) {
		// check if it will become a branch
		if (!branch.isEditing()) {
			// force fork if we are not editing
			this.push_(ACTION.PING,[]);
		} else {
			return Promise.resolve(true);
		};
	};
	
	return fetch(this.pushURI(),{method: 'POST',
	body: JSON.stringify(this.space().toRunStaticSnapshot()),
	headers: {
		"Content-Type": "application/json"
	}});
};

Browser.prototype.clientLayout = function (){
	return (this._clientLayout || (this._clientLayout = new Dimensions(null))).wrap(this._node ? this._node._layout : null);
};

Browser.prototype.deserialize = function (o,state){
	if (o.page && false) {
		o.page = PlayerPage.fromOptionValue(o.page,this);
	};
	return Browser.prototype.__super__.deserialize.apply(this,arguments);
};

Browser.prototype.node = function (){
	return this._node || (this._node = (_1(BrowserView)).setData(this).end());
};

Browser.prototype.stop = function (){
	return this._node && this._node.stop  &&  this._node.stop();
};

Browser.prototype.run = function (){
	if (this.space().simulator()) {
		this.space().simulator().convertToBrowser();
	};
	
	this.refresh();
	return this;
};

Browser.prototype.refresh = function (){
	this.node().refresh();
	return this;
};

Browser.prototype.fileDidSave = function (file){
	if (this.space().simulator()) {
		return;
	};
	
	if (file.ext() == 'css') {
		// saving css files should not trigger a reload
		return this;
	} else if (file.ext() == 'html') {
		// saving should only trigger reload if this is the
		// current page of browser
		if (this.url().indexOf(file.name()) >= 0) {
			this.refresh();
		};
	} else {
		this.refresh();
	};
	return this;
};

Browser.prototype.enabled = function (){
	return true;
};

Browser.prototype.title = function (){
	return 'Preview';
};

Browser.prototype.npmPackageNames = function (){
	return (this.npmPackages() || {resolved: []}).resolved;
};

Browser.prototype.parsePackageQuery = function (query,map){
	var name = query.match(/.[^@]*/)[0];
	var version = query.substr(len$(name) + 1);
	
	return map[name] = version || "*";
};

Browser.prototype.currentPackageMap = function (){
	var map = {};
	for (let i = 0, items = iter$(this.npmPackageNames()), len = items.length; i < len; i++) {
		this.parsePackageQuery(items[i],map);
	};
	return map;
};

Browser.prototype.addPackages = function (entries){
	var map = Object.assign(this.packageMap(),entries);
	return this.overwritePackages(map);
};

Browser.prototype.overwritePackages = async function (map){
	var items = [];
	for (let name in map){
		let version;
		version = map[name];items.push(("" + name + "@" + version));
	};
	var bundle = await this.resolvePackages(items);
	this.setNpmPackages(bundle);
	return this;
};

Browser.prototype.addPackage = function (query){
	var map = this.currentPackageMap();
	this.parsePackageQuery(query,map);
	return this.overwritePackages(map);
};

Browser.prototype.removePackage = function (name){
	var v_;
	var map = this.currentPackageMap();
	(((v_ = map[name]),delete map[name], v_));
	return this.overwritePackages(map);
};

Browser.prototype.upgradePackage = function (name){
	return this.addPackage(name);
};

Browser.prototype.resolvePackages = async function (packages){
	this.setIsResolvingPackages(true);
	try {
		var result = await this._resolvePackages(packages);
	} finally {
		this.setIsResolvingPackages(false);
		Imba.commit();
	};
	return result;
};

Browser.prototype._resolvePackages = async function (packages){
	
	if (len$(packages) == 0) {
		return;
	};
	
	var url = ("/rpc/yaas/resolve?patterns=" + window.encodeURIComponent(packages.join(",")));
	var result = await window.fetch(url);
	this.setIsResolvingPackages(false);
	
	if (result.status == 200) {
		var json = await result.json();
		this.log("returned from yaas",result,json);
		return json;
	} else {
		throw new Error(("could not resolve " + packages));
	};
};


Browser.prototype.dispose = function (){
	return this._node && this._node.dispose  &&  this._node.dispose();
};
