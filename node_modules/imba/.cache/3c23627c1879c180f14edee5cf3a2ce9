var Imba = require('imba'), _2 = Imba.createTagCache, _1 = Imba.createElement;
var Format = require('./Formatters').Format;

var applyStyles = function(code,ctx,lines,o) {
	if(o === undefined) o = {};
	if (code.indexOf('<span') >= 0) { return code };
	
	if (lines) {
		code = code.split("\n").slice(0,lines);
		code = code.map(function(line) {
			let idx0 = line.indexOf('<');
			let idx1 = line.lastIndexOf('<');
			let end = line.indexOf('>');
			if (line.length > 80) {
				if (idx0 == -1) {
					return line.slice(0,80);
				};
				if (idx0 == idx1 && idx0 == 0 && end == line.length - 1) {
					return line.slice(0,70) + '>';
				};
				if (line.length > 300) {
					return line.replace(/(<.|>)/g,'').slice(0,80);
					// let end = line.indexOf('>')
					// let sub = line.slice(idx0 + 1,end)
				};
			};
			
			return line;
		});
		
		code = code.join("\n");
	};
	
	var level = 0;
	var lnr = 1;
	var lpfx = " ";
	
	if (o.plain) {
		return "    " + code.replace(/(<.|>)/g,'').replace(/\n/g,"\n    ");
	};
	
	code = code.replace(/(<.|>|\n)/g,function(m) {
		if (m[0] == '<') {
			level++;
			var nr = m.charCodeAt(1) - 64;
			var tok = ctx.hl[nr];
			return ("<span class='tok-" + tok + "'>");
		} else if (m[0] == '>') {
			level--;
			return "</span>";
		} else if (m[0] == '\n') {
			lnr++;
			if (lnr == 10) {
				lpfx = "";
			};
			if (o.lineNumbers) {
				return ("\n<i>" + lpfx + lnr + "</i>  ");
			} else {
				return "\n";
			};
		};
	});
	
	while (level > 0){
		level--;
		code = code + '</span>';
	};
	
	if (o.lineNumbers) {
		code = "<i> 1</i>  " + code;
	};
	
	return code;
};


var CastPreview = Imba.defineTag('CastPreview', function(tag){
	
	tag.prototype.model = function(v){ return this._model; }
	tag.prototype.setModel = function(v){ this._model = v; return this; };
	tag.prototype.type = function(v){ return this._type; }
	tag.prototype.setType = function(v){ this._type = v; return this; };
	tag.prototype.__data = {watch: 'draw',name: 'data'};
	tag.prototype.data = function(v){ return this._data; }
	tag.prototype.setData = function(v){
		var a = this.data();
		if(v != a) { this._data = v; }
		if(v != a) { this.draw && this.draw(v,a,this.__data) }
		return this;
	};
	tag.prototype.__progress = {watch: 'progressDidSet',name: 'progress'};
	tag.prototype.progress = function(v){ return this._progress; }
	tag.prototype.setProgress = function(v){
		var a = this.progress();
		if(v != a) { this._progress = v; }
		if(v != a) { this.progressDidSet && this.progressDidSet(v,a,this.__progress) }
		return this;
	};
	tag.prototype.__maxlines = {'default': 14,name: 'maxlines'};
	tag.prototype.maxlines = function(v){ return this._maxlines; }
	tag.prototype.setMaxlines = function(v){ this._maxlines = v; return this; }
	tag.prototype._maxlines = 14;
	
	tag.prototype.progressBar = function (){
		let $ = this.$$ || (this.$$ = {});
		return (this._progressBar = this._progressBar||_1('div',this).flag('progressBar'));
	};
	
	tag.prototype.progressDidSet = function (val){
		let pct = parseInt(Math.min(1,Math.max(0,val || 0)) * 100);
		return this.progressBar().css('width',pct + '%');
	};
	
	tag.prototype.draw = function (){
		var $ = ($_ = this.$).$draw$ || ($_.$draw$ = _2(this)), self = this;
		if (!(self.data() && self.data().preview)) { return };
		if (self._drawTimeout) { clearTimeout(self._drawTimeout) };
		// return self
		
		let type = self.data().type;
		let npm = self.data().preview.npm || [];
		let files = self.data().preview.files;
		let file = files.filter(function(item) { return item[2]; })[0];
		
		var pkgs = npm.map(function(item) { return item.split("@")[0]; });
		// code = code.replace(/\n{3,}/g,'\n\n')
		
		var flagify = function(v) {
			return 'label-' + v.toLowerCase().replace(/[^A-Za-z\-\_\d]/g,'');
		};
		
		self.$open('draw0').setFlag(-1,self.data().privacy).setChildren([
			self.progress() ? (
				($[0] || _1('div',$,0,self).flag('progress')).setContent(self.progressBar(),3)
			) : void(0),
			// <.tabs>
			// 	<b.type .{type}> type or ''
			// 	for item,i in files
			// 		<b .sel=(item[2])> item[0]
			(self._code = self._code||_1('pre',self).flag('code'))
		// <.meta>
		// 	<.npm.packages>
		// 		for item in pkgs
		// 			<.pkg.label .{flagify(item)}> item
		// 	
		// 	if data:type == 'tutorial' and !data.isPublished
		// 		<.draft.label> 'draft'
		// 		
		// 	if data:privacy != 'public'
		// 		<.privacy.label .{flagify(data:privacy)}> data:privacy
		// 	
		// 	if data:duration
		// 		<.duration.label> Format.duration(data:duration)
		],1).synced();
		
		if (true) {
			if (file) {
				var code = applyStyles(file[1],self.data().preview,self.maxlines(),{plain: true});
				self._code.dom().innerHTML = code;
				self._code.flag('tmp');
			};
			return self;
		};
		
		if (!(file && false)) { return self };
		
		return self._drawTimeout = setTimeout(function() {
			var code = applyStyles(file[1],self.data().preview,self.maxlines());
			return self._code.dom().innerHTML = code;
		},0);
	};
})
exports.CastPreview = CastPreview;

