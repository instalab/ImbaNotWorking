function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var LCRange = require('../protocol').LCRange;

var compareRangesUsingEnds = function(a,b) {
	var al1 = a[0] - 1;
	var ac1 = a[1] - 1;
	var al2 = (a[0] + (a[3] || 0)) - 1;
	var ac2 = (a[1] + (a[2] || 0)) - 1;
	
	var bl1 = b[0] - 1;
	var bc1 = b[1] - 1;
	var bl2 = (b[0] + (b[3] || 0)) - 1;
	var bc2 = (b[1] + (b[2] || 0)) - 1;
	
	if (al2 == bl2) {
		if (ac2 == bc2) {
			if (al1 == bc1) {
				return ac1 - bc1;
			};
			return al1 - bl1;
		};
		return ac2 - bc2;
	};
	return al2 - bl2;
};

var sortOpsAscending = function(a,b) {
	let r = compareRangesUsingEnds(a[0],b[0]);
	if (r == 0) {
		return a.I - b.I;
	};
	return r;
};


var sortOpsDescending = function(a,b) {
	let r = compareRangesUsingEnds(a[0],b[0]);
	if (r == 0) {
		return b.I - a.I;
	};
	return -r;
};

var diffString = exports.diffString = function(str0,str1) {
	var i = 0;
	var l0 = str0.length;
	var l1 = str1.length;
	var minLen = Math.min(l0,l1);
	var maxLen = Math.max(l0,l1);
	var l = maxLen;
	
	var left = 0;
	// find first part that is different
	while (i < minLen){
		var chr0 = str0[i];
		var chr1 = str1[i];
		i++;
		
		if (chr0 == chr1) {
			left++;
		} else {
			break;
		};
	};
	
	// equal all the way
	if (left == i) {
		// cut it
		if (l0 > l1) {
			return [left,l0,''];
		} else if (l1 > l0) {
			return [left,left,str1.slice(left)];
		};
		return [];
	};
	
	// go from the end -- look at first part that is the same
	while (l0 >= left && l1 >= left){
		chr0 = str0[--l0];
		chr1 = str1[--l1];
		
		if (chr0 != chr1) {
			break;
		};
	};
	
	// right = Math.max(l0 + 1,left)
	var ins = str1.slice(left,l1 + 1);
	return [left,l0 + 1,ins];
};


var patchString = exports.patchString = function(str,diff) {
	if (diff instanceof Array) {
		return str.substr(0,diff[0]) + diff[2] + str.slice(diff[1]);
	} else {
		return diff;
	};
};

var getLineMaxColumn = exports.getLineMaxColumn = function(line) {
	return line.length;
};

var LINE_REGEX = /\r\n|\r|\n/;

function TextModel(raw){
	if(raw === undefined) raw = '';
	this._raw = raw;
	this._lines = raw.split(LINE_REGEX);
	this.reset();
};

exports.TextModel = TextModel; // export class 
TextModel.prototype.lines = function(v){ return this._lines; }
TextModel.prototype.setLines = function(v){ this._lines = v; return this; };

TextModel.prototype.reset = function (){
	this._edited = [];
	this._body = null;
	return this;
};

TextModel.prototype.reversedOperation = function (op){
	var str = this.textInRange(op[0]);
	var rng = this.expandedRange(op[0],op[1]);
	return [rng,str];
};

TextModel.prototype.expandedRange = function (start,text){
	var range;
	var lines = (text || '').split(LINE_REGEX);
	var l2 = start[0] + (lines.length - 1);
	var col = lines[lines.length - 1].length;
	if (start[0] == l2) {
		col += start[1];
	} else {
		col += 1;
	};
	
	return range = [start[0],start[1],col - start[1],l2 - start[0]];
};

TextModel.prototype.textInRange = function (pos,lines){
	if(lines === undefined) lines = this._lines;
	var l1 = pos[0] - 1;
	var c1 = pos[1] - 1;
	
	var l2 = (pos[0] + (pos[3] || 0)) - 1;
	var c2 = (pos[1] + (pos[2] || 0)) - 1;
	
	// var l2 = (pos[2] or pos[0]) - 1
	// var c2 = (pos[3] or pos[1]) - 1
	
	if (l1 == l2) {
		return lines[l1].slice(c1,c2);
	};
	
	var parts = lines[l1++].slice(c1);
	while (l1 < l2){
		parts += "\n" + lines[l1++];
	};
	
	parts += "\n" + lines[l2].slice(0,c2);
	return parts;
};

TextModel.prototype.apply = function (ops){
	var lines = this._lines;
	var rev = null;
	
	// uncache body
	this._body = null;
	
	if (!ops.UNDO) {
		ops.FWD = 1;
		rev = ops.UNDO = [];
		rev.UNDO = ops;
		rev.REV = 1;
	};
	
	let len = ops.length;
	let i = 0;
	
	// if first apply - sort	
	if (len > 1 && ops.FWD) {
		ops = ops.map(function(op,i) {
			op.I = i;
			return op;
		}).sort(sortOpsDescending);
	};
	
	// apply the operations in order
	while (i < len){
		let op = ops[i++];
		var pos = op[0];
		var ins = op[1] || '';
		
		var ln = pos[0] - 1;
		var col = pos[1] - 1;
		var ln2 = (pos[0] + (pos[3] || 0)) - 1;
		var col2 = (pos[1] + (pos[2] || 0)) - 1;
		
		if (rev) {
			rev.unshift(this.reversedOperation(op));
		};
		
		// the range spans multiple lines
		if (ln != ln2) {
			let start = lines[ln].slice(0,col);
			let end = lines[ln2].slice(col2);
			lines[ln] = start + end;
			lines.splice(ln + 1,(ln2 - ln));
			col2 = col;
		};
		
		let line = lines[ln];
		
		line = line.slice(0,col) + ins + line.slice(col2);
		
		if (ins.indexOf('\n') >= 0) {
			// console.log "multiline"
			lines.splice.apply(lines,[].concat([ln,1], [].slice.call(line.split(LINE_REGEX))));
		} else {
			lines[ln] = line;
		};
		
		// if len > 1
		// 	console.log "apply after",i - 1,pos,ins
		// 	console.log lines.join("\n")
	};
	
	return ops;
};

TextModel.prototype.getValue = function (){
	return this.body();
};

TextModel.prototype.body = function (){
	return this._body || (this._body = this._lines.join("\n"));
};

TextModel.prototype.getDiff = function (lines){
	var locals = this._lines;
	
	if ((typeof lines=='string'||lines instanceof String)) {
		lines = lines.split(LINE_REGEX).map(function(text,nr) { return {_text: text}; });
	};
	
	var remote = lines;
	
	var rl = len$(remote);
	var ll = len$(locals);
	
	var l1 = 0;
	var c1 = 0;
	var l2 = rl - 1;
	var c2 = 0;
	var text;
	
	var lEnd = ll - 1;
	var minLines = Math.min(rl,ll);
	
	// compare forwards
	while (l1 < minLines){
		if (locals[l1] != remote[l1]._text) {
			// console.log "line different",l1,[locals[l1],remote[l1]:_text]
			break;
		};
		l1 += 1;
	};
	
	// all lines shared are the same
	if (l1 == minLines) {
		if (ll == rl) {
			return null;
		} else if (ll > rl) {
			// insert at the end of last line
			l1 = l2;
			c1 = c2 = getLineMaxColumn(remote[l2]._text);
			text = "\n" + locals.slice(rl).join("\n");
			// end column as well
		} else if (rl > ll) {
			// we should remove from the end
			// there are more lines in remote
			l1 = ll - 1;
			c1 = getLineMaxColumn(locals[l1]);
			l2 = rl - 1;
			c2 = getLineMaxColumn(remote[l2]._text); // max length
			text = '';
		};
	} else {
		while (lEnd > l1 && l2 > l1){
			if (locals[lEnd] != remote[l2]._text) {
				// console.log "different line",locals[lEnd],remote[l1]
				break;
			};
			lEnd -= 1;
			l2 -= 1;
		};
		
		// console.log l1,l2,lEnd,rl,ll
		// some lines should be removed at end?
		if (rl > ll && false) { // lEnd == (ll - 1)
			l2 = l2 + 1;
			c2 = 0;
			// get the content that have changed though?
			text = '';
		} else {
			c2 = getLineMaxColumn(remote[l2]._text);
		};
		
		if (l1 == l2 && lEnd >= l2) {
			var txt = remote[l1]._text;
			var localStr = locals.slice(l1,lEnd + 1).join("\n");
			var strdiff = diffString(txt,localStr);
			c1 = strdiff[0];
			c2 = strdiff[1];
			text = strdiff[2];
			// console.log "diffed",strdiff,[txt,localStr]
		};
	};
	
	var pos = [l1 + 1,c1 + 1,(c2 - c1),(l2 - l1)];
	
	if (text == undefined) {
		text = this.textInRange([l1 + 1,c1 + 1,1000,(lEnd - l1)]);
	};
	
	return [pos,text];
};
