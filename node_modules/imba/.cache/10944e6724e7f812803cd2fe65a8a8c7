function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var db$ = require("./db"), db = db$.db, rdb = db$.rdb;

var fs = require('fs');
var msgpack = require('msgpack-lite');
var crypto = require('crypto');

var env = require('../env');
var manifest = require('../../assets/manifest.json');
var util = require('../util');

var protocol$ = require('../scrimba/protocol'), MSG = protocol$.MSG, CAST = protocol$.CAST, SCON = protocol$.SCON, VERSION = protocol$.VERSION, ACTION = protocol$.ACTION, SPIV = protocol$.SPIV;
var DB = require('../store/db').DB;

var DB_INSTANCE = DB.instance();

var publisher = require('../services/publisher');
var emailer = require('../services/emailer');

var timestamps = {};

var Resource = require('../store/Resource').Resource;

var StreamBuffer = require('../scrimba/core/StreamBuffer').StreamBuffer;
var Mailchimp = require('../util/mailchimp').Mailchimp;
var Logger = require('../util/Logger').Logger;

var TimelineCues = require('../scrimba/util/TimelineCues').TimelineCues;

var previewer$ = require('../services/space-previewer'), previewForSpace = previewer$.previewForSpace, previewForState = previewer$.previewForState;

var password$ = require('./password'), hashPassword = password$.hashPassword, verifyPassword = password$.verifyPassword;

var googleSlidesImporter = require('../services/google-slides-importer');
// TODO URGENT currently we expose all methods in rpc
// should prefix private methods with _ or somehow mark
// the public methods public

// Should have a client-like api wrapper around the serverside api
var UserAgent = require('../util/UserAgent').UserAgent;

function API(user,req){
	this._cache = {};
	this._preloads = [];
	this._req = req;
	this._logger = new Logger();
	
	if (req) {
		// console.log "inited api with req",req
		this._ua = new UserAgent(req.get('user-agent'));
	};
	
	if ((typeof user=='string'||user instanceof String)) {
		user = this.db().get(user);
	} else if (user) {
		user = this.db().read(user);
	};
	
	this._user = user;
	this;
};

exports.API = API; // export class 
API.prototype.cache = function(v){ return this._cache; }
API.prototype.setCache = function(v){ this._cache = v; return this; };
API.prototype.__user = {watch: 'userDidSet',name: 'user'};
API.prototype.user = function(v){ return this._user; }
API.prototype.setUser = function(v){
	var a = this.user();
	if(v != a) { this._user = v; }
	if(v != a) { this.userDidSet && this.userDidSet(v,a,this.__user) }
	return this;
};
API.prototype.sid = function(v){ return this._sid; }
API.prototype.setSid = function(v){ this._sid = v; return this; };
API.prototype.ua = function(v){ return this._ua; }
API.prototype.setUa = function(v){ this._ua = v; return this; };

API.assetsPath = function (name){
	return ("/assets/" + (manifest[name] || name));
};

API.assetsUrl = function (name){
	var port;
	var portstr = '';
	if ((port = env.get('NGINX_PORT')) != 443) {
		portstr = (":" + port);
	};
	return ("https://" + env.get('HOSTNAME') + portstr + this.assetsPath(name));
};

API.prototype.stats = function (){
	return API.STATS;
};

API.prototype.platform = function (){
	return 'Server';
};

API.prototype.scope = function (){
	return this._scope || (this._scope = {
		user: this._user,
		uid: this.uid(),
		roles: this.roles(),
		isMod: this.roles().indexOf('mod') >= 0
	});
};

API.prototype.userDidSet = function (user,prev){
	this._roles = null;
	return this._scope = null;
};

API.prototype.log = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return this._logger.log.apply(this._logger,params);
};

API.prototype.sendTracking = function (){
	// do nothing
	return null;
};

API.prototype.mailchimp = function (){
	var api_key;
	return (this._mailchimp == null) ? (this._mailchimp = (api_key = env.get('MAILCHIMP_API_KEY')) ? (
		new Mailchimp(api_key)
	) : (
		null
	)) : this._mailchimp;
};

API.prototype.filesDir = function (){
	return env.get('FILES_DIR');
};

API.prototype.assetsPath = function (name){
	return API.assetsPath(name);
};

API.prototype.assetsUrl = function (name){
	return API.assetsUrl(name);
};

API.prototype.clientVersion = function (){
	return manifest.version;
};

API.prototype.monacoPath = function (){
	return manifest.monaco;
};

API.prototype.isEmbed = function (){
	return false;
};

API.prototype.isMobile = function (){
	return false;
};

API.prototype.localToken = function (){
	return null;
};

API.prototype.db = function (){
	return DB_INSTANCE || (DB_INSTANCE = new DB({}));
};

API.prototype.roles = function (){
	return this._roles || (this._roles = (this._user && this._user.roles || []));
};

API.prototype.uid = function (){
	return this._user && this._user.id || null;
};

API.prototype.isMod = function (){
	return this.roles().indexOf('mod') >= 0;
};

API.prototype.get = function (key){
	var self = this;
	if (key instanceof Array) {
		return key.map(function(id) {
			return self.db().get(id);
		});
	};
	
	return self.db().get(key);
};

API.prototype.load = function (key){
	var item = this.db().get(key);
	if (item.v == -3) {
		return item.fetch();
	};
	return Promise.resolve(item);
};

API.prototype.fetch = function (item){
	console.log("called fetch on server",item);
	return this.db().fetch(item,this);
};

API.prototype.put = function (item){
	let store = this.db().storeForId(item.id);
	return store.put(item,this);
};

API.prototype.ins = function (item,localId){
	let store = this.db().storeForId(item.id || localId);
	return store.ins(item,this);
};

// TODO more descriptive name?
API.prototype.prefetch = function (query){
	return this.db().prefetch(query,this);
};

API.prototype.syncdb = function (diffs){
	// NOT WORKING
	var t = Date.now();
	var items = [];
	for (let i = 0, ary = iter$(diffs), len = ary.length, diff; i < len; i++) {
		diff = ary[i];
		var name = diff[0];
		var res = {store: name,data: this.res(),state: {v0: this.v(),v: this.v1()}};
		if (name == 'mediafiles' || name == 'actions' || name == 'files') { continue; };
		var store = this.db().stores()[name];
		items = store.filter(function(item) { return item.v > diff.v; });
		// find the highest index
		var patch = {store: name,data: res,state: {v0: this.v(),v: this.v1()}};
	};
	
	
	console.log("syncdb took",Date.now() - t);
	return this;
};

API.prototype.getCurrentUser = function (){
	return Promise.resolve(this._user || null);
};

API.prototype.fetchUserByUsername = async function (username){
	var user = await db.table('users').where({username: username}).first();
	if (user && user.github_profile && user.github_profile.email) {
		user.github_profile.email = '';
	};
	return user;
};

API.prototype.userWithUsername = async function (username){
	var user = await db.table('users').where({username: username}).first();
	return user ? this.db().read(user) : {CODE: 404};
};

API.prototype.userWithEmail = async function (email){
	var user = await db.table('users').where({email: email}).first();
	return user ? this.db().read(user) : null;
};

API.prototype.userCreate = async function (data){
	var passwordHash = await hashPassword(data.password);
	
	var insertData = {
		email: data.email,
		name: data.name,
		password_hash: passwordHash
	};
	
	var userInsert = db.table('users').insert(insertData);
	var user = await db.raw('? ON CONFLICT DO NOTHING RETURNING *',[userInsert]).get('rows').get(0);
	if (user) {
		this.subscribeUser(user);
		return this.userLogin(user);
	};
};

API.prototype.userLogin = function (user){
	var self = this;
	return new Promise(function(resolve,reject) {
		return self._req.login(user,function(err) {
			if (err) {
				return reject(err);
			} else {
				self._user = self.db().read(user);
				return resolve(self._user);
			};
		});
	});
};

API.prototype.userAuthenticate = async function (email,password){
	var user = await db.table('users').where({email: email}).whereNotNull('password_hash').first();
	var isValid = await (user && verifyPassword(password,user.password_hash));
	if (isValid) {
		return this.userLogin(user);
	};
};

API.prototype.userForgotPassword = async function (email){
	var user = await db.table('users').where({email: email}).whereNotNull('password_hash').first();
	if (user) {
		var action = {
			uid: user.id,
			type: "ForgotPassword",
			state: 'queued',
			params: {
				id: user.id,
				token: util.uuid()
			}
		};
		
		var job = await this.db().actions().ins(action,this);
		await emailer.sendForgotPassword(job.id);
		return true;
	} else {
		return false;
	};
};

API.prototype.userResetPassword = async function (id,token,password){
	var action = await this.db().fetch(id);
	if (action.params.token != token) {
		return "invalid";
	};
	
	if (password) {
		var passwordHash = await hashPassword(password);
		await db.table('users').where({id: action.uid}).update({password_hash: passwordHash});
		return "updated";
	} else {
		return "valid";
	};
};

API.prototype.subscribeUser = function (user){
	if (!(this.mailchimp())) { return };
	
	var mergeFields = {
		USERNAME: user.username,
		FULLNAME: user.name
	};
	
	return this.mailchimp().subscribe('1475ca4552',user.email,mergeFields).catch(function(err) { return true; });
	
	// TODO: Should we ever log the response?
};

API.prototype.authWithGitHub = async function (gh_user){
	// console.log 'gh_user',gh_user
	var self = this;
	var user = await db.table('users').where({github_user_id: gh_user.id}).first();
	
	var profile = {};
	
	for (let o = gh_user._json, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];if (k.indexOf('url') >= 0) { continue; };
		profile[k] = v;
	};
	profile.email = gh_user.emails[0].value;
	if (user) {
		
		return db.table('users').where({id: user.id}).update({github_profile: JSON.stringify(profile)}).then(function() {
			user.github_profile = profile;
			return self._user = user; // set?
		});
	} else {
		user = {
			username: profile.login,
			name: profile.name,
			email: profile.email,
			location: profile.location,
			bio: profile.bio,
			github_user_id: profile.id,
			github_profile: profile
		};
		
		if (user.email) {
			self.subscribeUser(user);
		};
		
		// use db
		var id = await db.table('users').returning('id').insert(user);
		
		return self.fetchUserByUsername(user.username);
	};
};


API.prototype.castCreate = async function (params,snapshot,stream){
	
	// what if user is not logged in?!?
	var seed;
	console.log("castCreate",params,snapshot);
	
	var data = SCON.clone(params);
	data.spiv = SPIV;
	data.uid = this.uid();
	
	var snap = await (snapshot || this.castSnapshot(data.parent_id));
	
	if (seed = snap.seed) {
		data.parent_id || (data.parent_id = seed[0]);
		data.parent_index || (data.parent_index = seed[1]);
		data.parent_offset || (data.parent_offset = seed[2]);
	};
	
	var par = this.db().get(data.parent_id);
	
	if (par) {
		if (par.type == 'lab' || par.type == 'challenge') {
			data.type || (data.type = 'fork');
			data.members = [par.uid];
			data.privacy || (data.privacy = 'private');
		};
	};
	
	data.privacy || (data.privacy = 'public');
	// what if snapshot is not supplied?
	data.preview = previewForState(snap);
	data.edited_at = new Date();
	
	var buffer;
	
	if (stream) {
		// add empty lock event, forcing socket to re-lock
		stream.push(-ACTION.LOCK,[]);
		buffer = util.mpencode.apply(util,stream);
	} else {
		buffer = util.mpencode(-ACTION.SNAPSHOT,[snap]);
	};
	
	var cast = await this.ins(data,'c');
	
	await rdb.set(cast.id + ':stream3',buffer);
	
	return cast;
};

API.prototype.castSnapshot = async function (cid){
	var preset = await this.db().fetch(cid);
	
	// TODO we need to actually parse the stream
	// to figure out the index (and offset) of the
	// snapshot?
	if (preset) {
		var buffer = await this.streamRead(cid,0,-1);
		let chunks = StreamBuffer.decode(buffer);
		let i = chunks.length;
		while (--i >= 0){
			if (chunks[i] == -ACTION.SNAPSHOT) {
				let snap = chunks[i + 1];
				console.log("found snapshot!!",snap);
				if (i == 0) {
					console.log("mod the snapshot to have correct seed",[cid,0,0]);
					snap[0].seed = [cid,0,0];
				};
				return snap[0];
			};
		};
		return {};
	} else {
		return {};
	};
};

API.prototype.castRespond = async function (cid,snapshot){
	var cast = this.db().fetch(cid);
	var seed = snapshot.seed;
	var response = await this.db().spaces().first({type: 'fork',parent_id: cid,uid: this.uid()});
	
	// should move on to castCreate
	return response || this.castCreate({parent_id: cid},snapshot);
};

API.prototype.castDel = async function (id){
	// FIXME permissions
	var item = await this.db().fetch(id);
	if (item.uid != this.uid()) { return };
	return this.put({id: id,archived_at: new Date()});
};

API.prototype.castBranches = async function (id){
	var self = this;
	var cast = self.get(id);
	var items = await db.table('spaces').where({parent_id: id,archived_at: null});
	
	items = items.filter(function(item) {
		return (item.privacy == 'public' && cast.state != 'published') || item.uid == self.uid();
	});
	
	// go through api no?
	return items;
};

API.prototype.castCheckIntegrity = async function (id){
	var self = this;
	var item = await self.db().fetch(id);
	var draft = item.draft || {};
	var issues = [];
	var health = {
		cid: id,
		issues: issues
	};
	
	var byteLength = await rdb.strlen(id + ':stream3');
	health.byteLength = byteLength;
	
	var cues = new TimelineCues(draft);
	
	var audio = (draft.markers || []).filter(function(item) {
		return item.type == 'audio';
	});
	
	// clone json here already?
	
	await cues.audio().map(async function(item) {
		var file = await self.db().fetch(item[3]);
		var integrity = await file.checkIntegrity();
		
		if (integrity.error) {
			return issues.push(integrity);
		};
	});
	
	console.log("found audio",audio);
	
	return health;
};

API.prototype.castPreview = async function (id){
	var item = await this.db().fetch(id);
	// return item:preview if item:preview
	var preview = await previewForSpace(this,item);
	await item.update({preview: preview});
	return preview;
};

API.prototype.castComment = async function (id,params){
	params.cid = id;
	params.uid = this.uid();
	
	var cast = await this.db().spaces().fetch(id);
	var msg = await this.db().messages().ins(params);
	return msg;
};

API.prototype.castCommentReply = async function (parentId,params){
	var thread = await this.db().messages().fetch(parentId);
	
	params.cid = thread.cid;
	params.uid = this.uid();
	params.parent_id = thread.id;
	
	// params:type = 'answer'
	// var cast = await self.db.spaces.fetch(id)
	var msg = await this.db().messages().ins(params);
	return msg;
};

API.prototype.castSetProgress = async function (cid,progress){
	if (!(this.uid())) { return Promise.resolve(null) };
	
	let vid = ("y" + cid + "-" + this.uid());
	
	console.log("castSetProgress",vid);
	
	let item = await db.table('viewings').where({cid: cid,uid: this.uid()}).first();
	
	let data = {
		cid: cid,
		uid: this.uid(),
		progress: progress,
		updated_at: new Date()
	};
	
	if (!item || item.max_progress < progress) {
		data.max_progress = progress;
	};
	
	if (item) {
		// if it is more than 20 minutes since last progress - mark as another view
		if ((data.updated_at - item.updated_at) > (1000 * 60 * 20)) {
			data.views = (item.views || 0) + 1;
		};
		return db.table('viewings').update(data).where({id: item.id});
	} else {
		data.id = vid;
		data.views = 1;
		return db.table('viewings').insert(data);
	};
};

API.prototype.importSlidesFromGoogle = async function (url){
	var res = await googleSlidesImporter.fetch(url);
	
	for (let i = 0, items = iter$(res.slides), len = items.length, slide; i < len; i++) {
		slide = items[i];
		slide.blobId = await this.upsertBlob(slide.body);
		slide.body = null;
	};
	return res;
};

API.prototype.upsertBlob = async function (data){
	if ((typeof data=='string'||data instanceof String)) {
		data = Buffer.from(data,'utf8');
	};
	var shasum = crypto.createHash('sha1');
	shasum.update(data);
	var id = ("sha1:" + shasum.digest('hex'));
	// return Promise.resolve(id)
	var exists = await db.table('blobs').where({id: id}).first('id');
	await (!exists && db.raw('INSERT INTO blobs (id, content, uid) VALUES (?, ?, ?) ON CONFLICT DO NOTHING',[id,data,this.uid()]));
	return id;
};

API.prototype.fileCheckIntegrity = async function (id){
	var file;
	return file = await this.db().fetch(id);
};

API.prototype.checkIntegrity = async function (id){
	var $1;
	var item = await this.db().fetch(id);
	var resp = ($1 = item) && $1.checkIntegrity  &&  $1.checkIntegrity();
	return resp || {status: 0};
};

API.prototype.streamRead = function (id,rangeStart,rangeEnd){
	var key = id + ':stream3';
	if (rangeStart || rangeEnd != -1) {
		return rdb.getrangeBuffer(key,rangeStart,rangeEnd);
	} else {
		return rdb.getBuffer(key);
	};
};

API.prototype.groupJoin = async function (gid,params){
	// throw if no user?
	let group = await this.db().groups().get(gid);
	console.log("found group?",gid,params);
	
	if (!(this.uid())) {
		return null;
	};
	
	// check for existing membership
	var membership = await db.table('memberships').where({gid: gid,uid: this.uid()}).first();
	
	if (membership) {
		return membership;
	};
	
	// insert now?!
	membership = await this.db().memberships().ins({gid: gid,uid: this.uid()},this);
	return membership;
};


API.prototype.playlistCreate = async function (params){
	if (!(this.uid())) { return };
	params.privacy || (params.privacy = 'public');
	params.uid = this.uid();
	var playlist = await this.db().playlists().ins(params,this);
	return playlist;
};

API.prototype.playlistAddItems = async function (id,itemIds){
	var pl = await this.load(id);
	var array = pl.item_ids || [];
	
	for (let i = 0, items = iter$(itemIds), len = items.length, item; i < len; i++) {
		item = items[i];
		if (array.indexOf(item) < 0) { array.push(item) };
	};
	
	return this.put({id: id,item_ids: array});
};

API.prototype.playlistReorder = function (id,itemIds){
	return this.put({id: id,item_ids: itemIds});
};

API.prototype.playlistDel = async function (id){
	// FIXME permissions
	var item = await this.db().fetch(id);
	await item.update({archived_at: new Date()});
	return item;
};

API.prototype.registerView = async function (id){
	console.log("registerView!!",id);
	var res = await db.table('spaces').where({id: id}).increment('view_count',1);
	return {status: 0};
};

API.prototype.publish = async function (item,opts){
	if(opts === undefined) opts = {};
	var item = await this.db().fetch(item);
	
	console.log("server api.publish",item,opts,item.draft);
	
	var data = {
		uid: this.uid(),
		cid: item.id,
		type: "PublishJob",
		state: 'queued',
		params: {
			id: item.id,
			draft: item.draft
		}
	};
	
	for (let v, i = 0, keys = Object.keys(opts), l = keys.length, k; i < l; i++){
		k = keys[i];v = opts[k];data.params[k] = v;
	};
	
	var job = await this.db().actions().ins(data,this);
	// await item.update(state: 'publishing')
	await publisher.publish(job.id);
	return job;
};

API.prototype.rpc = function (name,args,options){
	var self = this;
	if(options === undefined) options = {};
	var res = self[name].apply(self,args);
	
	if (res && !res.then) {
		res = Promise.resolve(res);
	};
	
	return res.then(function(result) {
		if (options.type == 'arraybuffer') {
			return result;
		};
		
		if (result == null) {
			return result || null;
		};
		
		var key = JSON.stringify([name,args]);
		self.scope().action = name.toUpperCase();
		self.db().scoped(self.scope(),function() {
			return self._cache[key] = JSON.parse(JSON.stringify(result));
		});
		// if we force-read on server we will overwrite shared db-models
		return self._cache[key];
	});
};


API.prototype.appendToStream = function (id,chunks){
	return this;
};

API.prototype.streamgetrange = function (cid,byteOffset,byteEnd){
	return rdb.bufferapi('streamgetrange',cid,byteOffset,byteEnd);
};

API.prototype.trackingstream = function (sid){
	if (env.get('EXPOSE_TRACKINGSTREAM')) {
		return rdb.bufferapi('trackingstream',sid);
	} else {
		return Promise.resolve(null);
	};
};

API.prototype.appendToTrackingStream = function (sid,payload){
	return rdb.api('trackingappend',sid,payload);
};

API.prototype.updateViewState = async function (socket,state){
	try {
		// see if the socket has stored a state for this cast
		let zid = socket.sid;
		let cid = state.cid;
		let cache = socket._viewSessions || (socket._viewSessions = {});
		let prev = cache[cid];
		
		if (!(cid && this.db().spaces().has(cid) && state.played > 0)) { return };
		
		if (!prev) {
			// console.log "create state for view"
			let data = cache[cid] = {
				uid: this.uid(),
				zid: zid,
				cid: cid,
				played: state.played,
				ranges: state.ranges
			};
			cache[cid] = data;
			console.log("inserting viewsession",zid,state.played);
			let viewsession = await this.db().viewsessions().ins(data,this);
			cache[cid] = viewsession;
		};
		
		if (prev) {
			if (prev.played == state.played || !prev.update) { return };
			prev.update({played: state.played,ranges: state.ranges});
		};
	} catch (e) {
		console.log("error in updateViewState",e);
	};
	return this;
};

API.prototype.onpacket = async function (packet){
	var cmd;
	var id,item;
	var code = packet.CODE;
	var socket = packet.socket();
	var sid = packet.sid();
	var now = new Date();
	// console.log "packet",packet.CODE
	
	if (packet.CODE == MSG.TRACKING) {
		return this.appendToTrackingStream(sid,packet.payload());
	};
	
	// latest info about what the socket is watching etc
	if (packet.CODE == MSG.VIEWSTATE) {
		console.log(("packet viewstate " + this.uid() + " " + (socket.sid)));
		return this.updateViewState(socket,packet[1]);
	};
	
	if (code >= 100 && code < 200) {
		id = packet[1];
		item = this.db().get(id);
	};
	
	if (!item) {
		return false;
	};
	
	switch (packet.CODE) {
		case MSG.STREAMFLATTEN: {
			if (!item.hasMember(this.uid())) {
				console.warn("not allowed to push to this cast",this.uid(),id);
				return false;
			};
			
			let res = await rdb.bufferapi('streamflatten',sid,id,msgpack.encode([packet[2]]));
			packet.reply(res);
			break;
		}
		case MSG.STREAMAPPEND: {
			packet.retain();
			// let copy = Buffer.from(packet.data)
			
			if (!item.hasMember(this.uid())) {
				console.warn("not allowed to push to this cast",this.uid(),id);
				return false;
			};
			
			
			let byteOffset = packet[2];
			let byteEnd = byteOffset + packet.payload().byteLength;
			let res = await rdb.bufferapi('streamappend',sid,id,byteOffset,packet.payload());
			
			// the stream will by default return nothing if successfull
			if (res.length > 1) {
				console.log("will reply from streamappend",id,res,msgpack.decode(res));
				// when we are not allowed to append we need to send details about where/what went wrong
				packet.reply(res);
			} else {
				let lastEdit = item._lastEdit || item.edited_at;
				// update edited at if it is more than 120s behind
				if (!lastEdit || (now - lastEdit) > 120000) {
					console.log("update edited at",id,now,lastEdit);
					item.update({edited_at: now});
					item.edited_at = item._lastEdit = now;
				};
				
				// broadcast to everyone in room - no need to publish to the outer room?
				let channels = [id];
				if (null && Math.random() > 0.9) {
					console.log("chaosmonkey drop broadcast");
					channels = [];
				};
				
				this.broadcast(channels,packet.data(),socket);
				packet.reply(util.mpencode([MSG.OK,0]));
				this.stats().appends.mark(byteEnd - byteOffset);
			};
			
			return true;
			break;
		}
		case MSG.STREAMTRIM: { // [spaceid, versionid, lastByteToKeep]
			if (!item.hasMember(this.uid())) {
				return false;
			};
			
			packet.retain();
			let byteEnd = packet[2];
			let res = await rdb.bufferapi('streamtrim',sid,packet[1],packet[2],packet[3],packet.payload() || '');
			console.log("trimmed stream!!!",packet[1],packet[2],packet[3],byteEnd);
			this.broadcast([id],packet.data()); // broadcast to everyone - including the sender
			if (item.buffer()) {
				item.buffer().trim(byteEnd);
			};
			packet.reply(util.mpencode([MSG.OK,0]));
			return true;
			break;
		}
		case MSG.STREAMSTATE: {
			let res = await rdb.bufferapi('streamgetrange',id,packet[2],-1);
			socket.send(res);
			break;
		}
		case MSG.STREAMGETRANGE: {
			let res = await rdb.bufferapi('streamgetrange',id,packet[2],packet[3]);
			socket.send(res);
			break;
		}
	};
	
	var res = await cmd;
	return true;
};

API.prototype.registerPrefetched = function (sel,result){
	this._cache.prefetched || (this._cache.prefetched = []);
	this._cache.prefetched.push([sel,result]);
	return this;
};

API.prototype.toJSON = function (){
	var self = this;
	self._cache.user = self.db().users().read(self.user());
	self._cache.manifest = manifest;
	
	var json = self.db().scoped(self.scope(),function() {
		return JSON.stringify(self._cache).replace(/\bscript/g,"§§SCRIPT§§");
	});
	
	return json; // will be doubly stringified
};

API.prototype.toScriptContent = function (name){
	if(name === undefined) name = "API_CACHE";
	if (name) {
		return ("" + name + " = ") + JSON.stringify(this);
	};
};

