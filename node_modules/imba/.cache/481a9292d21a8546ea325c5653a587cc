function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };

var Struct = require('./Struct').Struct;
var StreamAction$ = require('./StreamAction'), StreamAction = StreamAction$.StreamAction, RecStart = StreamAction$.RecStart, LockAction = StreamAction$.LockAction;
var StreamBuffer = require('./StreamBuffer').StreamBuffer;
var protocol$ = require('../protocol'), ACTION = protocol$.ACTION, ACTION_MAP = protocol$.ACTION_MAP, MSG = protocol$.MSG, SCON = protocol$.SCON;

var Pointer = require('./Pointer').Pointer;
var List = require('../util/List').List;

var msgpack = require('msgpack-lite');

// TODO if user is in a substream branching out from
// an event in this stream, it should force-revert the
// other stream before applying/reverting own events
function Stream(buffer,owner,seed,options){
	var self = this;
	if(options === undefined) options = {};
	self._buffer = buffer;
	self._actions = [];
	self._owner = owner;
	self._options = options;
	self._offset = options.offset || 0; // TODO understand?
	// custom tail-types for each event
	
	self._byteOffset = 0;
	self._localOffset = 0;
	self._lastLocalIndex = -1;
	self._lastActions = {};
	self._lastTimeOffset = 0;
	self._lastType = null;
	self._state = {};
	self._dupes = {};
	self._layouts = {};
	// keeps a list of recstart events
	self._recordings = new List(self);
	self._audio = new List(self);
	
	self._tail = self._first = StreamAction.seed(self);
	
	self._decoder = new (msgpack.Decoder)({});
	self._decoder.offset = 0;
	
	if (seed) {
		self._tail._prev = self._seed = seed;
	} else {
		self._seed = self._tail;
	};
	// this is surely wrong
	self.anchorTime();
	
	// bind to buffer
	self._ontrim = function(e) {
		self.api().log('stream','ontrim',e);
		return self.rollbackToAction(self.actionAtByteOffset(e));
	};
	
	self._buffer.on('trim',self._ontrim);
	self;
};


exports.Stream = Stream; // export class 
Stream.prototype.buffer = function(v){ return this._buffer; }
Stream.prototype.setBuffer = function(v){ this._buffer = v; return this; };
Stream.prototype.owner = function(v){ return this._owner; }
Stream.prototype.setOwner = function(v){ this._owner = v; return this; };
Stream.prototype.parent = function(v){ return this._parent; }
Stream.prototype.setParent = function(v){ this._parent = v; return this; };
Stream.prototype.actions = function(v){ return this._actions; }
Stream.prototype.setActions = function(v){ this._actions = v; return this; };
Stream.prototype.realtime = function(v){ return this._realtime; }
Stream.prototype.setRealtime = function(v){ this._realtime = v; return this; };
Stream.prototype.seed = function(v){ return this._seed; }
Stream.prototype.setSeed = function(v){ this._seed = v; return this; };
Stream.prototype.tail = function(v){ return this._tail; }
Stream.prototype.setTail = function(v){ this._tail = v; return this; };

Stream.prototype.recordings = function(v){ return this._recordings; }
Stream.prototype.setRecordings = function(v){ this._recordings = v; return this; };
Stream.prototype.__currentLock = {watch: 'currentLockDidSet',name: 'currentLock'};
Stream.prototype.currentLock = function(v){ return this._currentLock; }
Stream.prototype.setCurrentLock = function(v){
	var a = this.currentLock();
	if(v != a) { this._currentLock = v; }
	if(v != a) { this.currentLockDidSet && this.currentLockDidSet(v,a,this.__currentLock) }
	return this;
};
Stream.prototype.lastActions = function(v){ return this._lastActions; }
Stream.prototype.setLastActions = function(v){ this._lastActions = v; return this; };
Stream.prototype.lastTimeOffset = function(v){ return this._lastTimeOffset; }
Stream.prototype.setLastTimeOffset = function(v){ this._lastTimeOffset = v; return this; };
Stream.prototype.state = function(v){ return this._state; }
Stream.prototype.setState = function(v){ this._state = v; return this; };
Stream.prototype.audio = function(v){ return this._audio; }
Stream.prototype.setAudio = function(v){ this._audio = v; return this; };
Stream.prototype.dupes = function(v){ return this._dupes; }
Stream.prototype.setDupes = function(v){ this._dupes = v; return this; };
Stream.prototype.layouts = function(v){ return this._layouts; }
Stream.prototype.setLayouts = function(v){ this._layouts = v; return this; };

Stream.prototype.dispose = function (){
	this._buffer.un('trim',this._ontrim);
	return this;
};

Stream.prototype.id = function (){
	return this.owner().id();
};

Stream.prototype.space = function (){
	return this.owner().space();
};

Stream.prototype.api = function (){
	return this.space().api();
};

Stream.prototype.log = function (){
	var api_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (api_ = this.api()).log.apply(api_,[].concat(['stream'], [].slice.call(params)));
};

Stream.prototype.pointer = function (){
	return this._pointer || (this._pointer = new Pointer(this));
};

Stream.prototype.anchorTime = function (o){
	if(o === undefined) o = {};
	return this._anchor = {
		ts: o.now || Date.now(),
		offset: o.offset || this._tail.offset() || 0,
		collapsed: !(this.realtime()),
		rate: 1
	};
};

Stream.prototype.currentLockDidSet = function (lock){
	if (this.owner().isEditing() && lock && lock.sid() != this.api().sid()) {
		return this.owner().stopEditing();
	};
};

Stream.prototype.currentSID = function (){
	return this.currentLock() ? this.currentLock().sid() : null;
};

// is this used?
Stream.prototype.currentTime = function (){
	return Date.now() - this._anchor.ts;
};

Stream.prototype.lastTimeOffset = function (){
	return this._tail.offset();
};

Stream.prototype.nextTimeOffset = function (){
	return Math.max(this.lastTimeOffset(),this._anchor.offset + (this.now() - this._anchor.ts) * this._anchor.rate);
};

Stream.prototype.now = function (){
	return this._frozenTime || Date.now();
};

Stream.prototype.freezeTime = function (time,block){
	let prev = this._frozenTime;
	this._frozenTime = time || Date.now();
	block();
	this._frozenTime = prev;
	return this;
};

Stream.prototype.byteLength = function (){
	return this._decoder.offset;
};

Stream.prototype.read = function (meta){
	var dec = this._decoder;
	var buf = dec.buffer = this._buffer._buffer;
	
	if (!buf || dec.offset >= this._buffer.size()) {
		return null;
	};
	
	// check
	let chunk = dec.fetch();
	
	// this is an action
	if (typeof chunk == 'number') {
		if (chunk > 0) {
			this._lastTimeOffset += chunk;
		} else if (chunk < 0) {
			this._lastType = -chunk;
		};
		return this.read(meta);
	};
	
	
	var typ = this._lastType;
	var kls = ACTION_MAP[typ];
	
	if (!kls) {
		kls = StreamAction;
	};
	
	var nextIndex = this._actions.length;
	var prevOfType = this._lastActions[typ];
	
	// log "read",chunk
	var action = kls.decode(chunk,prevOfType ? prevOfType._params : null,this,nextIndex);
	if (meta) { action.LOCAL = meta };
	action.addToStream(this);
	action.commitToStream(this);
	return this._tail = action;
};

Stream.prototype.lock = function (){
	if (this.currentLock() && this.currentLock().sid() == this.api().sid()) {
		return true;
	};
	
	// if stream is currently recording and not locked by me - disallow
	var action = new LockAction([this.api().sid(),this.api().uid()]);
	this.log("lock",action);
	action.addToStream(this);
	var binary = StreamBuffer.encode([-ACTION.LOCK,action.encode(this)]);
	this.buffer().add(binary,this.byteLength());
	this._lastType = action._type;
	// log "read lock-action!",action
	this.sync({});
	return true;
};


// write to the stream - this is where we compact etc
Stream.prototype.write = function (action,meta){
	
	if (!(this.lock())) {
		return false;
	};
	
	var offset = this.nextTimeOffset();
	
	if (meta && meta.timeOffset != null) {
		offset = meta.timeOffset;
		// anchorTime(offset: offset)
	};
	
	// var offset = Math.max(timestamp,@tail.offset)
	var delta = offset - this.lastTimeOffset();
	
	if (delta > 0 && delta < 3) {
		delta = 0;
	};
	
	// if we are not recording - we should not add
	// any offsets between events at all.
	
	// FIX if recording belongs to another branch - we must definitely throw(!)
	if (!(this.space().recording() && this.space().recording().isRecording())) {
		if (!(meta && meta.timeOffset)) { delta = 0 };
	};
	
	var typ = action._type;
	
	if (!this.canPush(action)) {
		console.warn("not allowed to write to stream!",action);
		return this;
	};
	
	var binary = [];
	
	if (delta > 0) {
		binary.push(delta);
	};
	
	if (typ != this._lastType) {
		binary.push(-typ);
	};
	
	action.addToStream(this);
	// var prev = prevOfType ? prevOfType.@params : null
	var encoded = action.encode(this);
	binary.push(encoded);
	var packed = StreamBuffer.encode(binary);
	this.buffer().add(packed,this.byteLength());
	this.log.apply(this,[].concat([offset,delta,action.constructor.name], [].slice.call(encoded)));
	this._lastLocalIndex = this._actions.length;
	return this.read(meta);
};

Stream.prototype.canPush = function (action){
	var rec = this._recordings.last();
	var res = !rec || !rec.stop() || (action instanceof RecStart);
	return res;
};

Stream.prototype.encode = function (){
	var encoder = new (msgpack.Encoder)({});
	var type = 0;
	var dt = 0;
	var time = 0;
	for (let i = 0, items = iter$(this.actions()), len = items.length, action; i < len; i++) {
		action = items[i];
		let atime = action.timeOffset();
		if (atime > time) {
			encoder.write(atime - time);
			time = atime;
		};
		if (action._type != type) {
			encoder.write(-action._type);
			type = action._type;
		};
		
		let enc = action.encode(this);
		encoder.write(enc);
	};
	return encoder.read();
};

Stream.prototype.sync = function (meta){
	// for now read as long as possible
	if(meta === undefined) meta = null;
	var len = this._buffer.size();
	var offset = this._decoder.offset;
	
	// already at the end
	if (offset == len) {
		return this;
	};
	
	if (offset > len) {
		console.warn("we are ahead of buffer(?!)");
		return this;
	};
	
	while (this.read(meta)){
		// break if ++k > 1000
		true;
	};
	return this;
};

Stream.prototype.len = function (){
	return this._actions.length;
};

Stream.prototype.toArray = function (){
	return this._actions;
};

Stream.prototype.map = function (cb){
	return this._actions.map(cb);
};

Stream.prototype.duration = function (){
	return this._tail.offset();
};

// This supports negative indices
Stream.prototype.actionAtIndex = function (index){
	if (index < 0) {
		index = this._actions.length + index;
	};
	return this._actions[index];
};

Stream.prototype.actionAtOffset = function (time){
	this.read();
	
	var cursor = this._lastSearchCursor || this._actions[0];
	if (!cursor) { return null };
	
	var prev = cursor;
	// make sure we read ahead to the offset
	while (time >= this.duration()){
		if (!(this.read())) {
			return this._tail;
		};
	};
	
	if (time < cursor.offset()) {
		while (cursor && time < cursor.offset()){
			cursor = cursor._prev;
		};
		return this._lastSearchCursor = cursor || this._actions[0];
	} else {
		// add some sort of cache here?
		while (cursor && time >= cursor.offset()){
			prev = cursor;
			cursor = cursor._next;
		};
		return this._lastSearchCursor = prev;
	};
};

Stream.prototype.actionAtByteOffset = function (byteOffset){
	var action = this._tail;
	while (action && action._byteEnd > byteOffset){
		action = action._prev;
	};
	return action;
};

Stream.prototype.actionsOfType = function (type){
	return this._actions.filter(function(action) { return action._type == type; });
};

Stream.prototype.rollbackToAction = function (action){
	var dec = this._decoder;
	
	var path = this.space().cursor().compare(this.space().cursor().current(),action);
	// only sync if we are after this
	this.log("rollback-path",path);
	
	if (path.revertTo) {
		this.space().cursor().sync(action);
	};
	
	while (this._tail != action){
		let prev = this._tail._prev;
		this._tail.removeFromStream(this);
		this._tail = prev;
		prev._next = null;
	};
	
	var timeOffset = this._tail.timeOffset();
	
	this._lastType = this._tail.type();
	this._lastTimeOffset = timeOffset;
	this._lastSearchCursor = null;
	this._decoder.offset = this._tail.byteEnd();
	this._actions.slice(0,action.index() + 1);
	
	// remove cached dupes after new offset
	var lastIndex = len$(this._actions) - 1;
	for (let o = this._dupes, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];if (v > lastIndex) {
			this._dupes[k] = undefined;
		};
	};
	
	// should happen from Branch
	var tl = this._owner && this._owner.timeline  &&  this._owner.timeline();
	if (tl && tl.currentOffset() > timeOffset) {
		tl.seek(timeOffset);
	};
	return this;
};

Stream.prototype.rollbackToByteOffset = function (byteEnd){
	var action = this._tail;
	while (action && action.byteEnd() > byteEnd){
		action = action._prev;
	};
	
	// console.log "found action",action
	this.rollbackToAction(action);
	return this;
};
