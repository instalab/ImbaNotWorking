function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
// externs;

var FLAGS = {
	LOADING: 1
};

var Collection = require('./collection').Collection;
var Resource$ = require('./Resource'), Resource = Resource$.Resource, ACCESS = Resource$.ACCESS;
var LocalStore = require('../util/StoreWrapper').LocalStore;

var util = require('../util');

var AssignShim = function(target,params) {
	for (let v, i = 0, keys = Object.keys(params), l = keys.length, k; i < l; i++){
		k = keys[i];v = params[k];target[k] = v;
	};
	return target;
};


function Store(db,name,type,options){
	var self = this;
	self._type = type || Resource;
	self._name = name;
	self._db = db;
	self._ts = Date.now();
	self._options = options || {};
	
	db[name] = function() { return self; };
	db.stores().push(self);
	db.stores()[name] = self;
	
	if (options.ns) {
		db._prefixes[options.ns] = self;
	};
	
	self._flags = 0;
	self._version = 0;
	self._isReady = false;
	
	self._map = {}; // includes id-mapped hash of all loaded items
	self._cache = {};
	self._array = [];
	self._requested = {};
	self._indices = {};
	// possible to set up an automatic readHook actually
	self._reader = function(item) { return self.read(item); };
	self._kvs = {};
	
	// if $web$
	//	@kvs = LocalStore.new(@db.cacheKey+':'+@name + ':','temporary')
	
	if (true) {
		self._knex = self._db.knex();
		// @kvs = LocalStore.new('db:'+@name)
	};
	
	if (type) {
		// hacky solution to make this work on server as well
		// there can only be one instance of the db now
		type.prototype._db = db;
		type.prototype._store = self;
		type.prototype._ns = self._name;
	};
	
	if (self._options.preload == false && self._knex) {
		self._isReady = true;
	} else if (self._knex) {
		// on the server we want to preload anyways
		self.loadIntoMemory();
	};
	self;
};

exports.Store = Store; // export class 
Store.prototype.name = function(v){ return this._name; }
Store.prototype.setName = function(v){ this._name = v; return this; };
Store.prototype.isReady = function(v){ return this._isReady; }
Store.prototype.setIsReady = function(v){ this._isReady = v; return this; };
Store.prototype.version = function(v){ return this._version; }
Store.prototype.setVersion = function(v){ this._version = v; return this; };
Store.prototype.type = function(v){ return this._type; }
Store.prototype.setType = function(v){ this._type = v; return this; };
Store.prototype.kvs = function(v){ return this._kvs; }
Store.prototype.setKvs = function(v){ this._kvs = v; return this; };
Store.prototype.db = function(v){ return this._db; }
Store.prototype.setDb = function(v){ this._db = v; return this; };
Store.prototype.cache = function(v){ return this._cache; }
Store.prototype.setCache = function(v){ this._cache = v; return this; };

Store.prototype.api = function (){
	if (false) {} else {
		return {};
	};
};

Store.prototype.log = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	if (false) {};
	return this;
};

Store.prototype.dexie = function (){
	if (!this._dexie) {
		this._dexie = this._db.dexie()[this.name()];
		this._dexie.hook("reading",this._reader);
	};
	return this._dexie;
};

Store.prototype.inMemoryOnly = function (){
	return false;
};

Store.prototype.loadIntoMemory = function (){
	var self = this;
	if (self._isReady || self._isLoading) {
		return self;
	};
	
	self._isLoading = true;
	
	var d = Date.now();
	
	if (false) {};
	
	if (true) {
		// load the whole table for now
		self._knex.table(self.name()).then(function(items) {
			items.map(self._reader);
			return self.didLoadFromMemory();
		});
	};
	return self;
};

Store.prototype.didLoadFromMemory = function (){
	this._isReady = true;
	this._isLoading = false;
	this.touch();
	return this._db.storeDidLoad(this);
};

Store.prototype.touch = function (){
	this._version++;
	this._cache = {};
	return this._db.touch();
};

Store.prototype.drop = function (){
	return this.clear();
};

Store.prototype.clear = function (){
	// var res = await (inMemoryOnly ? null : dexie.clear)
	this._kvs = {}; // kvs.clear
	return this;
};

Store.prototype.generateId = function (){
	var rnd = util.uuid();
	return this._options.ns + 'o' + util.rndstr(10);
};

Store.prototype.index = function (name,key,value){
	let index = this._indices[name] || (this._indices[name] = {});
	if (value != undefined) {
		index[key] = value;
	};
	return index[key];
};

Store.prototype.build = function (data){
	data.v = -2;
	if (this._type.build) {
		data = this._type.build(data,this,util.rndstr(10));
	};
	data.id || (data.id = this.generateId());
	return this.read(data);
};

if (true) {
	Store.prototype.table = function (){
		return this._knex.table(this.name());
	};
	
	Store.prototype.normalizeFields = function (obj){
		for (let item, i = 0, keys = Object.keys(obj), l = keys.length, key; i < l; i++){
			// what if the field is of type jsonb?
			key = keys[i];item = obj[key];if (item instanceof Array) {
				obj[key] = '{' + item.join(',') + '}';
			};
		};
		return obj;
	};
	
	Store.prototype.fetch = async function (item){
		let id = item.id || item;
		let model = await this._knex.table(this.name()).where({id: id}).first();
		
		if (!model) {
			// WARN this gets added to the list of all models now
			return this.read({id: id,CODE: 404},true);
		};
		
		return this.read(model);
	};
	
	Store.prototype.ins = async function (item,api){
		// console.log "try to actually insert an item here",auth
		// need to run through some permissions for this
		var v_, $1, $2;
		let raw = JSON.parse(JSON.stringify(item));
		
		(((v_ = raw.v),delete raw.v, v_));
		((($1 = raw.LOCAL),delete raw.LOCAL, $1));
		((($2 = raw.CODE),delete raw.CODE, $2));
		
		if (this._name == 'users' && api) {
			console.warn("not allowed to insert users via Store#ins");
			return null;
		};
		
		if (raw.id) {
			if (!(raw.id[0] == this._options.ns && (!api || raw.id[1] == 'o'))) { // or no api?
				console.warn("trying to insert item with invalid id type!!!",raw);
			};
		};
		
		// Should disallow inserting unless user isMod or uid is mine?
		
		if (this._type.ins) {
			return this._type.ins(this,raw,api);
		};
		
		let res = await this._knex.table(this.name()).returning('id').insert(this.normalizeFields(raw));
		let model = await this._knex.table(this.name()).where({id: res[0]}).first();
		return this.read(model);
	};
	
	Store.prototype.put = async function (item,api){
		// check if it already exists
		// wbat about an anonymous user?
		var self = this, v_, $1, $2, $3, $4, $5;
		let old = await self._knex.table(self.name()).where({id: item.id}).first();
		
		if (!old) {
			console.log("did not exist - insert instead",item.id);
			return self.ins(item,api);
		};
		
		old = self.read(old);
		
		if (api && !self._type.canPut(item,old,api)) { // legacy
			return old;
		};
		
		if (self._type.put) {
			return self._type.put(self,item,api);
		};
		
		if (api && !old.can(api,'write')) {
			console.log("user cannot write - from server",self.user());
			return old;
		};
		
		let changes = JSON.parse(JSON.stringify(item)); // msgpack is the better format for this?
		let v = (((v_ = changes.v),delete changes.v, v_));
		let id = ((($1 = changes.id),delete changes.id, $1));
		
		((($2 = changes.CODE),delete changes.CODE, $2));
		((($3 = changes.LOCAL),delete changes.LOCAL, $3));
		
		
		
		// certain fields are not allowed to change
		((($4 = changes.uid),delete changes.uid, $4));
		((($5 = changes.roles),delete changes.roles, $5));
		
		
		
		// create diff between changes and existing
		
		changes = self.normalizeFields(changes);
		
		var err = function(e) {
			console.log("error on put!",e);
			// Send to opbeat?
			return self.fetch(id);
		};
		
		return self._knex.table(self.name()).returning('v').where({id: item.id}).update(changes).then(function() {
			// console.log "finished put"
			return self.fetch(id);
		},err);
	};
	
	Store.prototype.autofetch = function (){
		var self = this;
		var ids = Object.keys(self._requested);
		self._requested = {};
		if (!ids.length) { return Promise.resolve([]) };
		var items = self._knex.table(self.name()).select().whereIn('id',ids);
		console.log("autoloading",ids.length);
		return items.map(function(item) { return self.read(item); });
	};
	
	Store.prototype.batchLoad = function (ids){
		var self = this;
		if (!ids.length) { return Promise.resolve([]) };
		var items = self._knex.table(self.name()).select().whereIn('id',ids);
		console.log("autoloading",ids.length);
		return items.map(function(item) { return self.read(item); });
	};
};

Store.prototype.all = function (){
	return this._array;
};

Store.prototype.has = function (id){
	return !(!this._map[id]);
};

Store.prototype.get = function (id){
	if (id && !this._map[id]) {
		if (true) {
			// should surely be added?
			// console.log "{@name} with id {id} does not exist"
			// return null # or item that does not exist at all?
			true;
		};
		
		var temp = {id: id,v: -3,CODE: 200}; // set CODE loading?
		var item = this._map[id] = (this._type ? this._type.read(temp,this) : temp);
		this._array.push(item);
		this._requested[id] = true;
		this._db.autoload(item);
	};
	
	return this._map[id];
};

// asynchronous get that will only fetch from database
// if resource is not already loaded
Store.prototype.summon = function (id){
	let item = id && this._map[id];
	if (item && item.isInited()) {
		return Promise.resolve(item);
	};
	return this.fetch(id);
};

Store.prototype.read = function (item,force){
	if(force === undefined) force = false;
	if (!item) { return };
	
	var existing = this._map[item.id] || this._map[item.localid];
	
	if (existing == item) {
		return item;
	} else if (existing) {
		let ev = existing.v;
		let vdiff = item.v - ev;
		
		if (vdiff > 0 || ev == null || (vdiff >= 0 && force)) {
			// if vdiff < 0 and force
			//	console.log "force-reading!!!!",vdiff,force,item
			item.CODE || (item.CODE = 200);
			if (existing instanceof Resource) {
				existing.patch(item,this);
			} else {
				AssignShim(existing,item);
			};
			this._version++;
			this._cache = {};
		};
	} else {
		if (this._type && !(item instanceof this._type)) {
			item.v || (item.v = -4); // ?
			item.CODE || (item.CODE = 200);
			item = this._type.read(item,this);
		};
		
		this._map[item.id] = item;
		this._array.push(item);
		// what if this was requested?
		// should we not remove it from requested?
		this._version++;
		this._cache = {};
	};
	
	
	return existing || item;
};

Store.prototype.syncLocal = function (){
	return this;
};

Store.prototype.patch = function (diff){
	// this expects an object from the server
	// that includes the state-object etc
	// what happens if we try to push multiple times?
	// console.log "patching table",name
	if (!diff[1]) { return };
	
	var type = diff[1];
	var v1 = diff[2];
	var v0 = this.lastVersion(type);
	var data = diff[3] || [];
	
	this.lastVersion(type,v1);
	// console.log 'patch',type
	
	if (!len$(data)) {
		return this;
	};
	
	// should delay persisting and instead just register
	// what items we still need to update?
	
	for (let i = 0, items = iter$(data), len = items.length; i < len; i++) {
		this.read(items[i]);
	};
	
	this.touch();
	return;
};

Store.prototype.persist = function (){
	return this;
};

Store.prototype.saveLocal = function (item){
	if (this.inMemoryOnly()) {
		return Promise.resolve(item);
	};
	
	var v = item.v;
	if (v < -1) { item.v = -1 };
	var res = this._dexie.put(item);
	return res.then(function(e) {
		// console.log("saveLocal",e)
		if (item.v < -1) { item.v = -1 };
		return item;
	}).catch(function(e) {
		// console.log("perr",e)
		if (item.v == -1) { item.v = v };
		return item;
	});
};

Store.prototype.lastVersion = function (key,val){
	if (val != undefined) {
		this.kvs()[key] = val;
		// kvs.set(key,val)
	};
	return this.kvs()[val] || 0; // kvs.getnum(key)
};

Store.prototype.sync = async function (query){
	if(query === undefined) query = {};
	var key = JSON.stringify(query);
	if (true) { return Promise.resolve(this) };
	
	// console.log "Store.sync",@name
	
	var v = this.lastVersion(key);
	var req = [this._name,query,this.lastVersion(key)];
	// could include dependencies as well?
	var diff = await this.api().rpc('sync',[[req]]);
	if (diff[0]) { this.patch(diff[0]) };
	// log 'returned from sync',req,diff
	// patch(diff)
	return this;
};


Store.prototype.where = function (){
	var self = this, $1;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	if (true) {
		// this is not
		return ($1 = self._knex.table(self.name())).where.apply($1,params).map(function(res) { return self.read(res); });
	};
	// else
	// 	console.log "not implemented(!)"
	// 	@dexie.where(q)
};

Store.prototype.first = function (q){
	var self = this;
	if (q instanceof Function) {
		return self.filter(q)[0];
	};
	
	if (true) {
		// this is not
		return self._knex.table(self.name()).where(q).first().then(function(res) { return self.read(res); });
	};
	// else
	// 	# why touch into dexie here at all?
	// 	@dexie.where(q).first
};



Store.prototype.slice = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return this._array.slice.apply(this._array,params);
};

Store.prototype.filter = function (cb){
	// async vs sync?
	return this._array.filter(cb);
};

Store.prototype.sel = function (o,fn){
	if(fn==undefined && typeof o == 'function') fn = o,o = {};
	if(o==undefined) o = {};
	var coll = new Collection(this,o);
	if (fn) { (coll.setQuery(fn),fn) };
	return coll;
};
