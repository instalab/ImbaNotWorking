function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba'), _1 = Imba.createElement;


var protocol$ = require('../protocol'), MSG = protocol$.MSG, ACTION = protocol$.ACTION, CAST = protocol$.CAST;

var util = require('../util');

var delayPromise = function(ms) {
	if(ms === undefined) ms = 1000;
	return new Promise(function(resolve,reject) {
		return setTimeout(resolve,ms);
	});
};

var RecDoneDialog = require('../views/RecDoneDialog').RecDoneDialog;
var MediaRecording = require('../util/MediaRecording').MediaRecording;

// externs;

function Recording(branch,options){
	if(options === undefined) options = {};
	this._branch = branch;
	this._state = 'ready';
	this._options = options;
	this._live = options.live || false;
	branch.setRecording(this);
	this._startTimeOffset = branch.currentOffset();
	this._startTime = branch.timeline().endTime();
	this._draftEnd = branch.draft().end;
	this._initialState = branch.state();
	this;
};

exports.Recording = Recording; // export class 
Recording.prototype.branch = function(v){ return this._branch; }
Recording.prototype.setBranch = function(v){ this._branch = v; return this; };
Recording.prototype.state = function(v){ return this._state; }
Recording.prototype.setState = function(v){ this._state = v; return this; };
Recording.prototype.options = function(v){ return this._options; }
Recording.prototype.setOptions = function(v){ this._options = v; return this; };
Recording.prototype.audio = function(v){ return this._audio; }
Recording.prototype.setAudio = function(v){ this._audio = v; return this; };
Recording.prototype.live = function(v){ return this._live; }
Recording.prototype.setLive = function(v){ this._live = v; return this; };
Recording.prototype.startTimeOffset = function(v){ return this._startTimeOffset; }
Recording.prototype.setStartTimeOffset = function(v){ this._startTimeOffset = v; return this; };

Recording.prototype.space = function (){
	return this.branch().space();
};

Recording.prototype.log = function (){
	var api_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (api_ = this.api()).log.apply(api_,[].concat(['rec'], [].slice.call(params)));
};

Recording.prototype.api = function (){
	return this.space().api();
};

Recording.prototype.stream = function (){
	return this.branch().stream();
};

Recording.prototype.duration = function (){
	return this._startAt ? (((this._stopAt || Date.now()) - this._startAt)) : 0;
};

Recording.prototype.startTime = function (){
	return this._startTime;
};

Recording.prototype.currentTime = function (){
	return this.duration();
};

Recording.prototype.isRecording = function (){
	return this.state() == 'recording';
};

Recording.prototype.start = function (){
	var self = this;
	return self._start || (self._start = new Promise(function(resolve,reject) {
		self.space().setRecording(self);
		self._origin = self.space().cursor().current();
		self._startTimeOffset = self.stream().lastTimeOffset(); // not based on timeline/cues
		self._isFirstRecording = len$(self.stream().recordings()) == 0; // lastActions[CAST.RECSTART]
		
		self.api().analytics().castRecStart(self.branch().id());
		
		self.setState('starting');
		// should contact server and ask for the exclusive right
		// to editing this stream starting now (with a timeout)
		// var wait = Math.max(-duration,200)
		var start = util.delay(100);
		
		if (self.options().mic) {
			self.setAudio(window.MR = new MediaRecording({chunkSize: 2400,constraints: self.options().mic,space: self.space(),owner: self}));
			start = self.audio().start();
		};
		
		let catcher = function(e) {
			self.space().setRecording(null);
			self.teardown();
			return reject(e);
		};
		
		start.then(function() {
			self._startAt = self.audio() ? self.audio().startedAt() : Date.now();
			self.setState('recording');
			self.options().startTime = self._startAt;
			
			if (self.audio()) {
				self.options().audiofile = self.audio()._model.toJSON();
			};
			
			// console.log "startAt relative to now",Date.now - @startAt
			let op = [self.branch().toSnapshot({}),self.options()];
			self.stream().anchorTime({offset: self._startTimeOffset,now: self._startAt});
			
			self.stream().freezeTime(self._startAt,function() {
				// stream.lock
				// stream.sync
				console.log("setMode recording from",self.branch().mode());
				self.branch().setMode('recording');
				self._recEvent = self.branch().push_(ACTION.RECSTART,op,{timeOffset: self._startTimeOffset}); // force offset?
				
				// this is an example of a point where it would be nice to batch timing
				// console.log "flush locals!"
				self.space().view().focusViewport();
				self.space().client().flushLocals();
				self.space().pointerTracker().start();
				return resolve(self);
			});
			
			// console.warn "stream.nextOffset",stream.nextOffset
			return self._interval = setInterval(function() {
				// if audio
				// 	console.log("rec interval",audio.duration,stream.nextTimeOffset - @startTimeOffset)
				return self.branch().push_(ACTION.PING,[Date.now()]);
			},10000);
		},catcher);
		return self;
	}));
};

Recording.prototype.onaudioerror = function (e){
	return console.log("audio-error!",e);
};

Recording.prototype.stop = async function (){
	if (this._stopAt) {
		return this;
	};
	
	clearInterval(this._interval);
	
	this.setState('stopping');
	this._stopAt = Date.now();
	
	this.space().browser().stop();
	this.space().pointerTracker().stop();
	
	// we should not allow any more events for some time - to make sure
	// that the real duration of the audio won't end before the last few events
	this.log('stop',this._stopAt);
	
	await (this.audio() ? this.stopAudio() : Promise.resolve({}));
	
	this._stopTimeOffset = Math.round(this._startTimeOffset + (this._stopAt - this._startAt));
	this.stream().anchorTime({offset: this._stopTimeOffset,now: this._stopAt});
	this._stopEvent = this.branch().push_(ACTION.RECSTOP,[],{timeOffset: this._stopTimeOffset});
	return ((_1(RecDoneDialog).flag('modal')).setData(this).end()).show();
};

Recording.prototype.stopAudio = async function (){
	// give the audio 300ms extra time to end
	await delayPromise(300);
	await this.audio().stop();
	
	this._stopAt = this._startAt + this.audio().duration();
	console.log("audio.duration",this.audio().duration());
	return this;
};

Recording.prototype.discard = async function (){
	var audio_;
	this.branch().timeline().pause();
	await this.branch().trimToAction(this._origin);
	// discard the audio recording as well
	(audio_ = this.audio()) && audio_.discard  &&  audio_.discard();
	if (this.branch().timeline().duration() == 0) {
		this.branch().timeline().setState('watching');
	};
	
	this.teardown();
	this.api().analytics().castRecDiscard(this.branch().id());
	return Promise.resolve(this);
};

Recording.prototype.finish = async function (){
	// await (audio ? audio.finalize : {})
	var upload = await (this.audio() ? this.audio().upload() : {});
	
	if (this.audio()) {
		// 
		var audioMarker = [1,this._startTimeOffset,this._stopTimeOffset - this._startTimeOffset,this.audio()._model.id];
		console.log("audioMarker",audioMarker,this.audio().duration(),this._stopTimeOffset - this._startTimeOffset);
		this.branch().draft().audio.push(audioMarker);
	};
	// update the end-item here
	// TODO possibly end it at the audio-marker
	if (this._isFirstRecording) {
		this.branch().draft().start = this._startTimeOffset;
	};
	
	this.branch().draft().end = this._stopTimeOffset;
	console.log("finishing",this._stopTimeOffset,this._startTimeOffset);
	
	await this.branch().save({});
	this.setState('stopped');
	this.branch().setMode('paused');
	// branch.timeline.pause
	this.teardown();
	Imba.Scheduler.event({type: "recstop"});
	this.api().analytics().castRecSave(this.branch().id());
	// log("CASTREC",stream.lastActions[ACTION.RECSTART],stream.lastActions[ACTION.RECSTOP])
	return Promise.resolve(this);
};

Recording.prototype.teardown = function (){
	var v_;
	clearInterval(this._interval);
	if (this.branch().state() != this._initialState) {
		this.branch().model().update({state: this._initialState});
	};
	
	this.branch().setRecording(null);
	return (this.space().setRecording(null),null);
};
