function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');
var StreamAction = require('./StreamAction').StreamAction;

/*

Cursor keeps track of which event we are currently at (in a stream).
If a space has multiple branches, the cursor takes care of correctly
finding the path between two events and traversing them.

Events are like commits (in git). Cursor can be asked to "checkout" any
commit, and internally apply/revert all changes to end up at said commit.

*/

function Cursor(space){
	this._space = space;
	this._stack = [];
	this._event = {};
	this._syncing = false;
	this._reverting = false;
	
	// @current = @tail = @target = []
	// @current.OFFSET = 0
	// @current.INDEX = -1
	
	this._branch = space.trunk();
	this._current = this._target = this._tail = space.trunk().stream().seed();
	this;
};

exports.Cursor = Cursor; // export class 
Cursor.prototype.space = function(v){ return this._space; }
Cursor.prototype.setSpace = function(v){ this._space = v; return this; };
Cursor.prototype.stack = function(v){ return this._stack; }
Cursor.prototype.setStack = function(v){ this._stack = v; return this; };
Cursor.prototype.current = function(v){ return this._current; }
Cursor.prototype.setCurrent = function(v){ this._current = v; return this; };
Cursor.prototype.syncing = function(v){ return this._syncing; }
Cursor.prototype.setSyncing = function(v){ this._syncing = v; return this; };
Cursor.prototype.__branch = {watch: 'branchDidSet',name: 'branch'};
Cursor.prototype.branch = function(v){ return this._branch; }
Cursor.prototype.setBranch = function(v){
	var a = this.branch();
	if(v != a) { this._branch = v; }
	if(v != a) { this.branchDidSet && this.branchDidSet(v,a,this.__branch) }
	return this;
};
Cursor.prototype.skipping = function(v){ return this._skipping; }
Cursor.prototype.setSkipping = function(v){ this._skipping = v; return this; };

Cursor.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
Cursor.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
Cursor.prototype.once = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.once.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
Cursor.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

Cursor.prototype.lineage = function (e){
	var branch = e.branch();
	var lineage = [e];
	// no seeds?
	while (branch && branch.seed()){
		lineage.unshift(branch._seed);
		branch = branch._seed._branch;
	};
	
	return lineage;
};

Cursor.prototype.compare = function (a,b){
	if (a.branch() == b.branch()) {
		if (b._index < a._index) {
			return {revertTo: b};
		} else {
			return {stepTo: b};
		};
	};
	
	var la = this.lineage(a);
	var lb = this.lineage(b);
	var l = Math.min(len$(la),len$(lb));
	// find first shared root
	var i = 0;
	var k = 0;
	
	while (i < (l - 1)){
		if (la[i].branch() == lb[i].branch()) {
			k = i;
		};
		i++;
	};
	
	var revTo = lb[k];
	
	if (la[k]._index < lb[k]._index) {
		revTo = la[k];
	};
	
	return {revertTo: revTo,route: lb.slice(k)};
};

Cursor.prototype.branchDidSet = function (branch,prev){
	// did leave first?
	var $1, $2;
	($1 = prev) && $1.didLeave  &&  $1.didLeave(branch);
	($2 = branch) && $2.didEnter  &&  $2.didEnter(prev);
	return this.space().emit('branch:enter',branch,prev);
};

Cursor.prototype.syncing = function (){
	return this._syncing || this._stack.length > 0;
};

Cursor.prototype.target = function (value){
	if (value) {
		this._target = value;
		return this;
	} else {
		return this._target;
	};
};

Cursor.prototype.canPush = function (action){
	// !current.@next and 
	return this.branch().canPush(action);
};

Cursor.prototype.sync = function (next,maxTime){
	// if space.api.isMobile
	// 	maxTime = 15
	if(next === undefined) next = this._target;
	if(maxTime === undefined) maxTime = 0;
	if (!next) { return };
	if (!this._current) {
		// console.log "first cursor.sync!",next
		this._current = this.space().trunk().stream().seed();
	};
	
	var cursor = this.current();
	var ts = Date.now();
	this._syncing = true;
	this._prev = cursor;
	this._next = next;
	this._skipping = !(this.space().timeline().state() == 'playing' || this.space().isLive()) || !this.space()._currentEvent;
	
	if (cursor == this._tail) {
		// FIXME since we're setting the cursor here
		// we cannot do immediate exit whenever we try to sync
		// next == cursor
		
		if (cursor = this._space.trunk().stream().actionAtIndex(0)) {
			this.apply(cursor);
		};
	};
	
	// fast exit
	if (next == cursor) {
		true;
	} else if (next._prev == cursor) {
		this.emit('sync:start',next,cursor,this);
		cursor = this.apply(next,cursor);
	} else {
		this.emit('sync:start',next,cursor,this);
		var path = this.compare(cursor,next);
		
		// console.log "cursor.sync",cursor,next,path,lineage(cursor),lineage(next)
		
		if (path.revertTo) {
			// console.log "supposed to revert",path:revertTo.INDEX,path:revertTo.@branch
			while (cursor != path.revertTo){
				if (!cursor) {
					console.log("nothing to revert",cursor,this._prev,this._next,path);
				};
				cursor = this.revert(cursor);
				if (maxTime && (Date.now() - ts) > maxTime) {
					next = cursor;break;
				};
			};
		};
		
		if (path.stepTo) {
			// console.log "step to"
			while (cursor != path.stepTo){
				let after = cursor._next;
				cursor = this.apply(after,cursor);
				if (maxTime && (Date.now() - ts) > maxTime) {
					next = cursor;break;
				};
			};
		};
		
		if (path.route) {
			// console.log "routing",path
			let k = 0;
			let r = path.route;
			while (cursor != next){
				let to = cursor._next;
				if (cursor == r[k]) {
					// we now need to take a different route
					to = r[++k].branch().stream()._first;
					// console.log "jumping into branch",to
				};
				cursor = this.apply(to);
			};
		};
	};
	
	this._current = this._target = next;
	this.setBranch(this._current.branch());
	this._space.setTimeline(this._current.branch().timeline());
	
	if (this.branch().isEditing() && this._current._next) {
		// if we are not syncing to the very last item - we need to leave editing
		console.log("throw us out of editing mode",this._current);
		this.branch().setMode('watching');
	};
	
	this._syncing = false;
	return this._current;
};

Cursor.prototype.apply = function (e,from){
	if (e == this._tail) { return };
	// console.log "apply event",e,from
	if (!e) {
		console.log("apply without e",e,from);
		throw from;
	};
	
	// if from.@next does not match e.@prev
	// we need to rollback until we get there
	if (from && e._prev != from) {
		// console.log "try to apply from invalid event!!",e,from
		while (from && from != e._prev){
			from = this.revert(from);
		};
	};
	
	// add a batch?
	// @stack.unshift(e)
	
	if (e.isEnabled()) {
		e.commitWithCursor(this);
	};
	// @stack.shift
	return e;
};


Cursor.prototype.revert = function (e){
	// @stack.unshift e
	this._reverting = true;
	
	// console.log "REVERT",e
	if (e.isEnabled()) {
		e.revertWithCursor(this);
	};
	this._reverting = false;
	// @stack.shift
	return e._prev;
};
