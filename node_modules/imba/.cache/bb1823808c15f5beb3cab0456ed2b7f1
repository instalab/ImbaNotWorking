function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var self = {};
var env = require('../env');
var octokit = require('@octokit/rest');
var fetch = require('node-fetch');
var fs = require('fs');
var jwt = require('jsonwebtoken');

var entities = require('./entities');
var ROLES = require('../scrimba/protocol').ROLES;

// import entities from './entities'
// https://github.com/apps/scrimba/installations/new/permissions?target_id={githubid}

var personalAccessToken = "fac19a319913f563e003deabdc8908f66e3ad280";
var db = require('../server/db').db;
var DB = require('../store/db').DB;

var GraphQLClient = require('graphql-request').GraphQLClient;

var query = 'query getCollaborators($url: URI!) {\nresource(url: $url) {\n	__typename\n	... on User {\n		id\n		name\n		login\n		bio\n		websiteUrl\n	}\n	... on Organization {\n		id\n		name\n		login\n		email\n		description\n		websiteUrl\n		members(first: 100){ edges { node {\n			id\n			login\n			name\n		}}}\n		teams(first:100){ edges{ node {\n			__typename\n			name\n			privacy\n			id\n			parentTeam { id }\n			members(first:100){ edges {\n				node {\n					login\n				}\n				role\n			}}\n		}}}\n	}\n	... on Repository {\n		id\n		name\n		nameWithOwner\n		databaseId\n		isPrivate\n		issues(first:10){\n			edges {\n				node {\n					databaseId\n					id\n					number\n					title\n					body\n					createdAt\n					author { login }\n					comments(first: 20) {\n						nodes {\n							author { login }\n							createdAt\n							databaseId\n							body\n						}\n					}\n				}\n			}\n		}\n		collaborators(first:100){\n			edges {\n				node {\n					databaseId\n					login\n					name\n				}\n				permission\n			}\n		}\n	}\n}\n}';

var infoQuery = 'query getCollaborators($url: URI!) {\nresource(url: $url) {\n	__typename\n	... on User {\n		id\n		databaseId\n		name\n		login\n	}\n	... on Organization {\n		id\n		databaseId\n		name\n		login\n		viewerIsAMember\n	}\n	... on Repository {\n   		id\n   		databaseId\n   		nameWithOwner\n   		owner {\n   			... on User {\n   				databaseId  \n   			}\n   			... on Organization {\n   				databaseId  \n   			}\n   		}\n	}\n}\n}';

// query = query.replace(/AUTHOR/g,)

var clientID = env.get('GITHUB_CLIENT_ID');
var appID = env.get('GITHUB_APP_ID');
var clientSecret = env.get('GITHUB_CLIENT_SECRET');

var flatMaps = {
	members: 'login',
	collaborators: 'login',
	repositories: 'name'
};

var installTokens = {};

self.cleanRestData = function (data){
	var res = JSON.stringify(data,function(key,value) {
		if (typeof key == 'string' && key.match(/\_url$/)) {
			return undefined;
		};
		return value;
	});
	return JSON.parse(res);
};

self.flatten = function (data){
	var mappers = {members: 'login'};
	var replacer = function(key,value) {
		let out = value;
		if (value && value.edges) {
			let mapper = flatMaps[key];
			let map = {};
			out = value.edges.map(function(v) {
				for (let iv, i = 0, keys = Object.keys(v), l = keys.length, ik; i < l; i++){
					ik = keys[i];iv = v[ik];if (ik != 'node') {
						v.node[ik] = iv;
					};
				};
				if (mapper) {
					map[v.node[mapper]] = v.node;
				};
				return v.node;
			});
			if (mapper) { out = map };
		};
		
		return out;
	};
	
	return JSON.parse(JSON.stringify(data.resource || data,replacer));
};

self.auth = function (token){
	return octokit.authenticate({type: 'oauth',token: token});
};

self.get = function (url,token,o){
	if(o === undefined) o = {};
	return self.rest('get',url,token,o);
};

self.post = function (url,token,o){
	if(o === undefined) o = {};
	return self.rest('post',url,token,o);
};

self.rest = async function (meth,url,token,o){
	var lh, all_, $1;
	if(o === undefined) o = {};
	if (url[0] == '/') { url = ("https://api.github.com" + url) };
	var res = await fetch(url,{method: meth,headers: {
		Authorization: ("bearer " + token),
		Accept: "application/vnd.github.machine-man-preview+json,application/vnd.github.valkyrie-preview+json"
	}});
	
	var header = res.headers.get('X-OAuth-Scopes');
	// console.log "found headers",res:headers.get('Link')
	var json = await res.json();
	var link = {};
	
	// if url.indexOf("page=2") >= 0
	// console.log "returned from url",url,JSON.stringify(cleanRestData(json)).substr(0,300)
	
	var out = o.raw ? json : self.cleanRestData(json);
	
	if (lh = res.headers.get('Link')) {
		lh.replace(/page\=(\d+)\>\; rel\="(next|prev|last)"/g,function(m,v,k) {
			return link[k] = parseInt(v);
		});
	};
	
	out.page = link;
	
	if (o.all && link.next == 2) {
		// fetch all pages
		// console.log "fetch more pages",link,res:headers.get('Link')
		var promises = [];
		var p = 1;
		while (p < link.last){
			let q = (url.indexOf('?') >= 0) ? '&' : '?';
			promises.push(self.rest(meth,url + q + ("page=" + (++p)),token));
			// console.log "added promise",url + q + "page={p}"
		};
		
		var pages = await Promise.all(promises);
		for (let i = 0, items = iter$(pages), len = items.length, page; i < len; i++) {
			// console.log "getting page",i,!!page
			page = items[i];
			if ((typeof (all_ = o.all)=='string'||all_ instanceof String) && (out[o.all] instanceof Array)) {
				out[$1 = o.all].push.apply(out[$1],page[o.all]);
			} else if (out instanceof Array) {
				out.push.apply(out,page);
			};
		};
	};
	
	if (o.scopes) {
		out.scopes = header.split(/\,\s*/);
	};
	return out;
};

self.ql = async function (token,q,vars){
	let client = new GraphQLClient('https://api.github.com/graphql',{
		headers: {
			Authorization: ("bearer " + token),
			Accept: "application/vnd.github.machine-man-preview+json,application/vnd.github.valkyrie-preview+json"
		}
	});
	var res = await client.request(q,vars);
	console.log("result from ql",res,vars);
	return self.flatten(res);
};

exports.kit = self.kit = function (token){
	var wrapper = octokit();
	wrapper.authenticate({type: 'oauth',token: token});
	return wrapper;
};

// see https://developer.github.com/webhooks/
exports.handleWebhook = self.handleWebhook = async function (event,body){
	console.log("handle webhook github",event,body);
	var action = body.action;
	var cleaned = self.cleanRestData(body);
	await db.table('syslog').insert({message: ("github webhook " + JSON.stringify(cleaned))});
	
	var token;
	if (body.installation) {
		await self.getInstallationToken(body.installation.id);
	};
	
	if (event == 'installation') {
		if (action == 'created') {
			self.syncInstallation(body.installation);
			true;
		};
	} else if (event == 'installation_repositories') {
		// if action == 'added'
		for (let i = 0, items = iter$(body.repositories_added), len = items.length, repo; i < len; i++) {
			repo = items[i];
			repo.installId = body.installation.id;
			await self.upsertRepository(repo);
		};
		
		for (let i = 0, items = iter$(body.repositories_removed), len = items.length; i < len; i++) {
			await self.unlinkRepository(items[i].full_name);
		};
	} else if (event == 'github_app_authorization') {
		// happens when app is unauthorized
		self;
	} else if (event == 'marketplace_purchase') {
		if (action == 'cancelled') {
			self;
		};
	};
	return;
};

exports.getInstallLinkForRef = self.getInstallLinkForRef = async function (ref){
	// var test = await get("/users/somebee",personalAccessToken)
	var login = ref.split("/")[0];
	// console.log ref,test
	let res = await self.ql(personalAccessToken,infoQuery,{url: ("https://github.com/" + login)});
	let link = ("https://github.com/apps/scrimba/installations/new/permissions?target_id=" + (res.databaseId));
	return link;
};

exports.getAppToken = self.getAppToken = function (){
	//  __dirname + "/../../certs/scrimba.2018-05-15.private-key.pem"
	var privateKey = fs.readFileSync(env.get('GITHUB_APP_PEM')); // hardcoded
	var now = Math.round(Date.now() / 1000);
	var payload = {iat: now,exp: now + 60,iss: appID};
	var token = jwt.sign(payload,privateKey,{algorithm: 'RS256'});
	return token;
};

exports.getInstallationIdForRef = self.getInstallationIdForRef = async function (login){
	var entity = await db.table('entities').where({ref: login}).first();
	try {
		var id = entity.data.github.install;
	} catch (e) { };
	return id || null;
	
	if (entity) {
		return entity.data && entity.data.github;
	};
	
	var user = await db.table('users').where({username: login}).first();
	return user && user.github_app && user.github_app.id;
};

exports.getInstallationToken = self.getInstallationToken = async function (installId){
	let existing = installTokens[installId];
	
	if (existing && (Date.now() - existing.ts) < 1000 * 50) {
		return Promise.resolve(existing.token);
	};
	
	let url = ("https://api.github.com/app/installations/" + installId + "/access_tokens"); // /installations
	var headers = {
		Authorization: ("bearer " + self.getAppToken()),
		Accept: "application/vnd.github.machine-man-preview+json"
	};
	let res = await fetch(url,{method: 'POST',headers: headers});
	let json = await res.json();
	
	installTokens[installId] = {ts: Date.now(),token: json.token};
	return json.token;
};

exports.getInstallations = self.getInstallations = async function (){
	var installations = await self.get("/app/installations",self.getAppToken());
	// console.log "got installation",installation
	return installations;
};

exports.getInstallation = self.getInstallation = async function (id){
	var installation = await self.get(("/app/installations/" + id),self.getAppToken());
	// console.log "got installation",installation
	return installation;
};

exports.getUserForLogin = self.getUserForLogin = async function (login){
	var user = await db.table('users').where({username: login}).first();
	// create fake user if does not exist?
	// we do want to return wrapped user?
	// TODO ensure that it is from github?
	return user;
};

exports.entityFromGitHubRef = self.entityFromGitHubRef = async function (ref){
	var entity = await db.table('entities').where({ref: ref}).first();
	return entity;
};

exports.getGraphInfo = self.getGraphInfo = async function (ref,stack){
	if(stack === undefined) stack = {};
	if (stack[ref]) {
		return Promise.resolve(stack[ref]);
	};
	let res = await self.ql(stack.token || personalAccessToken,infoQuery,{url: ("https://github.com/" + ref)});
	stack[ref] = res;
	return res;
};


exports.userFromGitHub = self.userFromGitHub = async function (params,stack){
	if(stack === undefined) stack = {};
	var user = await self.getUserForLogin(params.login);
	// var user = await db.table('users').where(username: login).first
	// create fake user if does not exist?
	// should be in transaction?
	
	if (!user) {
		if (!params.name) {
			params = await self.getGraphInfo(params.login,stack);
		};
		
		if (!params.login) {
			return null;
		};
		
		// unless params:name
		user = await db.put('users',{
			id: ("u" + (params.login)),
			username: params.login,
			name: params.name
		});
	};
	
	return user;
};

exports.userIdFromGitHub = self.userIdFromGitHub = async function (params){
	var user = await self.userFromGitHub(params);
	return user ? user.id : null;
};

// export def getRepository
exports.syncHub = self.syncHub = async function (graph,stack){
	
	if(stack === undefined) stack = {};
	if ((typeof graph=='string'||graph instanceof String)) {
		if (stack[graph]) {
			// already cached
			console.log("already synced hub!");
			return Promise.resolve(stack[graph]);
		};
		
		graph = await self.ql(stack.token || personalAccessToken,infoQuery,{url: ("https://github.com/" + graph)});
	};
	// var hub = await entityFromGitHubRef(graph:login)
	var typ = graph.__typename;
	var isOrg = typ == 'Organization';
	
	console.log("found hub!",graph);
	
	var data = {
		type: isOrg ? 'org' : 'user',
		ghid: graph.id,
		ghref: graph.login,
		ref: graph.login,
		visibility: 0,
		title: graph.name || graph.login,
		desc: graph.description || graph.bio,
		roles: {},
		data: {}
	};
	
	if (typ == 'User') {
		data.uid = await self.userIdFromGitHub(graph);
	} else if (stack.user && graph.viewerIsAMember) {
		data.roles[stack.user.id] = ROLES.DEVELOPER;
	};
	
	stack[graph.login] = await entities.upsert(data);
	return stack[graph.login];
};


exports.upsertRepository = self.upsertRepository = async function (data,stack){
	var ary;
	if(stack === undefined) stack = {};
	let ref = data.nameWithOwner || data.full_name;
	let token = stack.token;
	if (!ref) { return };
	
	var ary = iter$(ref.split("/"));var login = ary[0],name = ary[1];
	
	// do we really need to know the owner?
	let owner = await db.table('users').where({username: login}).first();
	let repo = await db.table('entities').where({ref: ref}).first();
	let priv = (data.isPrivate || data.private);
	
	// when importing from GitHub, entity should essentially be secret for anyone
	// without an explicit role
	
	// ensure that the parent exists
	let hub = await self.syncHub(login,stack);
	
	let values = {
		id: repo && repo.id || null,
		type: 'repo',
		ref: ref,
		visibility: priv ? ROLES.GOD : 0, // for now -- private?
		ghid: data.node_id,
		ghref: ref,
		title: data.name,
		desc: data.description,
		roles: repo && repo.roles || {}
	};
	
	// ghid?
	if (stack.ghapp) {
		values.ghapp = stack.ghapp;
	};
	
	var collaborators = await self.get(("/repos/" + ref + "/collaborators"),stack.token);
	console.log("found collaborators",collaborators);
	
	for (let i = 0, items = iter$(collaborators), len = items.length, user; i < len; i++) {
		user = items[i];
		let uid = await self.userIdFromGitHub({login: user.login,name: user.name});
		let role = ROLES.REPORTER;
		if (user.permissions.admin) {
			role = ROLES.MAINTAINER;
		} else if (user.permissions.push) {
			role = ROLES.DEVELOPER;
		};
		values.roles[uid] |= role;
	};
	
	repo = await entities.upsert(values);
	return repo;
};

exports.unlinkRepository = self.unlinkRepository = async function (ref){
	return await db.table('entities').where({ref: ref}).update({ghapp: null});
};


exports.syncInstallation = self.syncInstallation = async function (install){
	var owner;
	if ((typeof install=='number'||install instanceof Number)) {
		install = await self.getInstallation(install);
	};
	
	console.log("syncing installation",install.id);
	var token = await self.getInstallationToken(install.id);
	
	var stack = {
		token: token,
		ghapp: install.id
	};
	
	var isOrg = install.target_type == 'Organization';
	var login = install.account.login;
	var graph = await self.ql(token,query,{url: ("https://github.com/" + login)});
	
	// find or create group
	// var user = await db.table('users').where(username: login).first
	
	// user/installations/{install:id}
	let reporeq = await self.get("/installation/repositories",token,{all: 'repositories'});
	let repos = reporeq.repositories;
	
	var existing = await db.table('entities').where({ref: login}).first();
	
	// simply upsert the hub
	// var hub = await syncHub(login,stack)
	
	var group = {
		type: isOrg ? 'org' : 'user',
		ghid: graph.id,
		ghref: login,
		ref: login,
		// uid: (isOrg ? null : user:id) # shuold not be neede
		visibility: 0,
		title: graph.name,
		desc: graph.description || graph.bio,
		ghapp: install.id,
		roles: {},
		data: {
			website: graph.websiteUrl // need to merge this data
		}
	};
	
	
	if (existing) {
		for (let i = 0, items = ['data','git','github','roles'], len = items.length, key; i < len; i++) {
			key = items[i];
			if (group[key]) {
				group[key] = Object.assign(existing[key] || {},group[key] || {});
			};
		};
	};
	
	if (isOrg) {
		for (let o = graph.members, member, i = 0, keys = Object.keys(o), l = keys.length, name, user; i < l; i++){
			name = keys[i];member = o[name];if (user = await self.userFromGitHub({login: name,name: member.name,ghid: member.ghid})) {
				group.roles[user.id] |= ROLES.DEVELOPER;
			};
		};
	} else {
		group.uid = await self.userIdFromGitHub(graph);
		
		if (owner = await self.userFromGitHub({login: login,name: graph.name})) {
			group.roles[owner.id] |= ROLES.OWNER; // (group:roles[owner:id] or 0) | 
		};
	};
	
	group = await entities.upsert(group); // db.table('entities').where(id: user:eid).first
	
	for (let i = 0, items = iter$(repos), len = items.length; i < len; i++) {
		await self.upsertRepository(items[i],stack);
	};
	
	return;
};

// find all installations and sync them
exports.syncAll = self.syncAll = async function (){
	var installations = await self.getInstallations();
	for (let i = 0, items = iter$(installations), len = items.length; i < len; i++) {
		await self.syncInstallation(items[i]);
	};
	return true;
};

exports.syncLogin = self.syncLogin = async function (login){
	let res = await self.ql(personalAccessToken,infoQuery,{url: ("https://github.com/" + login)});
	if (res) {
		return await self.userFromGitHub(res);
	};
};


exports.syncMarketplacePlans = self.syncMarketplacePlans = async function (){
	var ghplans = await self.get("/marketplace_listing/plans",self.getAppToken());
	var plans = [];
	console.log(plans);
	
	for (let i = 0, items = iter$(ghplans), len = items.length, ghplan; i < len; i++) {
		ghplan = items[i];
		var plandata = {
			id: ("$" + (ghplan.name.toLowerCase())),
			ghid: ghplan.id,
			number: ghplan.number,
			name: ghplan.name,
			desc: ghplan.description,
			monthly_price_in_cents: ghplan.monthly_price_in_cents,
			yearly_price_in_cents: ghplan.yearly_price_in_cents,
			data: ghplan
		};
		
		var plan = await db.put('plans',plandata);
		plans.push(plan);
	};
	return plans;
};

exports.syncMarketplace = self.syncMarketplace = async function (){
	var v_, $1, $2;
	var plans = await self.get("/marketplace_listing/plans",self.getAppToken());
	console.log(plans);
	
	for (let i = 0, items = iter$(plans), len = items.length, ghplan; i < len; i++) {
		ghplan = items[i];
		var plandata = {
			id: ("$" + (ghplan.name.toLowerCase())),
			ghid: ghplan.id,
			number: ghplan.number,
			name: ghplan.name,
			desc: ghplan.description,
			monthly_price_in_cents: ghplan.monthly_price_in_cents,
			yearly_price_in_cents: ghplan.yearly_price_in_cents,
			data: ghplan
		};
		
		var plan = await db.put('plans',plandata);
		
		// find the entities that supposedly should have a plan
		var current = await db.table('entities').whereRaw("github->>'plan' = ?",[plan.id]);
		for (let j = 0, ary = iter$(current), len = ary.length, item; j < len; j++) {
			item = ary[j];
			current[item.ref] = item;
		};
		
		var accounts = await self.get(("/marketplace_listing/plans/" + (ghplan.id) + "/accounts"),self.getAppToken());
		for (let j = 0, ary = iter$(accounts), len = ary.length, account; j < len; j++) {
			account = ary[j];
			var entity = await self.entityFromGitHubRef(account.login);
			var reffed = current[entity.ref];
			if (entity) {
				if (reffed) { current.slice(current.indexOf(reffed),1) };
				let purchase = Object.assign({},account.marketplace_purchase);
				let gh = entity.github || {};
				(((v_ = purchase.plan),delete purchase.plan, v_));
				gh.plan = plan.id;
				gh.purchase = purchase;
				db.put('entities',{id: entity.id,github: gh});
			};
		};
		console.log("accounts for plan",JSON.stringify(accounts,null,4),len$(current));
		
		// these no longer have a plan?!
		for (let j = 0, ary = iter$(current), len = ary.length, item; j < len; j++) {
			item = ary[j];
			((($1 = item.github.plan),delete item.github.plan, $1));
			((($2 = item.github.purchase),delete item.github.purchase, $2));
			await db.put('entities',{id: item.id,github: item.github});
		};
	};
	
	return plans;
};

// export def upsertUserEntity user,ghuser
// 	var data = {
// 		# id: "u{login}"
// 		type: 'user'
// 		uid: user:id
// 		ref: user:username
// 		ghid: ghuser:node_id
// 		title: user:username
// 		desc: ghuser:bio
// 		ghref: user:username
// 	}
// 	var res = await entities.upsert(data)
// 	if !user:eid
// 		await db.table('users').update(eid: res:id).where(id: user:id)
// 	return res

exports.compareScopes = self.compareScopes = function (a,b){
	if (len$(a) > len$(b)) {
		return 1;
	} else if (len$(b) > len$(a)) {
		return -1;
	};
	
	if (a.indexOf('repo') >= 0) {
		return 1;
	} else {
		return 0;
	};
};

// if we supply a token, and it has better access than existing token
// it will save the new accessToken
exports.syncUser = self.syncUser = async function (user,authToken){
	var userToken = user.github_token && env.decrypt(user.github_token,user.username);
	var scopes = user.github_scopes || [];
	
	var ghuser = await self.get('/user',authToken || userToken,{scopes: true,all: true});
	console.log("ghuser",ghuser);
	
	if (ghuser.scopes) {
		// make sure to update the the 
		if (!userToken || self.compareScopes(ghuser.scopes,scopes) > 0) {
			await db.put('users',{id: user.id,
			github_scopes: ghuser.scopes,
			github_token: env.encrypt(authToken,user.username)});
		};
		// else
		//	authToken = userToken
		scopes = ghuser.scopes;
		authToken || (authToken = userToken);
	};
	
	var stack = {
		user: user,
		scopes: scopes,
		token: authToken
	};
	
	// don't sync more if user has no access
	if (scopes.length == 1 && scopes[0] == 'user:email') {
		return self;
	};
	
	var hub = await self.syncHub(user.username,stack);
	
	if (scopes.indexOf('public_repo') >= 0 || scopes.indexOf('repo') >= 0) {
		// var following = await get('/user/subscriptions',token, all: yes)
		var repos = await self.get('/user/repos',authToken,{all: true});
		
		for (let i = 0, items = iter$(repos), len = items.length; i < len; i++) {
			self.upsertRepository(items[i],stack);
		};
	};
	return self;
};

exports.check = self.check = function (token,vars){
	let client = new GraphQLClient('https://api.github.com/graphql',{
		headers: {Authorization: ("bearer " + token)}
	});
	
	// auth(token)
	// var user = await octokit:users.get
	return client.request(query,vars);
};
