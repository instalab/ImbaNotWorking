function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba'), _1 = Imba.createElement;
var protocol$ = require('../protocol'), SCON = protocol$.SCON, DIRTY = protocol$.DIRTY, ACTION = protocol$.ACTION;

var EditorView = require('./EditorView').EditorView;
var CSSVariables = require('../../util/CSSVariables').CSSVariables;


var Delay = require('../../util/Delay').Delay;
var PointerView = require('./PointerView').PointerView;
var BrushupView = require('./BrushupView').BrushupView;
var Agents = require('./Agents').Agents;

var Notification = require('./Notification').Notification;

// Dialogs
var SpaceMenu = require('./SpaceMenu').SpaceMenu;
var PublishDialog = require('./PublishDialog').PublishDialog;
var NewFileDialog = require('./NewFileDialog').NewFileDialog;
// import GroupJoinDialog from '../../site/components/GroupJoinDialog'
// import CastCreateDialog from '../../site/components/CastCreateDialog'
var DependencyAddDialog = require('./DependencyAddDialog').DependencyAddDialog;
var StreamDialog = require('./StreamDialog').StreamDialog;
var AskDialog = require('./AskDialog').AskDialog;
var UserMediaDialog = require('./UserMediaDialog').UserMediaDialog;

var BrushupView = require('./BrushupView').BrushupView;

var InterfaceView = require('./InterfaceView').InterfaceView;
var EditorView = require('./EditorView').EditorView;
var DiffEditorView = require('./DiffEditorView').DiffEditorView;
var ExplorerView = require('./ExplorerView').ExplorerView;
var SidebarView = require('./SidebarView').SidebarView;
var TitlebarView = require('./TitlebarView').TitlebarView;

// import SpaceDrawer from './SpaceDrawer'
var SpaceMorpher = require('./SpaceMorpher').SpaceMorpher;
var SpaceHeader = require('./SpaceHeader').SpaceHeader;

var PlaybackOverlay = require('./PlaybackOverlay').PlaybackOverlay;

var util = require('../util');

Mousetrap = require('../../vendor/mousetrap');
var ScrimbaGesture = require('../util/ScrimbaGesture').ScrimbaGesture;

var JoinDialog = require('./JoinDialog').JoinDialog;

if (false) {};

var ViewportOverlay = Imba.defineTag('ViewportOverlay', InterfaceView, function(tag){
	
	tag.prototype.blocking = function(v){ return this._blocking; }
	tag.prototype.setBlocking = function(v){ this._blocking = v; return this; };
	
	tag.prototype.ontap = function (e){
		var v_;
		if (e.target() == this && this.data().mode() == 'pip') {
			return (this.data().setMode(v_ = this.data()._prevMode),v_);
		};
	};
	
	tag.prototype.space = function (){
		return this.data().space();
	};
	
	tag.prototype.state = function (){
		return this.space().state();
	};
	
	tag.prototype.branch = function (){
		return this.space().branch();
	};
	
	tag.prototype.commit = function (){
		let branch = this.space().branch();
		let atStart = (this.space().timeline().currentTime() == 0 && this.space().isPaused() && this.space().branch() == this.space().trunk());
		let blocked = branch.isUnavailable();
		this.setEnabled(this.data().isPip() || atStart || branch.isUnavailable());
		this.setBlocking(blocked);
		return tag.prototype.__super__.commit.apply(this,arguments);
	};
	
	tag.prototype.render = function (){
		var $ = this.$;
		let unavailable = this.branch().isUnavailable();
		// TODO dont show this when pip?
		return this.$open(0).flagIf('blocking',unavailable).setChildren([
			(this._cover = this._cover||_1('div',this).flag('cover')),
			unavailable ? (
				($[0] || _1('div',$,0,this).flag('state')).setContent(
					(this.state() == 'waiting') ? (
						($[1] || _1('p',$,1,0).setText("Waiting"))
					) : ((this.state() == 'preparing') ? (
						($[2] || _1('p',$,2,0).setText("Preparing"))
					) : ((this.state() == 'live') ? (
						($[3] || _1('p',$,3,0).setText("Broadcast is live"))
					) : ((this.state() == 'processing') ? (
						($[4] || _1('p',$,4,0).setText("Scrim is being processed"))
					) : (
						($[5] || _1('p',$,5,0).setText("Scrim is unavailable"))
					))))
				,3)
			) : void(0),
			
			(this.space().isPaused() && this.state() == 'published') ? (
				($[6] || _1('div',$,6,this).flag('tool').flag('xl').flag('sticky').flag('primary').flag('play').flag('unless-pip').setNestedAttr('uxa','action','play').dataset('icon','play')).end()
			) : void(0),
			
			($[7] || _1('div',$,7,this).flag('tool').flag('xl').flag('only-pip').flag('blue').on$(0,['tap',['trigger','expand']],this).dataset('icon','expand')).end(),
			($[8] || _1('div',$,8,this).flag('tool').flag('xl').flag('only-pip').flag('red').on$(0,['tap',['trigger','close']],this).dataset('icon','mclose')).end()
		],1).synced();
	};
});


var Viewport = Imba.defineTag('Viewport', function(tag){
	
	tag.prototype.build = function (){
		var v_;
		return (this.setTabindex(v_ = -1),v_);
	};
});

var DragHandle = Imba.defineTag('DragHandle', function(tag){
	
	tag.prototype.view = function (){
		return this.parent();
	};
	
	tag.prototype.ontouchstart = function (t){
		this.flag('active');
		t.capture();
		return ScrimbaGesture.wrap(t,{type: 'move'});
	};
	
	tag.prototype.ontouchend = function (){
		this.unflag('active');
		return this;
	};
	
	tag.prototype.onmovestart = function (g){
		return this._box = this.view().dom().getBoundingClientRect();
	};
	
	tag.prototype.onmoveupdate = function (g){
		let x = this._box.left + g.dx();
		let y = this._box.top + g.dy();
		
		this.view().setPipLeft(x);
		return (this.view().setPipTop(y),y);
	};
});


var LogEntry = require('../widgets/browser/PlayerPage').LogEntry;

// Refactor to use Notification api
var LogEntryTip = Imba.defineTag('LogEntryTip', function(tag){
	
	var currentTip;
	
	tag.show = function (items,target){
		if (currentTip) {
			currentTip.hide();
			currentTip = null;
		};
		return Imba.mount(currentTip = (_1(LogEntryTip)).setData(items).setContainer(target).end(),target);
	};
	
	tag.prototype.container = function(v){ return this._container; }
	tag.prototype.setContainer = function(v){ this._container = v; return this; };
	
	tag.prototype.render = function (){
		var $ = this.$;
		return this.$open(0).flag('xl').flag('dark').setChildren(
			$[0] || _1('div',$,0,this).flag('main')
		,2).synced((
			$[0].setContent([
				($[1] || _1('div',$,1,0).flag('triangle')),
				(len$(this.data()) > 1) ? (
					($[2] || _1('div',$,2,0).flag('more').setText("..."))
				) : void(0),
				($[3] || _1(LogEntry,$,3,0)).bindData(this.data(),len$(this.data()) - 1).end()
			],1)
		,true));
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self.dom().offsetWidth;
		self.flag('show');
		return setTimeout(function() { return self.hide(); },2500);
	};
	
	tag.prototype.setup = function (){
		this.render();
		return this.autosize();
	};
	
	tag.prototype.autosize = function (){
		var Math_;
		let txt = this.dom().innerText;
		let lines = txt.split("\n");
		let longest = Math.max.apply(Math,lines.map(function(l) { return l.length; }));
		let maxWidth = this.container().offsetWidth * 0.8;
		
		let minFont = 13;
		let maxFont = maxWidth / (longest * 0.6);
		let fontSize = Math.round(Math.min(Math.max(maxFont,minFont),30));
		this.css('fontSize',fontSize + 'px');
		this.flag('overflows',maxFont < minFont);
		return this;
	};
	
	// def ontap
	// 	self:hide = do yes
	
	tag.prototype.hide = function (){
		var self = this;
		if (self.hasFlag('hide')) { return };
		self.flag('hide');
		return setTimeout(function() {
			self.orphanize();
			if (currentTip == self) { return currentTip = null };
		},3000);
	};
});


var SpaceView = Imba.defineTag('SpaceView', function(tag){
	
	tag.prototype.dirty = function(v){ return this._dirty; }
	tag.prototype.setDirty = function(v){ this._dirty = v; return this; };
	tag.prototype.__activeNode = {watch: 'activeNodeDidSet',name: 'activeNode'};
	tag.prototype.activeNode = function(v){ return this._activeNode; }
	tag.prototype.setActiveNode = function(v){
		var a = this.activeNode();
		if(v != a) { this._activeNode = v; }
		if(v != a) { this.activeNodeDidSet && this.activeNodeDidSet(v,a,this.__activeNode) }
		return this;
	};
	tag.prototype.__activeWidget = {watch: 'activeWidgetDidSet',name: 'activeWidget'};
	tag.prototype.activeWidget = function(v){ return this._activeWidget; }
	tag.prototype.setActiveWidget = function(v){
		var a = this.activeWidget();
		if(v != a) { this._activeWidget = v; }
		if(v != a) { this.activeWidgetDidSet && this.activeWidgetDidSet(v,a,this.__activeWidget) }
		return this;
	};
	tag.prototype.shortcuts = function(v){ return this._shortcuts; }
	tag.prototype.setShortcuts = function(v){ this._shortcuts = v; return this; };
	
	tag.prototype.__showInspector = {watch: 'markLayout',name: 'showInspector'};
	tag.prototype.showInspector = function(v){ return this._showInspector; }
	tag.prototype.setShowInspector = function(v){
		var a = this.showInspector();
		if(v != a) { this._showInspector = v; }
		if(v != a) { this.markLayout && this.markLayout(v,a,this.__showInspector) }
		return this;
	};
	tag.prototype.__showNavDrawer = {watch: 'markLayout',name: 'showNavDrawer'};
	tag.prototype.showNavDrawer = function(v){ return this._showNavDrawer; }
	tag.prototype.setShowNavDrawer = function(v){
		var a = this.showNavDrawer();
		if(v != a) { this._showNavDrawer = v; }
		if(v != a) { this.markLayout && this.markLayout(v,a,this.__showNavDrawer) }
		return this;
	};
	tag.prototype.__playState = {watch: 'playStateDidSet',name: 'playState'};
	tag.prototype.playState = function(v){ return this._playState; }
	tag.prototype.setPlayState = function(v){
		var a = this.playState();
		if(v != a) { this._playState = v; }
		if(v != a) { this.playStateDidSet && this.playStateDidSet(v,a,this.__playState) }
		return this;
	};
	tag.prototype.__size = {'default': 'auto',watch: 'sizeDidSet',name: 'size'};
	tag.prototype.size = function(v){ return this._size; }
	tag.prototype.setSize = function(v){
		var a = this.size();
		if(v != a) { this._size = v; }
		if(v != a) { this.sizeDidSet && this.sizeDidSet(v,a,this.__size) }
		return this;
	}
	tag.prototype._size = 'auto';
	
	tag.prototype.tab = function(v){ return this._tab; }
	tag.prototype.setTab = function(v){ this._tab = v; return this; }; // hacky way to highlight tab
	
	tag.prototype.options = function(v){ return this._options; }
	tag.prototype.setOptions = function(v){ this._options = v; return this; };
	tag.prototype.manager = function(v){ return this._manager; }
	tag.prototype.setManager = function(v){ this._manager = v; return this; };
	tag.prototype.__mode = {watch: 'modeDidSet',name: 'mode'};
	tag.prototype.mode = function(v){ return this._mode; }
	tag.prototype.setMode = function(v){
		var a = this.mode();
		if(v != a) { this._mode = v; }
		if(v != a) { this.modeDidSet && this.modeDidSet(v,a,this.__mode) }
		return this;
	};
	tag.prototype.morphing = function(v){ return this._morphing; }
	tag.prototype.setMorphing = function(v){ this._morphing = v; return this; };
	tag.prototype.closing = function(v){ return this._closing; }
	tag.prototype.setClosing = function(v){ this._closing = v; return this; }; // rather opening and closing state?
	tag.prototype.__anchorNode = {'default': null,watch: 'anchorNodeDidSet',name: 'anchorNode'};
	tag.prototype.anchorNode = function(v){ return this._anchorNode; }
	tag.prototype.setAnchorNode = function(v){
		var a = this.anchorNode();
		if(v != a) { this._anchorNode = v; }
		if(v != a) { this.anchorNodeDidSet && this.anchorNodeDidSet(v,a,this.__anchorNode) }
		return this;
	}
	tag.prototype._anchorNode = null;
	tag.prototype.__pinned = {'default': false,watch: 'pinnedDidSet',name: 'pinned'};
	tag.prototype.pinned = function(v){ return this._pinned; }
	tag.prototype.setPinned = function(v){
		var a = this.pinned();
		if(v != a) { this._pinned = v; }
		if(v != a) { this.pinnedDidSet && this.pinnedDidSet(v,a,this.__pinned) }
		return this;
	}
	tag.prototype._pinned = false;
	
	tag.prototype.__fontSize = {'default': 13,watch: 'fontSizeDidSet',name: 'fontSize'};
	tag.prototype.fontSize = function(v){ return this._fontSize; }
	tag.prototype.setFontSize = function(v){
		var a = this.fontSize();
		if(v != a) { this._fontSize = v; }
		if(v != a) { this.fontSizeDidSet && this.fontSizeDidSet(v,a,this.__fontSize) }
		return this;
	}
	tag.prototype._fontSize = 13;
	tag.prototype.__userFontSize = {watch: 'userFontSizeDidSet',name: 'userFontSize'};
	tag.prototype.userFontSize = function(v){ return this._userFontSize; }
	tag.prototype.setUserFontSize = function(v){
		var a = this.userFontSize();
		if(v != a) { this._userFontSize = v; }
		if(v != a) { this.userFontSizeDidSet && this.userFontSizeDidSet(v,a,this.__userFontSize) }
		return this;
	};
	tag.prototype.__sidebarWidth = {watch: 'syncStyleVar',reflow: true,name: 'sidebarWidth'};
	tag.prototype.sidebarWidth = function(v){ return this._sidebarWidth; }
	tag.prototype.setSidebarWidth = function(v){
		var a = this.sidebarWidth();
		if(v != a) { this._sidebarWidth = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__sidebarWidth) }
		return this;
	};
	tag.prototype.__scale = {'default': 1,watch: 'syncStyleVar',reflow: true,name: 'scale'};
	tag.prototype.scale = function(v){ return this._scale; }
	tag.prototype.setScale = function(v){
		var a = this.scale();
		if(v != a) { this._scale = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__scale) }
		return this;
	}
	tag.prototype._scale = 1;
	
	tag.prototype.__anchorVisible = {'default': false,watch: 'anchorVisibleDidSet',name: 'anchorVisible'};
	tag.prototype.anchorVisible = function(v){ return this._anchorVisible; }
	tag.prototype.setAnchorVisible = function(v){
		var a = this.anchorVisible();
		if(v != a) { this._anchorVisible = v; }
		if(v != a) { this.anchorVisibleDidSet && this.anchorVisibleDidSet(v,a,this.__anchorVisible) }
		return this;
	}
	tag.prototype._anchorVisible = false;
	tag.prototype.__anchorTop = {watch: 'syncStyleVar',unit: 'px',name: 'anchorTop'};
	tag.prototype.anchorTop = function(v){ return this._anchorTop; }
	tag.prototype.setAnchorTop = function(v){
		var a = this.anchorTop();
		if(v != a) { this._anchorTop = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__anchorTop) }
		return this;
	};
	tag.prototype.__anchorLeft = {watch: 'syncStyleVar',unit: 'px',name: 'anchorLeft'};
	tag.prototype.anchorLeft = function(v){ return this._anchorLeft; }
	tag.prototype.setAnchorLeft = function(v){
		var a = this.anchorLeft();
		if(v != a) { this._anchorLeft = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__anchorLeft) }
		return this;
	};
	tag.prototype.__anchorWidth = {watch: 'syncStyleVar',unit: 'px',name: 'anchorWidth'};
	tag.prototype.anchorWidth = function(v){ return this._anchorWidth; }
	tag.prototype.setAnchorWidth = function(v){
		var a = this.anchorWidth();
		if(v != a) { this._anchorWidth = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__anchorWidth) }
		return this;
	};
	tag.prototype.__anchorHeight = {watch: 'syncStyleVar',unit: 'px',name: 'anchorHeight'};
	tag.prototype.anchorHeight = function(v){ return this._anchorHeight; }
	tag.prototype.setAnchorHeight = function(v){
		var a = this.anchorHeight();
		if(v != a) { this._anchorHeight = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__anchorHeight) }
		return this;
	};
	tag.prototype.__contrastRatio = {'default': 0,watch: 'syncStyleVar',name: 'contrastRatio'};
	tag.prototype.contrastRatio = function(v){ return this._contrastRatio; }
	tag.prototype.setContrastRatio = function(v){
		var a = this.contrastRatio();
		if(v != a) { this._contrastRatio = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__contrastRatio) }
		return this;
	}
	tag.prototype._contrastRatio = 0;
	
	tag.prototype.__pipLeft = {watch: 'syncStyleVar',name: 'pipLeft'};
	tag.prototype.pipLeft = function(v){ return this._pipLeft; }
	tag.prototype.setPipLeft = function(v){
		var a = this.pipLeft();
		if(v != a) { this._pipLeft = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__pipLeft) }
		return this;
	}; // , unit: 'px'
	tag.prototype.__pipTop = {watch: 'syncStyleVar',name: 'pipTop'};
	tag.prototype.pipTop = function(v){ return this._pipTop; }
	tag.prototype.setPipTop = function(v){
		var a = this.pipTop();
		if(v != a) { this._pipTop = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__pipTop) }
		return this;
	}; // , unit: 'px'
	tag.prototype.__pipOrder = {'default': -1,watch: 'syncStyleVar',name: 'pipOrder'};
	tag.prototype.pipOrder = function(v){ return this._pipOrder; }
	tag.prototype.setPipOrder = function(v){
		var a = this.pipOrder();
		if(v != a) { this._pipOrder = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__pipOrder) }
		return this;
	}
	tag.prototype._pipOrder = -1;
	
	tag.prototype.syncStyleVar = function (value,prev,key){
		let name = key.name;
		let unit = key.unit;
		this.dom().style.setProperty('--' + name,unit ? ((value + unit)) : value);
		if (key.reflow) { return this.space().emit('reflow') };
	};
	
	tag.prototype.cssvars = function (){
		return this._cssvars || (this._cssvars = new CSSVariables(this));
	};
	
	tag.prototype.userFontSizeDidSet = function (size){
		return (this.setFontSize(size),size);
	};
	
	tag.prototype.fontSizeDidSet = function (size){
		this.setFlag('fontSize',("fs" + size));
		if (this._mounted) { return this.reflow() };
	};
	
	tag.prototype.option = function (key){
		return this._options && this._options[key];
		// val == undefined ? space.option(key) : val
	};
	
	tag.prototype.morph = function (dur,cb){
		var self = this;
		if (self._morphing) {
			return cb && cb();
		};
		
		self._morphing = true;
		var start = self.dom().getBoundingClientRect();
		var morpher = (_1(SpaceMorpher)).setData(self).end();
		morpher.markStart(start);
		
		cb && cb(morpher);
		
		// console.warn "MORPHING",morpher,dom:className
		
		// setting actual window-states
		// setFlag('viewMode',pip ? "is-pip" : "is-{mode}")
		self.setFlag('viewMode',("is-" + self.mode()));
		self.flag('closing',self.closing());
		self.unflag('appearing');
		if (self.closing()) { self.trigger('closing') };
		
		if (self._mounted) self.reflow();
		self.render();
		
		morpher.markEnd(self.dom().getBoundingClientRect());
		
		let box = self._mounting && self._mounted && self.option('animateFrom');
		if (box) { morpher.transformFrom(box) };
		
		self.trigger('morph',{mode: self.mode(),closing: self.closing()});
		
		let after = function() {
			self.unflag('morphing');
			self.trigger('morphend',{mode: self.mode()});
			self._animating = false;
			self._morphing = false;
			morpher.hide();
			morpher = null;
			if (self.anchorNode() && self.mode() == 'inline') { self.anchorNode().unflag('detached') };
			if (self.anchorNode()) { self.anchorNode().flag('occluded',!(self.anchorVisible())) };
			if (self.closing()) { return self.dispose() };
		};
		
		
		if (!self._mounted || dur == 0 || morpher.isImmediate()) {
			after();
			return self;
		};
		
		document.body.appendChild(morpher.dom());
		self._animating = true;
		self.flag('morphing');
		morpher.animate(dur + 10,after);
		return self;
	};
	
	
	tag.prototype.isInline = function (){
		return this.mode() == 'inline';
	}; // pip and anchorNode and (anchorVisible or !pinned)
	tag.prototype.isPip = function (){
		return this.mode() == 'pip';
	}; // pip and !isInline
	tag.prototype.isFullscreen = function (){
		return this.mode() == 'fullscreen';
	}; // !isInline and !pip
	tag.prototype.isTheater = function (){
		return this.mode() == 'theater';
	}; // !isInline and !pip
	tag.prototype.isModal = function (){
		return this.isFullscreen() || this.isTheater();
	};
	
	tag.prototype.hasAnchor = function (){
		return !(!(this.anchorNode()));
	};
	
	tag.prototype.modeDidSet = function (mode,prev){
		this._prevMode = prev;
		if (this.anchorNode() && mode != 'inline') { this.anchorNode().flag('detached') };
		return this.morph(250,function() { return true; });
	};
	
	tag.prototype.anchorNodeDidSet = function (node,prev){
		return this;
	};
	
	tag.prototype.viewMode = function (){
		return this.mode();
	};
	
	tag.prototype.detachFromAnchor = function (){
		var self = this;
		self.setAnchorNode(null);
		return self.morph(function() { var v_;
		return (self.setMode(v_ = 'pip'),v_); });
	};
	
	tag.prototype.attachToAnchor = function (anchor){
		this.setAnchorNode(anchor);
		this.reanchor();
		if (anchor && this.anchorVisible() && this.isPip()) {
			this.setMode('inline');
		};
		return this;
	};
	
	tag.prototype.onmaximize = function (e){
		var v_;
		return (this.setMode(v_ = 'fullscreen'),v_);
	};
	
	tag.prototype.onminimize = function (e){
		var v_;
		return (this.setMode(v_ = 'pip'),v_);
	};
	
	tag.prototype.onpin = function (e){
		return (this.setPinned(true),true);
	};
	
	tag.prototype.onunpin = function (e){
		this.pause();
		return (this.setPinned(false),false);
	};
	
	tag.prototype.onclose = function (e,params){
		var v_;
		this.log("SpaceView.onclose",e);
		e.stop();
		this.pause();
		if (this.anchorNode() && !(this.isInline())) {
			return (this.setMode(v_ = 'inline'),v_);
		} else {
			return this.close(params || {});
		};
	};
	
	tag.prototype.close = function (options){
		var self = this;
		if(options === undefined) options = {};
		self.log("SpaceView.close");
		// even if inline?
		return self.morph(options.immediate ? 0 : 250,function() { return (self.setClosing(true),true); });
	};
	
	tag.prototype.onexpand = function (){
		this.log('expand');
		if (this.isPip()) {
			this.setMode('theater');
		};
		return this;
	};
	
	tag.prototype.onexitfullscreen = function (){
		var v_;
		return (this.setMode(v_ = this._prevMode || 'pip'),v_);
	};
	
	tag.prototype.onenterfullscreen = function (){
		var v_;
		return (this.setMode(v_ = 'fullscreen'),v_);
	};
	
	tag.prototype.hasTouchInterface = function (){
		return this.hasFlag('touch-ux');
	};
	
	tag.prototype.space = function (){
		return this.data();
	};
	
	tag.prototype.browser = function (){
		return this.space().browser();
	};
	
	tag.prototype.model = function (){
		return this.space().model();
	};
	
	tag.prototype.branch = function (){
		return this.space().branch();
	};
	
	tag.prototype.timeline = function (){
		return this.space().timeline();
	};
	
	tag.prototype.client = function (){
		return this.data().client();
	};
	
	tag.prototype.requestFocus = function (target){
		this._requestedFocus = target;
		return this;
	};
	
	tag.prototype.resolveFocus = function (){
		var target;
		if (target = this._requestedFocus) {
			// console.log "set focus to",@requestedFocus
			if ((target instanceof Imba.Tag) || (target instanceof Element)) {
				target = util.callClosest(target,'focusWidgetForNode');
			};
			this._requestedFocus = null;
			this.space().emit('refocus',target);
			return Imba.commit();
		};
	};
	
	tag.prototype.setup = function (){
		var self = this;
		self._layoutCache = {};
		self._marked = {layout: 0};
		self._autoFontSize = 12;
		self._dirty = DIRTY.SIZE;
		self._loaded = false;
		
		self.resolveFocus = self.resolveFocus.bind(self);
		
		self._onresized = new Delay(function() {
			self._dirty |= DIRTY.SIZE;
			return self.reflow();
		});
		
		self._handlers = {};
		self._handlers.window = {
			resize: function(e) {
				self._resized = true;
				self._onresized.delay(200);
				return self.reanchor();
			},
			
			mousedown: function(e) {
				if (!self.dom().contains(e.target)) { return };
				let closest = util.findClosestWithMethod(e.target,'focusWidgetForNode');
				return self.requestFocus(closest);
			},
			
			mouseup: function(e) {
				if (!self.dom().contains(e.target)) { return };
				// console.log 'mouseup',e:target
				return self.space().once('ticked',self.resolveFocus);
			}
		};
		
		if (false) {};
		return self;
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self.log('mounting',self);
		self.dataset({id: self.space().id()});
		self._mounting = true;
		
		// set viewMode
		self._mode = self.option('mode') || 'fullscreen';
		self.setFlag('viewMode',("is-" + (self._mode)));
		self.setAnchorNode(self.option('anchor'));
		// do this before we are actually mounted
		self.reanchor();
		self._mounted = true;
		
		self.setTabindex(0);
		self.space().emit('mounted');
		
		self._onreflow = function() {
			self._resized = false;
			return self.reflow();
		};
		
		self._onwinscroll = function() {
			// invalidate box-cache
			self._box = null;
			return self.reanchor({scroll: true});
		};
		
		window.addEventListener('scroll',self._onwinscroll,{passive: true,capture: true});
		window.addEventListener('orientationchange',self._onreflow,true);
		
		for (let o = self._handlers.window, handler, i = 0, keys = Object.keys(o), l = keys.length, event; i < l; i++){
			event = keys[i];handler = o[event];window.addEventListener(event,handler,true);
		};
		
		self.api().on('reflow',self._onreflow);
		self.api().on('reanchor',self._onwinscroll);
		
		// TODO fix playerBridge
		if (self.api().isEmbed() && !(self.playejsBridge()) && self.space().timeline().audio) {
			self.setPlayerjsBridge({});
			setTimeout(function() {
				if (self.space().timeline().audio()) {
					self.setPlayerjsBridge(new (self.playerjs().HTML5Adapter)(self.space().timeline().audio()));
					return self.playerjsBridge().ready();
				};
			},10);
		};
		
		self.mountLogAlerts();
		self.reflow();
		
		if (!(self.isInline()) && !self.option('demo')) {
			self.dom().focus();
		};
		
		// if option(:animateFrom) or option(:animateIn)
		// 	morph(2500) do yes
		
		if (self.option('animateIn')) {
			self.setFlag('animState','opening');
			self._opening = true;
			setTimeout(function() {
				self.setFlag('animState','opened');
				return setTimeout(function() {
					self.setFlag('animState',null);
					return self._opening = false;
				},320);
			},10);
		};
		
		self._mounting = false;
		self.schedule({events: true});
		
		return self;
	};
	
	// disposableOn
	tag.prototype.don = function (target,ev,func){
		this._disposables || (this._disposables = []);
		this._disposables.push([target,ev,target.on(ev,func)]);
		return this;
	};
	
	
	tag.prototype.tick = function (){
		this.space()._dirty = true;
		return this;
	};
	
	tag.prototype.onfocusin = function (){
		return true;
	};
	
	tag.prototype.mountLogAlerts = function (){
		var self = this;
		let logs = [];
		let showLogs = function() {
			let last = logs[logs.length - 1];
			let currOffset = self.space().timeline().currentOffset();
			if (last && Math.abs(currOffset - last.timeOffset()) < 1000) {
				LogEntryTip.show(logs.map(function(item) { return item._params; }),self._viewport.dom());
			};
			return logs = [];
		};
		
		return self.space().on('log',function(item) {
			logs.push(item);
			return logs.TIMEOUT || (logs.TIMEOUT = setTimeout(showLogs,15));
		});
	};
	
	tag.prototype.unmount = function (){
		var space_;
		this.unschedule();
		(space_ = this.space()) && space_.emit  &&  space_.emit('unmounted');
		window.removeEventListener('orientationchange',this._onreflow,true);
		window.removeEventListener('scroll',this._onwinscroll,true);
		this.api().un('reflow',this._onreflow);
		this.api().un('reanchor',this._onwinscroll);
		
		for (let i = 0, items = iter$(this._disposables), len = items.length, pair; i < len; i++) {
			pair = items[i];
			pair[0].un(pair[1],pair[2]);
		};
		this._disposables = null;
		
		for (let o = this._handlers.window, handler, i = 0, keys = Object.keys(o), l = keys.length, event; i < l; i++){
			event = keys[i];handler = o[event];window.removeEventListener(event,handler,true);
		};
		
		if (this._modeNotification) {
			this._modeNotification.hide();
			this._modeNotification = null;
		};
		return this;
	};
	
	tag.prototype.dispose = function (){
		var self = this;
		self.trigger('dispose');
		self.space().terminate();
		self.space().dispose();
		self._activeEl = null;
		self._controls && self._controls.dispose  &&  self._controls.dispose();
		self._shortcuts && self._shortcuts.disable  &&  self._shortcuts.disable();
		self._shortcuts = null; // ?.dispose
		self.render = function() { return self; };
		// Fix to make sure tweenmax removes the last reference
		// TweenMax.to(document.createElement('div'),0.1,{opacity: 0.1})
		// view.space.dispose
		// view.orphanize
		self.orphanize();
		return self;
	};
	
	tag.prototype.startPublishing = function (branch){
		return this.uxa().open((_1(PublishDialog)).setData(branch || this.space().branch()).end());
	};
	
	tag.prototype.alert = function (text,options){
		// automatically hide if already shown?
		options || (options = {});
		options.target = this.dom();
		
		return Notification.show(text,options);
	};
	
	tag.prototype.box = function (){
		var el;
		if (this._box) { return this._box };
		if (el = (this._viewport && this._viewport.dom())) {
			let bounds = el.getBoundingClientRect();
			return this._box = {
				top: Math.round(bounds.top), // (el:offsetTop + dom:offsetTop + par:offsetTop)
				left: Math.round(bounds.left), // (el:offsetLeft + dom:offsetLeft + par:offsetLeft)
				width: Math.round(bounds.width), // ow
				height: Math.round(bounds.height) // oh
			};
		};
	};
	
	tag.prototype.playStateDidSet = function (state,prev){
		
		var v_;
		if (this._modeNotification) {
			this._modeNotification.hide();
			this._modeNotification = null;
		};
		
		let text;
		if (state == 'paused' && prev == 'playing' && this.space().timeline().progress() < 0.99) {
			text = "_pause_ paused";
		} else if (state == 'playing' && prev == 'paused' && this.space().timeline().currentTime() > 50) {
			text = "_play_ resumed";
		} else if (state == 'editing' && this.branch().isLocal() && this.branch() != this.space().trunk()) {
			text = "Now editing – click _play_ to resume watching";
			if (this.isPip()) { (this.setMode(v_ = 'theater'),v_) };
			return this.alert(this._modeNotification = (_1(Notification).flag('info').setSticky(true)).setText(text).end());
		};
		
		if (text) {
			return this.alert(this._modeNotification = (_1(Notification).flag('system')).setText(text).end());
		};
	};
	
	
	tag.prototype.checkActiveWidget = function (){
		var v_;
		var el = document.activeElement;
		if (el && el._tag && this._viewport.contains(el)) {
			return (this.setActiveWidget(v_ = util.callClosest(el._tag,'focusWidgetForNode')),v_);
		};
	};
	
	tag.prototype.activeWidgetDidSet = function (widget,prev){
		// log "activeWidgetDidSet",widget and widget.TYPE,prev and prev.TYPE
		if (prev) { this._prevActiveWidget = prev };
		if (this.space().me()) {
			this.space().me().setFocus(widget); // what if we are not even editing?!
		};
		
		if (!this.browser().windowed()) {
			if (widget == this.browser()) { (this.browser().setMinimized(false),false) };
			if (prev == this.browser()) { return (this.browser().setMinimized(true),true) };
		};
	};
	
	tag.prototype.sizeDidSet = function (size,prev){
		this.setFlag('size',("size-" + size));
		this.flagIf('centered',size && size != 'auto');
		if (this._mounted) { return this.reflow() };
	};
	
	tag.prototype.checkActiveElement = function (){
		if (this._requestedFocus) { return };
		this.setActiveNode(Imba.getTagForDom(document.activeElement));
		return this;
	};
	
	tag.prototype.activeNodeDidSet = function (node,prev){
		// log "activeNodeDidSet",node,prev
		var v_;
		if (node && this._viewport.contains(node)) {
			return (this.setActiveWidget(v_ = util.callClosest(node,'focusWidgetForNode')),v_);
		};
	};
	
	tag.prototype.focusViewport = function (){
		if (!this._viewport.contains(document.activeElement)) {
			this._viewport.dom().focus();
		};
		return this;
	};
	
	tag.prototype.maximize = function (){
		this.log('maximize');
		return this;
	};
	
	tag.prototype.minimize = function (){
		this.log('minimize');
		return this;
	};
	
	
	// get position of anchorNode and update
	tag.prototype.reanchor = function (){
		var self = this;
		if (!(self.anchorNode())) { return };
		
		if (self.hasFlag('unanchoring')) {
			console.log("reattaching to new anchor now");
			self.unflag('unanchoring');
			self._animating = false;
			self;
		};
		
		var el = self.anchorNode()._dom || self.anchorNode();
		var anchor = el.getBoundingClientRect();
		
		if (anchor.width == 0 && anchor.height == 0) {
			// log "REANCHOR remove"
			self.setAnchorNode(null);
			// make sure it is not rendering or doing anything until
			// next frame - in which it might have received a request
			// to reopen.
			if (self.isInline()) {
				self.flag('unanchoring');
				self._animating = true;
				
				// transform out - wait
				setTimeout(function() {
					if (self.hasFlag('unanchoring') && !(self.anchorNode())) {
						// console.log "still no anchorNode"
						self._animating = false;
						return self.trigger('close',{immediate: true});
					};
					// if isInline
				},100);
			};
			return self;
		};
		
		var vh = window.innerHeight;
		var ah = anchor.height;
		self.setAnchorTop(Math.round(anchor.top + (App.scrollTop() || 0)));
		self.setAnchorLeft(Math.round(anchor.left)); // + 0 # scrollLeft
		self.setAnchorHeight(Math.round(anchor.height));
		self.setAnchorWidth(Math.round(anchor.width));
		self.setAnchorVisible((anchor.bottom > ah * 0.7) && anchor.bottom < (vh + ah * 0.3));
		return self;
	};
	
	tag.prototype.anchorVisibleDidSet = function (bool,prev){
		var self = this;
		return self.morph(250,function() {
			return self.flag('anchor-visible',bool);
		});
	};
	
	tag.prototype.reflow = function (){
		var self = this;
		var el = self._viewport && self._viewport.dom();
		
		if (!el) { return };
		if (self._reflowing || self._opening) { return };
		
		var box = self._box;
		var bounds = el.getBoundingClientRect();
		var ow = bounds.width;
		var oh = bounds.height;
		
		if (ow == 0) { return };
		
		self._reflowing = true;
		
		// round numbers
		self._box = {
			top: Math.round(bounds.top), // (el:offsetTop + dom:offsetTop + par:offsetTop)
			left: Math.round(bounds.left), // (el:offsetLeft + dom:offsetLeft + par:offsetLeft)
			width: Math.round(bounds.width), // ow
			height: Math.round(bounds.height) // oh
		};
		
		self._layoutCache = {};
		// should use userFontSize as well?
		// should maybe be affected by whether drawer is open?
		let prevAutoFontSize = self._autoFontSize; // @pip ? 8 : 
		let fontSizeOption = self.space().option('fontSize');
		
		let fs = 10;
		
		if (ow < 400) {
			fs = self.isPip() ? 6 : 9;
		} else if (ow < 500) {
			fs = self.isPip() ? 8 : 10;
		} else if (ow < 700) {
			fs = 10;
		} else if (ow < 970) {
			fs = 11;
		} else if (ow < 1450) { // 1280
			fs = 12;
		} else {
			fs = 13;
		};
		
		// if scale < 1
		// 	fs -= 2
		
		if ((oh / (fs * 1.5)) < 15 && fs > 10) {
			fs = 10;
		};
		
		if ((typeof fontSizeOption=='number'||fontSizeOption instanceof Number)) {
			self._autoFontSize = fs = fontSizeOption;
			self.setFontSize(fs);
		} else {
			self._autoFontSize = fs;
			if (self.fontSize() == prevAutoFontSize) {
				self.setFontSize(fs);
			};
		};
		
		self._dirty |= DIRTY.SIZE;
		
		var area = ow * oh;
		
		if (area > 0 && area < 360000 && !self.hasFlag('touch-ux')) {
			self.flag('touch-controls');
		};
		
		self.flag('touch-ux',area < 360000 && 'ontouchstart' in window);
		self.flag('portrait',oh >= ow);
		self.flag('landscape',oh < ow);
		
		self.flag('sidebar-float',ow < 740 && self.space().option('sidebar') == 'auto');
		
		if (self._dirty) {
			self.flag('reflowing');
			clearTimeout(self._reflowTimeout);
			self._reflowTimeout = setTimeout(function() {
				return self.unflag('reflowing');
			},300);
		};
		
		// include viewport size in stream
		self.space().me().setVw(self._box.width);
		self.space().me().setVh(self._box.height);
		
		// way too much going on here?
		self.space().emit('resize'); // what if it was not resized?
		self.space().emit('reflow',self._dirty);
		self.space().emit('resized');
		
		self._marked.layout = self.space()._marked.layout;
		self._dirty = 0;
		self._reflowing = false;
		return self;
	};
	
	tag.prototype.getStyleVar = function (varname){
		var cs = window.getComputedStyle(this.dom());
		var val = cs.getPropertyValue('--' + varname);
		return val;
	};
	
	tag.prototype.setStyleVar = function (varname,value){
		this.dom().style.setPropertyValue('--' + varname,value);
		return this;
	};
	
	tag.prototype.targetForPointer = function (el){
		let browser = this.space().browser();
		
		// always keep pointer-focus on browser when it is front and center
		if (this.space().agent().focus() == browser && !browser.windowed() && !browser.minimized() && !browser.node().contains(el)) {
			return browser.node();
		};
		
		let target = el.closest('[data-sref]');
		return target ? ((target._tag || target)) : null;
		// return target ? SCON.strToPath(target:dataset:ref) : null
	};
	
	tag.prototype.lookup = function (key){
		if (key instanceof Element) {
			return key._tag;
		};
		
		if (key instanceof Imba.Tag) {
			return key;
		};
		
		if (!((typeof key=='string'||key instanceof String))) {
			key = SCON.pathToStr(key);
		};
		
		let target = this.dom().querySelector(("[data-sref=\"" + key + "\"]"));
		// log "lookup",key,target
		return target ? target._tag : null;
	};
	
	tag.prototype.layoutForNode = function (nodeOrRef,cache){
		var cached, $1;
		if(cache === undefined) cache = false;
		let node = this.lookup(nodeOrRef);
		
		if (node && node.nodeForLayout) {
			node = node.nodeForLayout();
		};
		
		if (!((node instanceof Imba.Tag))) { return null };
		
		if (cache && node.sref()) {
			if (cached = this._layoutCache[node.sref()]) {
				return cached;
			};
		};
		
		if (node.layoutForNode) {
			return node.layoutForNode(this);
		};
		
		var el = node._dom || node; // should be possible to force?
		
		if (!this.dom().contains(el)) {
			return null;
		};
		
		// if we want this to work even with transforms we do need
		// to traverse up offsetParent chain and calculate
		let rect;
		let box;
		
		if (this.option('disableLayoutOptimizations')) {
			// console.log "unoptimized layout"
			let root = this._viewport.dom();
			let layoutEl = el;
			box = {top: 0,left: 0};
			rect = {
				top: 0,
				left: 0,
				width: layoutEl.offsetWidth,
				height: layoutEl.offsetHeight
			};
			while (layoutEl != root && root.contains(layoutEl)){
				rect.top += layoutEl.offsetTop;
				rect.left += layoutEl.offsetLeft;
				layoutEl = layoutEl.offsetParent;
			};
		} else {
			rect = el.getBoundingClientRect();
			box = this._viewport.dom().getBoundingClientRect();
		};
		
		let layout = [
			Math.round(rect.top - box.top),
			Math.round(rect.left - box.left),
			Math.round(rect.width),
			Math.round(rect.height),
			(($1 = node) && $1.layoutMask  &&  $1.layoutMask() || 0)
		];
		
		if (cache && node.sref()) {
			this._layoutCache[node.sref()] = layout;
		};
		
		return layout;
	};
	
	tag.prototype.pushNodeLayout = function (node,layout){
		// only if element has a reference?
		if (this.space().isSpectating()) { return };
		
		var sref = node.sref();
		layout || (layout = this.layoutForNode(node));
		// Must look for my layouts
		var cache = this.space().branch().stream().state(this.space().me());
		var existing = cache && cache.layouts[sref];
		
		if (String(layout) != String(existing)) {
			this.branch().push_(ACTION.NODE_LAYOUT,[sref,layout],{});
		};
		return node;
	};
	
	tag.prototype.oncontextmenu = function (e){
		return e.prevent().halt();
	};
	
	// action handlers
	tag.prototype.onannotate = function (e,branch){
		e.stop();
		branch.startAnnotating();
		this.dom().focus();
		this.setMode('fullscreen');
		return (this.setPinned(true),true);
	};
	tag.prototype.onask = function (e){
		throw "not implemented";
		return e.stop();
	};
	
	tag.prototype.onbrushupstop = function (e){
		e.halt();
		return this.branch().stopAnnotating();
	};
	
	tag.prototype.onrecstart = function (e,branch){
		throw "not implemented";
	};
	
	tag.prototype.onrecstop = function (e,branch){
		e.halt();
		branch.stopRecording();
		return this;
	};
	
	tag.prototype.ongolive = function (e){
		e.stop();
		if (!this.space().branch().canGoLive()) { return };
		// uxa.open(<StreamDialog[space.branch]>)
	};
	
	tag.prototype.onstoplive = function (e){
		e.stop();
		return this.space().branch().stopRecording();
	};
	
	tag.prototype.onspacezip = function (e){
		e.halt();
		let index = this.space().cursor().current().index();
		if (!this.space().branch().isLocal()) {
			this.uxa().flash("Generating .zip");
			return window.location = ("/casts/" + (this.space().branch().id()) + ".zip?index=" + index);
		} else {
			return this.uxa().flash("You need to save before downloading .zip");
		};
	};
	
	tag.prototype.onspaceclone = async function (e){
		throw "not implemented";
		var params = this.space().clone();
		this.log('onspaceclone',e,params);
		await this.api().tryLogin();
		if (!this.api().user()) { return };
	};
	
	tag.prototype.onspacemenu = function (e){
		e.stop();
		return e.uxa().open((_1(SpaceMenu)).bindData(this,'space',[]).end());
	};
	
	tag.prototype.onshowannotation = function (e,annotation){
		e.stop();
		return (this.space().setAnnotation(annotation),annotation);
	};
	
	tag.prototype.onbranchsave = function (e,branch){
		e.stop();
		throw "not implemented";
	};
	
	tag.prototype.onbranchdiscard = function (e,branch){
		e.halt();
		branch.discard();
		return this;
	};
	
	tag.prototype.onbranchpublish = function (e,branch){
		e.stop();
		throw "not implemented";
		return this.uxa().open((_1(PublishDialog)).setData(branch).end());
	};
	
	tag.prototype.onbranchenter = function (e,branch){
		e.halt();
		return this.space().navigateTo(branch);
	};
	
	tag.prototype.onbranchdelete = async function (e,branch){
		e.halt();
		var ok = await e.uxa().confirm(("Are you sure you want to delete '" + (branch.title()) + "'?"));
		if (!ok) { return };
		
		if (this.space().branch() == branch) {
			this.space().navigateTo(this.space().trunk());
		};
		
		return await branch.model().update({archived_at: new Date()});
	};
	
	// TODO should no longer be called notes
	tag.prototype.onnotedel = async function (e,note){
		e.halt();
		
		var ok = await e.uxa().confirm(("Are you sure you want to delete '" + (note.title) + "'?"));
		if (!ok) { return };
		
		// set archived archived_at
		if (this.space().branch().model() == note) {
			this.space().navigateTo(this.space().trunk());
		};
		
		await note.destroy();
		return this;
	};
	
	tag.prototype.onnotediscard = async function (e,note){
		e.halt();
		let branch = await this.space().resolveBranchForModel(note);
		if (branch && note.isLocal()) {
			return branch.discard();
		};
	};
	
	tag.prototype.onnotesave = async function (e,note){
		e.halt();
		let branch = await this.space().resolveBranchForModel(note);
		return this.onbranchsave(e,branch);
	};
	
	tag.prototype.onbrowsertoggle = function (e){
		e.halt();
		if (this.space().simulator()) {
			this.space().simulator().setVisible(false);
		};
		this.space().browser().setVisible(!this.space().browser().visible());
		return this;
	};
	
	tag.prototype.onconsoletoggle = function (e){
		var v_;
		e.halt();
		return (this.space().console().setEnabled(v_ = !this.space().console().enabled()),v_);
	};
	
	tag.prototype.onbrowserrun = function (e){
		// log 'onbrowserrun',e
		e.halt();
		this.space().browser().run();
		return this;
	};
	
	tag.prototype.onnewfile = function (e){
		e.halt();
		return this.uxa().open((_1(NewFileDialog)).bindData(this,'space',[]).end());
	};
	
	tag.prototype.onplay = function (e){
		e.halt();
		var tl = this.space().timeline();
		if (tl.isPaused()) {
			tl.play();
			return this.trigger('spaceplay');
		};
	};
	
	tag.prototype.ontoggleplayback = function (e,timeline){
		e.halt();
		var tl = timeline || this.space().timeline();
		
		if (tl.isPlaying()) {
			tl.pause();
			return this.trigger('spacepaused');
		} else if (tl.isPaused()) {
			tl.play();
			// should happen when playing through other means as well?
			return this.trigger('spaceplay');
		};
	};
	
	tag.prototype.resume = function (){
		if (this.space().timeline().isPaused()) {
			this.space().timeline().play();
			this.trigger('spaceplay');
			this.dom().focus();
		};
		return this;
	};
	
	tag.prototype.pause = function (){
		if (this.space().timeline().isPlaying()) {
			this.space().timeline().pause();
			this.trigger('spacepaused');
		};
		return this;
	};
	
	tag.prototype.ondependencyadd = function (e){
		e.halt();
		this.log("ondependencyadd");
		return this.uxa().open((_1(DependencyAddDialog)).bindData(this,'space',[]).end());
	};
	
	tag.prototype.oncontrolsevent = function (e){
		if (e.event() instanceof Event) {
			return;
		};
		
		return e.redirect(this);
	};
	
	tag.prototype.onactionevent = function (e){
		// redirect the custom events to this view
		if (e.event() instanceof Event) { return };
		return e.redirect(this);
	};
	
	tag.prototype.ontoggledrawer = function (e){
		throw "not implemented";
		e.halt();
		return this._drawer.toggle();
	};
	
	tag.prototype.onimportslides = function (e){
		e.halt();
		var url = window.prompt("Link to presentation");
		if (url && url.match(/google\.com(.*)\/pub/)) {
			return this.space().slides().importFromGoogleSlides(url);
		} else {
			return this.uxa().flash("Link must be to a 'Publish to the web' link from Google Slides");
		};
	};
	
	tag.prototype.onreimportslides = function (e){
		e.halt();
		if (this.space().slides().url()) {
			return this.space().slides().importFromGoogleSlides(this.space().slides().url());
		};
	};
	
	tag.prototype.ongoto = function (e,target){
		e.halt();
		// log 'ongoto',target
		return this.space().navigateTo(target);
	};
	
	tag.prototype.onbeforeunload = function (e){
		if (this.space().isRecording() || this.space().isEditing()) {
			return e.cancel();
		};
	};
	
	tag.prototype.onmicenable = function (e){
		this.log('onmicenable',e);
		e.stop();
		// some sort of promise?
		return this.uxa().open((_1(UserMediaDialog)).bindData(this,'space',[]).end());
	};
	
	tag.prototype.showJoinDialog = function (){
		return this.uxa().open((_1(JoinDialog).flag('plane')).bindData(this,'space',[]).end());
	};
	
	tag.prototype.markLayout = function (value,prev,desc){
		this.flag(desc.name,!!value);
		return this._dirty |= DIRTY.LAYOUT;
	};
	
	tag.prototype.synced = function (){
		tag.prototype.__super__.synced.apply(this,arguments);
		if (this._dirty || !this._box || (this._marked.layout != this.space()._marked.layout)) {
			this.reflow();
		};
		return this;
	};
	
	tag.prototype.editor = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._editor || (this._editor = this._editor||_1(EditorView,this).flag('editor')).bindData(this.space(),'primaryEditor',[]).end();
	};
	
	tag.prototype.diffEditor = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._diffEditor || (this._diffEditor = this._diffEditor||_1(DiffEditorView,this).flag('diffEditor')).bindData(this.space(),'primaryEditor',[]).end();
	};
	
	// def drawer
	// 	@drawer || <SpaceDrawer@drawer[space.model].sp space=space>
	
	tag.prototype.titlebar = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._titlebar || (this._titlebar = this._titlebar||_1(TitlebarView,this).flag('titlebar').setEnabled(true)).bindData(this,'space',[]).end();
	};
	
	tag.prototype.sidebar = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._sidebar || (this._sidebar = this._sidebar||_1(SidebarView,this).flag('sidebar').flag('sp')).bindData(this.space(),'sidebar',[]).end();
	};
	
	tag.prototype.header = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._header || (this._header = this._header||_1(SpaceHeader,this).flag('header').flag('sp').flag('masthead').flag('light')).setData(this).end();
	};
	
	tag.prototype.toggleInspector = function (){
		this.space().inspector().open();
		this.requestFocus(this.space().inspector().view());
		return this;
	};
	
	tag.prototype.title = function (){
		return this.space().trunk().model().title();
	};
	
	tag.prototype.router = function (){
		return App.router();
	};
	
	tag.prototype.pointers = function (){
		return this.space().agents().map(function(_0) { return _0.pointer(); });
	};
	
	tag.prototype.render = function (){
		var $ = this.$, self = this, simulator_, t0, t1;
		if (true || self._animating) { return self };
		if (self.data().readyState() == 'init' || self.data().readyState() == 'disposing') { return self };
		
		let isReady = self.data().readyState() == 'complete';
		
		if (isReady) {
			self.flag('browser-on',self.data().browser().visible());
			self.flag('simulator-on',(simulator_ = self.data().simulator()) && simulator_.enabled  &&  simulator_.enabled());
			
			
			self.setShowInspector(self.data().inspector().shouldShow());
			// showNavDrawer = drawer.enabled
			self.setPlayState(self.space().timeline().playState());
			self.setScale(self.space().option('scale'));
			
			// setFlag('focus',"focus-{data.agent.focus and data.agent.focus.TYPE}")
			self.flag('play',self.data().timeline().isPlaying());
			self.setFlag('playstate',"ps-" + self.data().timeline().state());
			self.flag('is-annotating',self.branch().isAnnotating());
			self.flag('ws-unstable',self.branch().syncer().latency() > 1500);
			self.flag('can-edit',self.branch().canEdit());
			self.flag('unsaved',self.branch().isLocal());
			self.flag('mine',self.branch().isMine());
			// flag('live',!!space.trunk.host)
			
			self.setFlag('clientColor','agent-' + (self.space().me() ? self.space().me().color() : 'local'));
			
			self.setSidebarWidth(self.space().sidebar().width());
			self.checkActiveElement();
			
			// set space names
			for (let i = 0, items = iter$(self.space().agents()), len = items.length, agent; i < len; i++) {
				agent = items[i];
				self.cssvars().set(("agent-" + (agent.color()) + "-name"),'"' + (agent.name() || 'guest') + '"');
			};
		};
		
		if (self.space()._isNavigating) { return };
		//  .{space.branch.type}
		return self.$open(0).flag('resize').flag('dark').setFlag(-1,("trunk-" + (self.space().trunk().type()))).setFlag(-2,self.space().state()).setChildren([
			($[0] || _1(DragHandle,$,0,self).flag('only-pip')).end(),
			// unless space.manager
			// header.flag('sm',!isFullscreen).end
			(t0 = self._viewport = self._viewport||(t0=_1(Viewport,self)).flag('viewport').flag('sp')).setContent([
				(t1 = self._frame = self._frame||(t1=_1('div',t0)).flag('frame').flag('sp')).setContent([
					self.sidebar().end(),
					// drawer.end
					self._main = self._main||_1('div',t1).flag('main').flag('sp')
				// <.drawer-tabs>
				],1).end((
					self._main.setContent([
						self.titlebar().end(),
						self.editor().end(),
						self.diffEditor().end(),
						self.space().inspector().node().end()
					// <.inspector-toggler :tap.toggleInspector>
					// 	<span> "Console"
					// 	<.tool.toggler data-icon='mup'>
					],1)
				,true)),
				
				
				(isReady && self.space().simulator()) ? (
					self.space().simulator().node().end()
				) : void(0),
				
				self.space().browser().node().end(),
				// these should be register by the widgets themselves instead
				self.space().slides().node().end(),
				
				(function tagLoop($$) {
					for (let i = 0, items = iter$(self.space().agents()), len = items.length; i < len; i++) {
						$$.push(items[i].pointer().end());
					};return $$;
				})([]),
				
				($[1] || _1(ViewportOverlay,$,1,t0)).setData(self).end()
			],1).end(),
			
			self.branch().isAnnotating() ? (
				($[2] || _1(BrushupView,$,2,self).setEnabled(true)).bindData(self,'space',[]).end()
			) : void(0),
			(!self.option('inlineTrack')) ? (
				(self._controls = self._controls||_1(PlaybackOverlay,self).flag('controls')).bindData(self,'space',[]).end()
			) : void(0),
			self.option('demo') ? (
				($[3] || _1(Agents,$,3,self)).bindData(self,'space',[]).end()
			) : void(0)
		],1).synced();
	};
})
exports.SpaceView = SpaceView;


