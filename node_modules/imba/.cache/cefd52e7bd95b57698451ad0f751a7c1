function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _1 = Imba.createElement;
var express = require('express');
var bodyParser = require('body-parser');

var path = require('path');
var fs = require('fs');
var cp = require('child_process');

var request = require('request');

var passport = require('passport');
var pplocal = require('passport-local');
var ppgh = require('passport-github2');
var pmx = require('pmx');
var crypto = require('crypto');
var env = require('../env');

var app = exports.app = express();

// app.use(body-parser.urlencoded(extended: false, limit: '100mb'))
app.use('/static',express.static(env.absPath('public'))); //  path.resolve("{__dirname}/../../public")
app.use('/assets',express.static(env.absPath('assets')));
app.use('/cdn',express.static(env.get("FILES_DIR")));

var api$ = require("./api"), API = api$.API, WorkerAPI = api$.WorkerAPI;
var Packet = require('../scrimba/core/Packet').Packet;

require('./search');

var github = require('../services').github;
var ffmpeg = require('../services/ffmpeg');
var msgpack = require('msgpack-lite');
var headJs = fs.readFileSync(path.resolve(__dirname,'../site/head.js'),'utf-8');
var topicsCss = require('../services/topics-css');

Imba.extendTag('element', function(tag){
	tag.prototype.root = function (){
		
		return this._owner_ ? this._owner_.root() : this;
	};
	
	tag.prototype.api = function (){
		return this.root().api();
	};
	
	tag.prototype.log = function (){
		var api_;
		var $0 = arguments, i = $0.length;
		var params = new Array(i>0 ? i : 0);
		while(i>0) params[i-1] = $0[--i];
		return (api_ = this.api()).log.apply(api_,[].concat([this.constructor._name], [].slice.call(params)));
	};
});

var db = require('./db').db;

var SessionParser = require('./session').SessionParser;

var version = '(unknown)';
try {
	version = fs.readFileSync(("" + __dirname + "/../../VERSION"),{encoding: 'utf-8'}).trim();
} catch (err) {
	// nevermind
	console.log("could not find version");
};

env.set('VERSION',version);

/*
GitHub login
*/

var ghcallback = async function(accessToken,refreshToken,profile,done) {
	console.log("received accessToken!!!",accessToken,refreshToken);
	var api = await API.spawn();
	var user = await api.authWithGitHub(profile,accessToken,refreshToken);
	return process.nextTick(function() { return done(null,user); });
};

passport.use(new (ppgh.Strategy)({
	clientID: env.get('GITHUB_CLIENT_ID'),
	clientSecret: env.get('GITHUB_CLIENT_SECRET'),
	callbackURL: env.get('GITHUB_CALLBACK_URL'),
	userAgent: "beta.scrimba.com",
	scope: 'user:email'
},ghcallback));


passport.serializeUser(function(user,done) {
	return done(null,user ? user.id : null);
});

passport.deserializeUser(async function(uid,done) {
	if (!uid) { return done(null,uid) };
	// now fetching user on every request
	// console.log "deserializing user",obj
	// could just fetch from api db no?
	console.log("deserialize user",uid);
	var user = await API.db().users().summon(uid);
	// var user = await  db.table('users').where(id: uid).first
	// TODO make this the rich object
	return done(null,user ? user._data : false);
});

app.use(SessionParser);
app.use(passport.initialize());
app.use(passport.session());

// we always create an api object
app.use(async function(req,res,next) {
	req.session.ip = req.get('x-forwarded-for');
	req.session.ua = req.get('user-agent');
	
	let touched = req.session.touched;
	let workerRef = req.get('scrimba-worker-ref');
	
	// is it more than 1 hour since we extended session?
	if ((Date.now() - (touched || 0)) > (60 * 60 * 1000)) {
		req.session.touched = Date.now();
	};
	
	// this feels somewhat insecure - probably better if
	// workers request their own unique jwt or something
	if (workerRef && workerRef == env.get('WORKER_SECRET')) {
		req.api = new WorkerAPI(null,req);
	} else {
		req.api = await API.spawn(req.user,req);
	};
	
	return next();
});


var githubBodyVerify = function(req,res,buf) {
	var hash = crypto.createHmac('sha1',env.get('GITHUB_APP_WEBHOOK_SECRET')).update(buf).digest('hex');
	return req.bodySignature = "sha1=" + hash;
};

// webhooks
app.post('/api/webhooks/github',bodyParser.json({limit: '2mb',verify: githubBodyVerify}),async function(req,res) {
	// var hash = crypto.createHmac('sha1',env.get('GITHUB_APP_WEBHOOK_SECRET')).update().digest('hex')
	var signature = req.headers['x-hub-signature'];
	
	if (signature != req.bodySignature) {
		console.log("invalid request from server",req.body,signature,req.bodySignature);
		return res.sendStatus(403);
	};
	
	var event = req.headers['x-github-event'];
	console.log("valid webhook request from github",event,req.headers,req.body);
	await github.handleWebhook(event,req.body);
	return res.sendStatus(200);
});

app.post('/api/webhooks/github/marketplace',bodyParser.json({limit: '2mb',verify: githubBodyVerify}),async function(req,res) {
	// var hash = crypto.createHmac('sha1',env.get('GITHUB_APP_WEBHOOK_SECRET')).update().digest('hex')
	var signature = req.headers['x-hub-signature'];
	
	if (signature != req.bodySignature) {
		console.log("invalid request from server",req.body,signature,req.bodySignature);
		return res.sendStatus(403);
	};
	
	var event = req.headers['x-github-event'];
	console.log("valid webhook request from github",event,req.headers,req.body);
	await github.handleWebhook(event,req.body);
	return res.sendStatus(200);
});

app.get('/api/github/integrate',async function(req,res) {
	let ref = req.query.ref;
	console.log("reference",ref);
	var link = await github.getInstallLinkForRef(ref);
	link = "https://github.com/apps/scrimba/installations/new";
	// get the install 
	// res.json link
	return res.redirect(link);
});

app.post('/api/workers/process',async function(req,res) {
	var resp = await req.api.scrimProcessNext();
	return res.json({status: resp});
});

var runner = require("../services/run-static").app;

app.use(function(req,res,next) {
	if (req.hostname == env.get('RUN_HOSTNAME')) {
		return runner(req,res);
	} else {
		return next();
	};
});

app.use(bodyParser.json({limit: '2mb'}));

app.get('/login',function(req,res) {
	req.session.ghRedirect = req.query.from;
	let url = '/auth/github';
	if (req.query.scope) {
		url += "/" + req.query.scope;
		req.session.ghScope = req.query.scope;
	};
	
	return res.redirect(url);
	// res.redirect('/auth/github')
});

app.get('/auth',function(req,res) {
	req.session.ghRedirect = '/auth/github/seamless';
	let url = '/auth/github';
	if (req.query.scope) {
		url += "/" + req.query.scope;
	};
	return res.redirect(url);
});

app.get('/auth/github/seamless',function(req,res) {
	// include details?
	var handler = function() {
		try {
			window.opener.SCRIMBA_API.reloadUser();
			return window.close();
		} catch (err) {
			var timeout = setTimeout(function() { return window.location = "/"; },2000);
			window.onmessage = function() {
				clearTimeout(timeout);
				return window.close();
			};
			return window.opener.postMessage('reloadUser','*');
		};
	};
	
	var code = (_1('script')).setText("(" + (handler.toString()) + ")()");
	return res.send(code.toString());
});

app.get('/auth/github',passport.authenticate('github',{scope: ['user:email']}));
app.get('/auth/github/minimal',passport.authenticate('github',{scope: ['user:email']}));
app.get('/auth/github/public',passport.authenticate('github',{scope: ['user:email','public_repo','read:org']}));
app.get('/auth/github/private',passport.authenticate('github',{scope: ['user:email','public_repo','repo','read:org']}));

var ghauth = passport.authenticate('github',{failureRedirect: '/'});

app.get('/auth/github-team/callback',ghauth,function(req,res) {
	var code = req.query.code;
	var ghRedirect = req.session.ghRedirect;
	console.log("github-team callbacpk",req.params,req.query,code);
	return res.send("ok!");
});

app.get('/auth/github/callback/v2',ghauth,function(req,res) {
	console.log("OTHER CALLBACK");
	var code = req.query.code;
	var ghRedirect = req.session.ghRedirect;
	
	console.log("returned from github",req.params,req.query,code,req.headers);
	
	if (ghRedirect) {
		req.session.ghRedirect = "";
		return res.redirect(ghRedirect);
	} else {
		return res.redirect('/');
	};
});

app.get('/auth/github/callback',ghauth,function(req,res) {
	var code = req.query.code;
	var ghRedirect = req.session.ghRedirect;
	
	console.log("returned from github",req.params,req.query,code,req.headers);
	
	if (ghRedirect) {
		req.session.ghRedirect = "";
		return res.redirect(ghRedirect);
	} else {
		return res.redirect('/');
	};
});

app.get('/favicon.ico',function(req,res) { return res.send(""); });

app.get('/logout',function(req,res) {
	// req:session:ghRedirect = req:query:from
	req.logout();
	console.log("server /logout",req.xhr,req.query.xhr);
	if (req.xhr || req.query.xhr) {
		return res.send('0');
	} else {
		return res.redirect(req.query.from || '/');
	};
});

app.get('/cli.json',function(req,res) {
	return res.json(API.manifest());
});

app.post('/files/:id/append',bodyParser.urlencoded({extended: true,limit: '100mb'}),async function(req,res) {
	
	var id = req.params.id.replace(/\//g,'');
	var file = await req.api.fetch(id);
	var entity = req.api.db().entities().get(id);
	
	var offset = req.query.offset;
	
	if (entity && entity.isInited()) {
		await req.api.guardAllowed('write',id);
		id = id + '.scrim';
	};
	
	var dir = env.get('FILES_DIR');
	var dest = path.resolve(dir + ("/" + id));
	
	console.log("dest is",dest);
	
	// return a new token for writing the next part of file?
	
	return fs.stat(dest,function(err,stat) {
		if (stat && offset == 0) {
			console.log("remove file");
			fs.unlinkSync(dest);
			stat = null;
		};
		// console.log "file stats",err,stat
		if ((stat && stat.size != offset) || (!stat && offset > 0)) {
			return res.status(400);
		};
		
		var enc = (id.indexOf('.scrim') >= 0) ? 'utf8' : 'binary';
		var writer = fs.createWriteStream(dest,{defaultEncoding: enc,flags: 'a'});
		var pipe = req.pipe(writer);
		res.type('json');
		
		return writer.on('finish',function() {
			return res.json({status: 0});
		});
	});
});

app.get('/files/:ref.scrim.json',async function(req,res) {
	let file = await req.api.fetch(req.params.ref + '.scrim');
	var src = path.resolve(env.get('FILES_DIR'),file.id);
	// console.log "found file",src
	let msg = fs.readFileSync(src,'binary');
	var json = [];
	var msgpack = require("msgpack-lite");
	var readStream = fs.createReadStream(src);
	var decodeStream = msgpack.createDecodeStream();
	return readStream.pipe(decodeStream).on("data",function(_0) { return json.push(_0); }).on("end",function() { return res.json(json); });
	// return res.json status: 0
});

app.post('/upload/:id',bodyParser.urlencoded({extended: true,limit: '100mb'}),async function(req,res) {
	
	var id = req.params.id.replace(/\//g,'');
	var file = await req.api.fetch(id);
	console.log("post /upload",id,file);
	
	var dir = env.get('FILES_DIR');
	var dest = path.resolve(dir + ("/" + id));
	
	console.log("dest is",dest);
	
	// var writer = Promise.new do |resolve, reject|
	var writer = fs.createWriteStream(dest,{defaultEncoding: 'binary',flags: 'w'});
	var pipe = req.pipe(writer);
	
	res.type('json');
	
	return writer.on('finish',async function() {
		var src = path.resolve(env.get('FILES_DIR') + '/' + id);
		var updates = {state: 'uploaded'};
		await ffmpeg.finalize(file,updates);
		// make sure we mux the webm-file immediately
		return fs.stat(src,async function(err,stat) {
			await file.update({state: 'uploaded',size: stat.size});
			// if file:size != stat:size
			return res.send(file);
		});
	});
});

app.get('/cdn/:id.scrim',async function(req,res) {
	try {
		let eid = req.params.id;
		var src = path.resolve(env.get('FILES_DIR') + '/' + eid + '.scrim');
		await req.api.guardAllowed('read',eid);
		return fs.existsSync(src) ? res.sendFile(src) : res.sendStatus(404);
	} catch (e) {
		console.log("error",e);
		return res.sendStatus(404);
	};
});


app.get('/cdn/:id.:version.stream',function(req,res) {
	console.log("trying to fetch stream",req.params.id);
	var ref = req.params.id + '.' + req.params.version + '.stream';
	// var dst = path.resolve(env.get("FILES_DIR"),ref)
	var x = request('https://scrimba.com/cdn/' + ref);
	// .pipe(fs.createWriteStream(dst))
	req.pipe(x);
	return x.pipe(res);
	
	// var dest = await ffmpeg.webm2m4a(id)
	// res.type('m4a')
	// res.sendFile(dest)
});

app.get('/cdn/:id.webm.m4a',async function(req,res) {
	console.log("trying to access",req.params.id);
	var id = req.params.id + '.webm';
	var dest = await ffmpeg.webm2m4a(id);
	res.type('m4a');
	return res.sendFile(dest);
});

app.get('/cdn/:id.webm.mp3',async function(req,res) {
	console.log("trying to access",req.params.id);
	var id = req.params.id + '.webm';
	// var file = await req:api.fetch(id)
	console.log("getting webmfile",id);
	var src = ffmpeg.fullpath(id);
	var dest = await ffmpeg.encodeMP3(src);
	res.type('mp3');
	return res.sendFile(dest);
});


app.get('/cdn/:id.:v.cover.svg',async function(req,res) {
	console.log("trying to access",req.params.id);
	res.type('svg');
	
	var item = await req.api.db().fetch(req.params.id);
	
	if (item && item.coverart) {
		return res.send(item.coverart);
	} else {
		return res.send("");
	};
});

app.get('/cdn/:id.webm.ogg',async function(req,res) {
	var id = req.params.id + '.webm';
	var dest = await ffmpeg.webm2ogg(id);
	res.type('ogg');
	return res.sendFile(dest);
});

app.get('/cast/:spaceid.preview',function(req,res) {
	var html = '<!DOCTYPE html><html lang="en"><head></head><body></body></html>';
	res.type('html');
	return res.send(html);
});

if (env.get('NODE_ENV') == 'development') {
	app.get('/impersonate/:id',async function(req,res,next) {
		var user = await req.api.db().fetch(req.params.id);
		console.log("impersonating user",user);
		if (!user) {
			return next();
		};
		
		return req.login(user,function(err) {
			if (err) { return next(err) };
			return res.redirect('/');
		});
	});
};

app.get('/api/oembed',async function(req,res) {
	res.header("Access-Control-Allow-Origin","*");
	res.header("Access-Control-Allow-Headers","Origin, X-Requested-With, Content-Type, Accept");
	
	var format = (req.query.format || "json");
	if (format != "json") {
		return res.status(501).send("Only format=json is supported");
	};
	
	var url = String(req.query.url);
	var m = url.match(/\/casts\/([^\/]+)($|\?)/);
	if (!m) {
		return res.status(404).send(("" + url + " is not embeddable"));
	};
	
	var castId = m[1];
	var cast = await req.api.db().fetch(castId);
	if (!cast) {
		return res.status(404).send(("No cast with id: " + castId));
	};
	
	console.log("cast!!",cast);
	
	var owner = await cast.owner().fetch();
	
	var height = Number(req.query.height);
	var width = Number(req.query.width);
	var ratio = 16 / 9;
	
	if (!width && !height) {
		width = 800;
	};
	
	if (!width) {
		width = height * ratio;
	} else if (!height) {
		height = width / ratio;
	};
	
	var embedUrl = ("https://scrimba.com/cast/" + castId + ".embed");
	var frame = (_1('iframe').css('border',0)).setSrc(embedUrl).end();
	frame.setAttribute('width',width);
	frame.setAttribute('height',height);
	
	return res.send(
		{type: 'rich',
		version: '1.0',
		cache_age: 60 * 60 * 24,
		title: cast.title,
		author_name: owner.name || owner.username,
		provider_name: 'Scrimba',
		provider_url: 'https://scrimba.com/',
		width: width,
		height: height,
		html: frame.toString()}
	);
});


// Zipper
var archiveSpace = require("../services/space-archiver").archiveSpace;

app.get('/casts/:id.zip',function(req,res,next) {
	var castId = req.params.id;
	var api = req.api;
	var space = api.get(castId);
	var idx = Number(req.query.index || -1);
	if (space.can(api.user(),'read')) {
		res.type('zip');
		return archiveSpace(api,res,space,idx).then(null,next);
	} else {
		return next();
	};
});

// Blobs

app.post('/blobs',bodyParser.raw({limit: '6mb'}),async function(req,res) {
	if (!(req.body instanceof Buffer)) {
		res.status(400).send("Unable to upload file (wrong Content-Type?)\n");
		return;
	};
	
	var shasum = crypto.createHash('sha1');
	shasum.update(req.body);
	var id = ("sha1:" + shasum.digest('hex'));
	
	var exists = await db.table('blobs').where({id: id}).first('id');
	
	await (!exists && db.raw('INSERT INTO blobs (id, content, uid) VALUES (?, ?, ?) ON CONFLICT DO NOTHING',[id,req.body,req.api.uid()]));
	
	return res.send({type: 'blob',id: id});
});


app.get('/blobs/:id',async function(req,res,next) {
	var ary;
	var ary = iter$(req.params.id.split("."));var id = ary[0],ext = ary[1];
	var row = await db.table('blobs').where({id: id}).first('content');
	
	console.log("trying to return",id,ext);
	
	if (!row) {
		console.log("could not find image!?!?",id);
		return next();
	};
	
	res.type(ext || 'binary');
	return res.send(row.content);
});


app.get('/topics.css',async function(req,res) {
	// TODO should be cached
	res.type('css');
	
	var topics = await req.api.db().topics().where('v','>',0);
	var css = topicsCss.generate(topics);
	return res.send(css);
});


app.get(/\.(\w)+$/,function(req,res,next) {
	console.log("try to access non-renderable url",req.originalUrl);
	if (req.originalUrl.match(/\.embed/)) {
		return next();
	};
	
	return res.status(204).send("");
});

// TODO hide behind development/test
app.get('/impersonate/:id',async function(req,res,next) {
	var user = await req.api.db().fetch(req.params.id);
	if (!user) {
		return next();
	};
	
	return req.login(user,function(err) {
		if (err) { return next(err) };
		return req.session.save(function() {
			if (req.query.redir) {
				return res.redirect('/');
			} else {
				return res.json({status: 0});
			};
		});
	});
});

app.get('/casts/:id',async function(req,res,next) {
	var castId = req.params.id;
	var key = req.query.backdoor;
	var backdoorKey = env.get("BACKDOOR_KEY");
	if (!backdoorKey || key != backdoorKey) {
		return next();
	};
	
	var user = await db.table('spaces').where('spaces.id',castId).join('users','spaces.uid','users.id').select('users.*').first();
	
	if (!user) {
		return next();
	};
	
	return req.login(user,function(err) {
		if (err) { return next(err) };
		return res.redirect('/casts/' + castId);
	});
});


app.get('/live',async function(req,res,next) {
	var live = await db.table('entities').whereNotNull('pid').orderBy('crets','desc').first();
	console.log("found live scrim?!?",live.id);
	return res.redirect(("/scrim/" + (live.id)));
});

app.get('/live/:pid',async function(req,res,next) {
	var live = await db.table('entities').whereNotNull('pid').where({pid: req.params.pid}).orderBy('crets','desc').first();
	console.log("found live scrim?!?",live.id);
	return res.redirect(("/s/" + live.id.slice(2)));
});

Imba.extendTag('link', function(tag){
	tag.prototype.sizes = function(v){ return this.getAttribute('sizes'); }
	tag.prototype.setSizes = function(v){ this.setAttribute('sizes',v); return this; };
	tag.prototype.color = function(v){ return this.getAttribute('color'); }
	tag.prototype.setColor = function(v){ this.setAttribute('color',v); return this; };
});

var Site = Imba.defineTag('Site', 'html', function(tag){
	
	tag.prototype.api = function(v){ return this._api; }
	tag.prototype.setApi = function(v){ this._api = v; return this; };
	tag.prototype.page = function(v){ return this._page; }
	tag.prototype.setPage = function(v){ this._page = v; return this; }; // no?
	tag.prototype.app = function(v){ return this._app; }
	tag.prototype.setApp = function(v){ this._app = v; return this; };
	
	tag.prototype.render = function (){
		var $ = this.$;
		var ga = (this.api().user() ? {userId: this.api().uid()} : {});
		
		return this.$open(0).setChildren($.$ = $.$ || [
			this._head = this._head||_1('head',this).flag('head'),
			_1('body',$,32,this).setContent([
				_1('script',$,33,32).setText("$$API_CACHE$$"),
				_1('script',$,34,32),
				_1('script',$,35,32).setDefer(true)
			],2)
		],2).synced((
			this._head.setContent([
				($[0] || _1('title',$,0,this._head)).setContent(this.page() ? this.page().title() : "Scrimba.com",3),
				($[1] || _1('meta',$,1,this._head).setCharset("utf-8")).end(),
				($[2] || _1('meta',$,2,this._head).setName("viewport").setContent("width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1")).end(),
				($[3] || _1('meta',$,3,this._head).setName("apple-mobile-web-app-capable").setContent("yes")).end(),
				($[4] || _1('meta',$,4,this._head).setName("apple-mobile-web-app-title").setContent("Scrimba")).end(),
				($[5] || _1('meta',$,5,this._head).setName("apple-mobile-web-app-status-bar-style").setContent("black")).end(),
				
				this.page() ? Imba.static([
					($[6] || _1('meta',$,6,this._head).setName("description")).setContent(this.page().desc()).end(),
					($[7] || _1('meta',$,7,this._head).setProperty("og:title")).setContent(this.page().title()).end(),
					($[8] || _1('meta',$,8,this._head).setProperty("og:description")).setContent(this.page().desc()).end(),
					($[9] || _1('meta',$,9,this._head).setProperty("og:site_name").setContent("Scrimba")).end(),
					($[10] || _1('meta',$,10,this._head).setName("twitter:card").setContent("summary")).end(),
					($[11] || _1('meta',$,11,this._head).setName("twitter:title")).setContent(this.page().title()).end(),
					($[12] || _1('meta',$,12,this._head).setName("twitter:description")).setContent(this.page().desc()).end(),
					($[13] || _1('meta',$,13,this._head).setName("twitter:site").setContent("@scrimba_com")).end(),
					
					this.page().image() ? Imba.static([
						($[14] || _1('meta',$,14,this._head).setProperty("og:image")).setContent(this.page().image()).end(),
						($[15] || _1('meta',$,15,this._head).setProperty("twitter:image")).setContent(this.page().image()).end()
					],2,1) : void(0)
				],1,2) : (
					($[16] || _1('meta',$,16,this._head).setName("description").setContent("Scrimba is a community of developers sharing knowledge through interactive coding screencasts.")).end()
				),
				
				// favicon
				($[17] || _1('link',$,17,this._head).setRel("apple-touch-icon").setSizes("180x180").setHref("/static/cached/favico1/apple-touch-icon.png")).end(),
				($[18] || _1('link',$,18,this._head).setRel("icon").setType("image/png").setSizes("32x32").setHref("/static/cached/favico1/favicon-32x32.png")).end(),
				($[19] || _1('link',$,19,this._head).setRel("icon").setType("image/png").setSizes("16x16").setHref("/static/cached/favico1/favicon-16x16.png")).end(),
				($[20] || _1('link',$,20,this._head).setRel("manifest").setHref("/static/cached/favico1/manifest.json")).end(),
				($[21] || _1('link',$,21,this._head).setRel("mask-icon").setHref("/static/cached/favico1/safari-pinned-tab.svg").setColor("#75aaff")).end(),
				($[22] || _1('meta',$,22,this._head).setName("theme-color").setContent("#ffffff")).end(),
				
				($[23] || _1('meta',$,23,this._head).setName("keywords").setContent("coding screencast tutorial react imba javascript css js")).end(),
				($[24] || _1('script',$,24,this._head)).setText('VERSION = ' + JSON.stringify(env.get('VERSION'))),
				
				// if (var opbeatApp = env.get('OPBEAT_CLIENT_APP_ID')) and (var opbeatOrg = env.get('OPBEAT_ORG_ID'))
				// 	<script>
				// 		"window.OpbeatConfig = {JSON.stringify({ orgId: opbeatOrg, appId: opbeatApp })}"
				
				($[25] || _1('link',$,25,this._head).setId('clientcss').setRel("stylesheet").setMedia("screen")).setHref(this.api().assetsPath('client.css')).end(),
				($[26] || _1('link',$,26,this._head).setId('clientcss').setRel("stylesheet").setHref("/topics.css").setMedia("screen")).end(),
				($[27] || _1('link',$,27,this._head).setRel("stylesheet")).setHref(("" + (this.api().monacoPath()) + "/monaco.editor.css")).end(),
				($[28] || _1('script',$,28,this._head)).setText("var vw = window.innerWidth;\nif(vw % 2)\{ document.documentElement.classList.add('odd-width'); \}"),
				
				($[29] || _1('script',$,29,this._head)).setContent(headJs,3),
				
				($[30] || _1('script',$,30,this._head)).setText("(function(i,s,o,g,r,a,m)\{i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()\{\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\nga('create', 'UA-89256059-' + (window.top == window ? (location.hostname.indexOf('.dev') >= 0 ? 3 : 1) : 2), 'auto', " + JSON.stringify(ga) + ");\nga('set', 'anonymizeIp', true);\nga('send', 'pageview')"),
				($[31] || _1('style',$,31,this._head).setId('userstyles'))
			],1),
			$[34].setSrc(this.api().assetsPath('client.js')).end(),
			$[35].setSrc(("" + (this.api().monacoPath()) + "/monaco.editor.js")).end()
		,true));
	};
	
	
	tag.prototype.respondTo = function (req,result,next){
		let url = req.originalUrl.replace(/\b(\/$)/,'');
		let t = Date.now();
		this.render();
		
		// router.onReady do
		// 	# if @app
		// 	# 	console.log 'router ready',@app.page and @app.page.title
		// 	# 	page = @app.page
		// 	# 	render
		
		let apiCache = this.api().toScriptContent("API_CACHE");
		console.log(("Site.respondTo " + url),Date.now() - t + 'ms',Math.round(apiCache.length / 1000) + 'kb api');
		return result.send(this.toString().replace("$$API_CACHE$$",apiCache));
	};
});

app.get('/s/:ref',function(req,res,next) {
	var session_;
	var ref = 'es' + req.params.ref;
	var secret = ref.split("-");
	if (req.query.secret) {
		(session_ = req.session).secrets || (session_.secrets = {});
		req.session.secrets[ref] = req.query.secret;
		// make sure it is saved?
	};
	return next();
});

app.get(/.*/,async function(req,res,next) {
	// make sure stores are loaded
	console.log("started request",Object.keys(req.session),req.sessionID,req.session.secrets);
	await req.api.db().storesDidLoad();
	await req.api.find('me');
	
	console.log(("--- handle request -- " + (req.originalUrl)));
	// var router = Router.new(url: req:path) 
	var site = (_1(Site)).setApi(req.api).end();
	return site.respondTo(req,res,next);
});

app.post('/rpc/:action',bodyParser.urlencoded({extended: true,limit: '100mb'}),function(req,res,next) {
	var t = Date.now();
	var action = req.params.action;
	
	var o = req.body.options;
	var fmt = req.header('Accept');
	console.log(("/rpc/" + action),req.body.args[0],fmt);
	if (fmt == 'application/msgpack') {
		o.type = 'msgpack';
	};
	
	var p = req.api.rpc(action,req.body.args,o);
	
	
	var onerror = function(err) {
		res.status(400);
		res.type('json');
		console.log("error from api",err);
		// report to opbeat / similar
		return res.send({error: {}});
		// next(err)
	};
	
	return p.then(function(result) {
		res.setHeader('Scrimba-Client-Version',req.api.clientVersion());
		
		if ((typeof result=='number'||result instanceof Number) && result > 100 && result < 600) {
			return res.sendStatus(result);
		};
		
		if (o.type == 'arraybuffer') {
			if (!result) {
				result = msgpack.encode(0);
			};
			res.setHeader('Content-Type','application/octet-stream');
			res.setHeader('Content-Length',result.length);
			res.send(new Buffer(result,'binary'));
		} else if (fmt == 'application/msgpack') {
			// let packed = Packet.serialize(result, scope: req:api)
			res.setHeader('Content-Type','application/msgpack');
			res.setHeader('Content-Length',result.length);
			res.send(new Buffer(result,'binary'));
		} else {
			res.type('json');
			res.send({response: result});
		};
		return console.log("returned from rpc action",Date.now() - t);
	},onerror);
});

// if opbeat
// 	app.use(opbeat:middleware.express)

app.use(pmx.expressErrorHandler());
