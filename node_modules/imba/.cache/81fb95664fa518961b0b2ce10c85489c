function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');
var Store = require('./Store').Store;

var Action = require('../models/Action').Action;
var Topic = require('../models/Topic').Topic;
var File = require('../models/File').File;
var User = require('../models/User').User;
var Peer = require('../models/Peer').Peer;
var Entity = require('../models/Entity').Entity;
var Link = require('../models/Link').Link;
// import Invitation from '../models/Invitation'

var LocalStore = require('../util/StoreWrapper').LocalStore;
var protocol$ = require('../scrimba/protocol'), MSG = protocol$.MSG, SCON = protocol$.SCON, SPIV = protocol$.SPIV;

// FIXME We should move all app-specific stuff (models, db-connection etc)
// out from this, and structure store/* as if it was a fully separate project/module

if (true) {
	var serverDB = require("../server/db");
};

function FakePromise(){
	this._value = undefined;
	this._resolved = false;
	this._listeners = [];
	this;
};

FakePromise.prototype.then = function (cb){
	if (this._resolved) {
		cb(this._value);
	} else {
		this._listeners.push(cb);
	};
	return this;
};

FakePromise.prototype.resolve = function (value){
	this._resolved = true;
	this._value = value;
	for (let i = 0, items = iter$(this._listeners), len = items.length; i < len; i++) {
		items[i](this._value);
	};
	this._listeners = [];
	return this;
};

function DB(api){
	var self = this;
	self._api = api;
	self._ts = Date.now();
	self._dbname = 'scrimba2';
	
	self._scope = null;
	self._stores = [];
	self._prefixes = {};
	self._loadQueue = [];
	self._kvs = {};
	
	if (false) {} else if (true) {
		self._kvs2 = new LocalStore('db:' + self._dbname);
	};
	
	self._topics = new Store(self,'topics',Topic,{ns: '#'});
	self._users = new Store(self,'users',User,{ns: 'u',preload: false});
	self._actions = new Store(self,'actions',Action,{ns: 'a'});
	self._files = new Store(self,'files',File,{ns: 'f',preload: false});
	self._peers = new Store(self,'peers',Peer,{ns: 'P',preload: false});
	self._entities = new Store(self,'entities',Entity,{ns: 'e',preload: false});
	self._links = new Store(self,'links',Link,{ns: 'l',preload: false});
	// @invitations = Store.new(self,'invitations',Invitation, ns: 'i', preload: false)
	
	self._autosyncer = function() { return self.autosync(); };
	self._loadPromise = new FakePromise();
	self._readyPromise = new FakePromise();
	self._sync;
	
	self._local = true;
	
	if (true) {
		self.open();
	};
	self;
};

exports.DB = DB; // export class 
DB.prototype.api = function(v){ return this._api; }
DB.prototype.setApi = function(v){ this._api = v; return this; };
DB.prototype.stores = function(v){ return this._stores; }
DB.prototype.setStores = function(v){ this._stores = v; return this; };
DB.prototype.dexie = function(v){ return this._dexie; }
DB.prototype.setDexie = function(v){ this._dexie = v; return this; };
DB.prototype.scope = function(v){ return this._scope; }
DB.prototype.setScope = function(v){ this._scope = v; return this; };
DB.prototype.kvs = function(v){ return this._kvs; }
DB.prototype.setKvs = function(v){ this._kvs = v; return this; };

DB.prototype.touch = function (){
	if (false) {};
	this.time();
	return this;
};

DB.instance = function (){
	return this._instance || (this._instance = new this());
};

DB.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
DB.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
DB.prototype.once = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.once.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

if (true) {
	DB.prototype.open = function (){
		var self = this;
		return serverDB.pgconnect(function(err,client) {
			// should send first immediately, but then start to delay
			// and batch if there are tons of changes over a very short period
			// leaky bucket?
			var queue = self._pusher = {
				count: 0,
				timeout: null,
				syncer: self.sync.bind(self),
				ids: [],
				models: []
			};
			
			client.on('notification',async function(msg) {
				var data = JSON.parse(msg.payload);
				var id = data.id;
				
				clearTimeout(queue.timeout);
				queue.timeout = setTimeout(queue.syncer,10000);
				var store = self.storeForId(id);
				if (store) {
					queue.ids.push(id);
					var item = await store.fetch(id);
					queue.models.push(item);
					if (len$(queue.ids) == len$(queue.models)) {
						return self.broadcast();
					};
				};
			});
			
			return client.query("LISTEN update");
		});
	};
	
	DB.prototype.broadcast = function (){
		// should add some timeout for this as well?
		var ids = this._pusher.ids;
		var items = this._pusher.models;
		if (len$(items)) {
			this._pusher.models = [];
			this._pusher.ids = [];
			this._pusher.flushed = Date.now();
			return this.emit('change',items);
		};
	};
	
	DB.prototype.autofetch = async function (){
		return await Promise.all(this.stores().map(function(store) { return store.autofetch(); }));
	};
};

if (false) {};

DB.prototype.autoload = function (item){
	if (this._loadQueue.indexOf(item) < 0) { this._loadQueue.push(item) };
	if (false) {};
	return this;
};

DB.prototype.autosync = function (){
	if (!len$(this._loadQueue)) { return };
	var ids = this._loadQueue.filter(function(item) { return item.v == -3; }).map(function(item) { return item.id; });
	// console.log "autosync",@loadQueue.len,ids
	// what if there are too many?
	this._loadQueue = [];
	this._api.rpc('load',[ids],{models: true});
	
	return this;
};

if (true) {
	DB.prototype.pendingResourceIds = function (){
		return this._loadQueue.filter(function(item) { return item.v == -3; }).map(function(item) { return item.id; });
	};
	
	DB.prototype.autosync = function (){
		var self = this;
		var ids = self._loadQueue.filter(function(item) { return item.v == -3; }).map(function(item) { return item.id; });
		
		if (len$(ids) == 0 && !self._autosyncing) {
			return Promise.resolve(self);
		};
		
		return self._autosyncing || (self._autosyncing = new Promise(async function(resolve,reject) {
			var _name_;
			console.log("started autosyncing",ids);
			self._loadQueue = [];
			// order by table
			let tables = {};
			for (let i = 0, items = iter$(ids), len = items.length, id, store; i < len; i++) {
				id = items[i];
				if (store = self.storeForId(id)) {
					tables[_name_ = store._name] || (tables[_name_] = []);
					tables[store._name].push(id);
				};
			};
			
			let promises = [];
			for (let oids, i = 0, keys = Object.keys(tables), l = keys.length, ns; i < l; i++){
				ns = keys[i];oids = tables[ns];promises.push(self._stores[ns].batchLoad(oids));
			};
			
			await Promise.all(promises);
			
			console.log("autosynced");
			
			if (len$(self._loadQueue)) {
				console.log("more to load after batchLoad");
				self._autosyncing = null;
				return resolve(self.autosync());
			} else {
				self._autosyncing = null;
				return resolve(self);
			};
			
			// now see if there are new things to autoload after this
			// resolve()
		}));
	};
};

DB.prototype.scoped = function (scope,blk){
	var prev = this._scope;
	this._scope = scope;
	var res = blk();
	this._scope = prev;
	return res;
};

DB.prototype.cacheKey = function (){
	return false ? true : "sdb";
};

DB.prototype.casts = function (){
	return this._spaces;
};

DB.prototype.knex = function (){
	return serverDB.db;
};

DB.prototype.storeForId = function (id){
	return this._prefixes[id[0]];
};

DB.prototype.storeDidLoad = function (store){
	if (len$(this.stores().filter(function(store) { return !store.isReady(); })) == 0) {
		this._readyPromise.resolve(this);
		return this;
	};
};

DB.prototype.storesDidLoad = function (){
	return this._readyPromise;
};

DB.prototype.get = function (id){
	if (!id) { return };
	var store = this.storeForId(id);
	return store ? store.get(id) : null;
};

DB.prototype.summon = function (id){
	if (!id) { return };
	var store = this.storeForId(id);
	return store ? store.summon(id) : null;
};

DB.prototype.has = function (id){
	if (!id) { return };
	var store = this.storeForId(id);
	return store ? store.has(id) : null;
};

DB.prototype.read = function (item,force){
	if(force === undefined) force = false;
	if (!(item && item.id)) { return };
	var store = this.storeForId(item.id);
	return store ? store.read(item,force) : null;
};

DB.prototype.put = function (item){
	return this.storeForId(item.id).put(item);
};

DB.prototype.fetch = function (id){
	if (!id) { return };
	var store = this.storeForId(id);
	return store ? store.fetch(id) : null;
};

DB.prototype.cache = function (){
	return this._cache || (this._cache = {});
};

DB.prototype.cacheGet = function (key){
	// console.log "cacheGet",key
	return Promise.resolve(this.cache()[key]);
	
	if (!this._dexie || this._inmemory) {
		return Promise.resolve(null);
	};
	
	return this._dexie.cache.get(key);
};

DB.prototype.cacheSet = function (key,val){
	// console.log "cacheSet",key
	this.cache()[key] = val;
	return Promise.resolve(true);
	
	if (!this._dexie || this._inmemory) {
		return Promise.resolve(null);
	};
	
	val.id = key;
	return this._dexie.cache.put(val);
};

DB.prototype.deserialize = function (data,force){
	var self = this;
	if(force === undefined) force = true;
	if (data instanceof Array) {
		return data.map(function(item) { return ((typeof item=='string'||item instanceof String)) ? self.get(item) : self.read(item,force); });
	} else if (data instanceof Object) {
		if (data.id) {
			data = self.read(data,force);
		} else {
			let value = data;
			data = {};
			for (let v, i = 0, keys = Object.keys(value), l = keys.length, k; i < l; i++){
				k = keys[i];v = value[k];data[k] = self.deserialize(v,force);
			};
		};
	} else if ((typeof data=='string'||data instanceof String)) {
		data = self.get(data);
	};
	return data;
};

DB.prototype.preload = function (items){
	for (let i = 0, ary = iter$(items), len = ary.length; i < len; i++) {
		// we simply read these items into the db-memory
		this.read(ary[i]);
	};
	return this;
};

DB.prototype.drop = function (){
	return this;
};

DB.prototype.migrate = function (){
	return this;
};

DB.prototype.persist = function (){
	for (let i = 0, items = iter$(this.stores()), len = items.length; i < len; i++) {
		this.stores().persist();
	};
	return this;
};

DB.prototype.sync = function (sel){
	var versions = {};
	var reqs = [];
	if (sel instanceof Object) {
		for (let v, i = 0, keys = Object.keys(sel), l = keys.length, k, store; i < l; i++){
			k = keys[i];v = sel[k];if (store = this._stores[k]) {
				reqs.push([k,v,store.lastVersion(v)]);
			};
		};
	} else if (sel instanceof Array) {
		reqs = sel;
	} else if ((typeof sel=='string'||sel instanceof String)) {
		this.stores().map(function(tbl) {
			return versions[tbl.name()] = tbl.lastVersion(sel);
		});
		reqs = [sel,versions];
	} else {
		reqs = this.stores().map(function(tbl) { return [tbl.name(),'all',sel ? (-1) : tbl.lastVersion('all')]; });
	};
	
	if (false) {} else {
		return true;
		// console.log "db.sync",reqs
		// var diff = await serverDB:db.syncStores(reqs)
		// patch(diff,reqs)
	};
};

DB.prototype.prefetch = async function (sel,api){
	console.warn("DB.prefetch deprecated!!!");
	api || (api = this.api());
	
	// check for preloaded version
	let slug = JSON.stringify(sel);
	let prev = this.kvs()[slug]; // (sel)
	var cachedPatch;
	
	if (prev && (Date.now() - prev.ts) < 1000) {
		cachedPatch = prev.result;
	};
	
	// var versions = {}
	var versions = false ? true : {};
	var patch = await (cachedPatch || api.find(sel,versions));
	var res = patch[0];
	
	// console.log "returned from prefetch",slug,patch
	
	if (!patch || len$(patch) == 0) {
		return null;
	};
	
	// read dependencies
	for (let i = 0, items = iter$(patch[1]), len = items.length; i < len; i++) {
		this.read(items[i]);
	};
	
	if (false) {};
	
	if (true) {
		api.registerPrefetched(slug,patch);
	};
	
	
	if (res && Object.keys(res).length > 0) {
		for (let v, i = 0, keys = Object.keys(res), l = keys.length, k; i < l; i++){
			k = keys[i];v = res[k];res[k] = this.deserialize(v);
		};
	};
	
	return res;
};

DB.prototype.patch = function (diff,reqs){
	var $1;
	this.log("patch",diff[1],reqs);
	
	var models = diff[0];
	var versions = diff[1];
	
	for (let i = 0, items = iter$(models), len = items.length; i < len; i++) {
		this.read(items[i]);
	};
	
	for (let i = 0, items = iter$(versions), len = items.length; i < len; i++) {
		var req = reqs[i];
		var store = this.stores()[req[0]];
		($1 = store) && $1.lastVersion  &&  $1.lastVersion(req[1],items[i]);
	};
	return this;
};

DB.prototype.rebuild = function (){
	for (let i = 0, items = iter$(this.stores()), len = items.length; i < len; i++) {
		items[i].clear();
	};
	return this.sync(true);
};

DB.prototype.rebuildHard = function (){
	for (let i = 0, items = iter$(this.stores()), len = items.length; i < len; i++) {
		items[i].clear();
	};
	
	return setTimeout(function() { return document.location.reload(); },2000);
};

DB.prototype.syncLocal = function (){
	let res = [];
	for (let i = 0, items = iter$(this.stores()), len = items.length; i < len; i++) {
		res.push(items[i].syncLocal());
	};
	return res;
};

DB.prototype.log = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	if (false) {} else {
		return console.log.apply(console,params);
	};
};

DB.prototype.rpc = function (name,args,o){
	var self = this;
	if(o === undefined) o = {};
	var promise = self._api.rpc(name,args,o);
	var transformer = function(item) {
		if ((typeof item=='string'||item instanceof String)) {
			return self.get(item);
		} else if (item && item.id) {
			return self.read(item);
		};
	};
	
	return promise.then(function(res) {
		if (res instanceof Array) {
			return res.map(transformer);
		} else {
			return transformer(res);
		};
	});
};

DB.prototype.time = function (){
	// console.log Date.now - @ts
	return this;
};

// predefined collections
DB.prototype.presets = function (){
	return this._presets || (this._presets = this.casts().sel(function(_0) { return _0.type == 'template' && _0.spiv == SPIV; }));
};

