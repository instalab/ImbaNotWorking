function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var self = {};
var fs = require('fs');
var path = require('path');
var cp = require('child_process');
var tmp = require('tmp');
var util = require('../util');
var crypto = require('crypto');

var db = require('../server/db').db;
var DB = require('../store/db').DB;

// var root = path.resolve(__dirname,'files')
var env = require('../env');

var ROOT = env.get("FILES_DIR");
var TMPDIR = env.get("TMPDIR");

var Promise = require("bluebird");

var TimelineCues = require('../scrimba/util/TimelineCues').TimelineCues;

exports.fullpath = self.fullpath = function (src,dir){
	if(dir === undefined) dir = ROOT;
	return path.resolve(dir,src);
};

exports.probeToMetadata = self.probeToMetadata = function (probe){
	var metadata = {
		duration: Math.floor(parseFloat(probe.duration || '0') * 1000),
		bitrate: parseInt(probe.bit_rate),
		size: parseInt(probe.size),
		format: probe.format_name
	};
	return metadata;
};

exports.probe = self.probe = function (src,raw){
	if(raw === undefined) raw = false;
	return new Promise(function(resolve) {
		var cmd = ("ffprobe -print_format json -show_format " + self.fullpath(src));
		return cp.exec(cmd,{shell: "/bin/bash"},function(err,out,res) {
			var metadata = {};
			try {
				var json = JSON.parse(out);
				if (raw) {
					resolve(json);
				};
				
				if (json && json.format) {
					metadata = self.probeToMetadata(json.format);
					return resolve(metadata);
				} else {
					return resolve({cmd: cmd,raw: out,error: "invalid"});
				};
			} catch (e) {
				return resolve({error: e,cmd: cmd,raw: out});
			};
		});
	});
};

exports.run = self.run = function (params,retval){
	return new Promise(function(resolve,reject) {
		var t = Date.now();
		return cp.exec(("ffmpeg -loglevel quiet " + params),{shell: "/bin/bash"},function(err,out,res) {
			console.log((" -- ffmpeg (" + (Date.now() - t) + ")"),err,out);
			if (err) {
				"-- ffmpeg error!!!";
			};
			if (retval != undefined) {
				return resolve(retval);
			} else {
				return resolve({params: params});
			};
		});
	});
};

exports.encodeMP3 = self.encodeMP3 = function (src,dest){
	if (fs.existsSync(dest)) {
		return Promise.resolve(true);
	};
	return self.run(("-y -i " + src + " -acodec libmp3lame -q:a 6 " + dest),dest);
};

exports.encodeWebm = self.encodeWebm = function (src,dest){
	if (fs.existsSync(dest)) {
		return Promise.resolve(true);
	};
	return self.run(("-y -i " + src + " -c:a libopus -b:a 48k " + dest));
};

exports.webm2ogg = self.webm2ogg = function (src,dest){
	src = self.fullpath(src);
	dest = dest ? self.fullpath(dest) : ((src + '.ogg'));
	if (fs.existsSync(dest)) { return Promise.resolve(dest) };
	return self.run(("-y -i " + src + " -c:a copy " + dest),dest);
};


var pendingConversions = {};

exports.webm2m4a = self.webm2m4a = function (src,dest){
	src = self.fullpath(src);
	dest = dest ? self.fullpath(dest) : ((src + '.m4a'));
	if (fs.existsSync(dest)) { return Promise.resolve(dest) };
	
	return pendingConversions[src] || (pendingConversions[src] = new Promise(async function(resolve,reject) {
		await self.run(("-n -i " + src + " -ac 1 -c:a aac -b:a 96k -strict experimental " + dest),dest);
		pendingConversions[src] = null;
		return resolve(dest);
	}));
};

exports.fetchInfo = self.fetchInfo = async function (id){
	var src = self.fullpath(id);
	
	if (!fs.existsSync(src)) {
		return Promise.resolve({id: id,CODE: 404});
	};
	
	var meta = await self.probe(src);
	
	var data = {
		id: id
	};
	
	data.metadata = meta;
	data.size = meta.size;
	
	if (meta.format) {
		if (meta.format.match(/webm/)) {
			data.type = 'audio/webm;codecs=opus;';
		} else if (meta.format.match(/m4a/)) {
			data.type = 'audio/mp4;';
		};
	};
	
	return data;
};

// wait for file filled with silence
exports.silencepath = self.silencepath = function (dur,ext){
	var tot = Math.ceil(dur / 5) * 5;
	var out = self.fullpath(("silence-" + tot + "s." + ext));
	console.log("silence for",out);
	
	return new Promise(async function(resolve) {
		if (fs.existsSync(out)) {
			return resolve(out);
		};
		
		var cmd = ("-y -f lavfi -t " + tot + " -i anullsrc ");
		
		if (ext == 'webm') {
			cmd += " -c:a libopus -b:a 48k";
		} else if (ext == 'm4a') {
			cmd += " -c:a aac -b:a 96k -strict experimental";
		} else {
			cmd += " -c:a libopus -b:a 48k";
		};
		
		cmd += (" " + out);
		
		console.log("run",cmd);
		await self.run(cmd);
		return resolve(out);
	});
};


exports.muxwebm = self.muxwebm = function (src,dest){
	var overwrite = false;
	if (dest == null) {
		overwrite = true;
		dest = src + ".muxed.webm";
		// make sure the dest does not already exist
		if (fs.existsSync(dest)) {
			fs.unlinkSync(dest);
		};
	};
	// var tmpFile = tmp.tmpNameSync(postfix: ".webm", dir: TMPDIR)
	var cmd = ("mkvmuxer_sample -i " + src + " -o " + dest + " -output_cues 1 -cues_on_audio_track 1 -max_cluster_duration 5");
	return new Promise(function(resolve,reject) {
		return cp.exec(cmd,{},async function(err) {
			if (err) {
				// console.log "error from muxwebm {cmd}!",err
				return resolve({error: "mkvmuxer_sample failed"});
			};
			// fs.renameSync(tmpFile, dest)
			
			var meta = await self.probe(dest);
			
			if (overwrite && meta.duration) {
				console.log(("muxed " + src + "!"),meta);
				// remove the original file
				fs.unlinkSync(src);
				// move the target file to src dest
				fs.renameSync(dest,src);
			};
			
			return resolve(meta);
		});
	});
};

exports.finalize = self.finalize = async function (file,upd){
	if(upd === undefined) upd = {};
	var src = file.id;
	var ext = src.split('.').pop();
	var dest = src;
	
	// only if it has not bee finalized?
	
	if (ext == 'webm') {
		dest = await self.webm2ogg(src);
	};
	
	console.log("converted to ogg!",src);
	
	var meta = await self.probe(dest);
	
	console.log("got metadata",meta);
	
	// console.log "finalize file",ext,src,meta
	// var mux = meta:duration == 0 and ext == 'webm'		
	// meta = await (mux ? muxwebm(fullpath(src)) : meta)
	
	upd.metadata || (upd.metadata = file.metadata);
	for (let val, i = 0, keys = Object.keys(meta), l = keys.length, key; i < l; i++){
		// only if update is needed
		key = keys[i];val = meta[key];upd.metadata[key] = val;
	};
	upd.size = meta.size;
	await file.update(upd);
	return file;
};

exports.probeFileIds = self.probeFileIds = function (ids){
	return Promise.map(ids,async function(fid) {
		var file = await DB.instance().fetch(fid); // db.table('files').where(id: fid).first
		// console.log 'found file',fid
		await self.finalize(file);
		return file;
	},{concurrency: 1});
};

exports.probeClips = self.probeClips = async function (items){
	var promises = [];
	var fids = [];
	// go through clips -- ensure that there are muxed versions - possibly overwrite item
	for (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
		item = ary[i];
		if (fids.indexOf(item.fid) < 0) {
			fids.push(item.fid);
		};
	};
	
	var files = await self.probeFileIds(fids);
	console.log("result from probed files!",files);
	for (let i = 0, ary = iter$(files), len = ary.length, file; i < len; i++) {
		file = ary[i];
		files[file.id] = file;
	};
	
	for (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
		item = ary[i];
		let f = files[item.fid];
		if (f) {
			item.fdur = f.metadata.duration;
			item.fmt = f.type;
			item.file = f;
		};
	};
	
	return items;
};

exports.generate = self.generate = async function (src,sms,tms,o){
	
	if(o === undefined) o = {};
	var cmd = o.mergeCmd || '-n -seek2any 1 -i SRC -ss $S -t $T -c copy -avoid_negative_ts make_zero DEST';
	var dest;
	
	if (sms === null) {
		// how will this work with a different dir?
		// console.log "SKIP THIS!!",src
		if (src.match(/\.webm$/)) {
			// cmd = '-n -seek2any 1 -i SRC -c copy DEST'
			dest = src + ".ogg";
			sms = 0;
		} else {
			return Promise.resolve({
				sms: 0,
				tms: tms,
				duration: tms,
				meta: {format: {duration: tms / 1000}},
				src: self.fullpath(src)
			});
		};
	};
	
	// round start and end
	let remux = o.mergeRemux || false;
	
	var overwrite = o.debug ? "y" : "n";
	
	// include hash of command template in filename to automatically regenerate if our commands change.
	var cmdhash = crypto.createHash('md5').update(cmd).digest('hex');
	dest || (dest = ("" + sms + "_" + tms + "." + src + "." + cmdhash + ".ogg")); // including the ext
	
	cmd = cmd.replace('SRC',self.fullpath(src)).replace('DEST',self.fullpath(dest,o.dir));
	cmd = cmd.replace('$S',sms / 1000);
	cmd = cmd.replace('$T',tms / 1000);
	if (overwrite) { cmd = cmd.replace("-n ","-y ") };
	
	if (src == 'gap') {
		// dest += '.ogg' # extension?
		cmd = ("-" + overwrite + " -f lavfi -t " + ((tms) / 1000) + " -i anullsrc -ac 1 -c:a libopus -b:a 64k -frame_duration 20 -vbr on " + self.fullpath(dest,o.dir));
		remux = true;
	};
	
	let fdest = self.fullpath(dest,o.dir);
	
	let out = {
		src: fdest,
		cmd: cmd,
		sms: sms,
		tms: tms
	};
	
	var res = await self.run(cmd,out);
	
	let meta = await (o.debug ? self.probe(fdest,true) : Promise.resolve({}));
	
	out.meta = meta;
	// out:metapre = metapre
	out.duration = tms;
	return out;
};

exports.copymerge = self.copymerge = async function (items,options){
	if(options === undefined) options = {};
	if (!items || !len$(items)) { return Promise.resolve() };
	
	items = await self.probeClips(items);
	
	var dir = options.dir || ROOT;
	
	
	let currTime = 0;
	var endTime = options.duration || 0;
	
	var segments = [];
	
	for (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
		item = ary[i];
		let sms = item.skip;
		let tms = item.t1 - item.t0;
		let gap = item.t0 - currTime;
		let fdur = item.fdur;
		
		if (gap > 0) { segments.push(['gap',0,gap]) };
		
		if (sms == 0 && Math.abs(fdur - tms) < 10) {
			console.log("use whole file",Math.abs(fdur - tms));
			segments.push([item.fid,null,tms]);
		} else if (tms < 100 || (fdur - sms) < 100) {
			// just insert silence if it is a tiny clip
			console.log("less than 100ms",tms,(fdur - sms));
			segments.push(['gap',0,tms]);
		} else {
			segments.push([item.fid,sms,tms]);
		};
		
		currTime = item.t1;
	};
	
	// at the end
	if (currTime < endTime) {
		segments.push(['gap',0,endTime - currTime]);
	};
	
	
	var files = await Promise.map(segments,function(seg) {
		// dir: dir, debug: options:debug, remux: options:remux
		return self.generate(seg[0],seg[1],seg[2],options);
	},{concurrency: 1});
	
	// console.log files
	
	let concat = files.map(function(file) { return ("file '" + (file.src) + "'"); }).join("\n");
	
	// we are still using .webm as the root file, but everything inside copymerge uses ogg.
	// so the actual destination will be destname.webm.ogg, and afterwards we generate a webm version from it
	let destname = (options.destname || ('fo-pub-' + crypto.createHash('md5').update(concat).digest('hex'))) + '.webm';
	let webmdest = self.fullpath(destname,dir);
	let oggdest = webmdest + '.ogg';
	
	
	let concatdest = self.fullpath(destname + '.txt');
	fs.writeFileSync(concatdest,concat);
	
	let cmd = ("-" + (options.debug ? 'y' : 'n') + " -f concat -safe 0 -i <(printf \"" + concat + "\") -c copy " + oggdest);
	
	await self.run(cmd);
	// create a webm version at the same time
	await self.run(("-y -i " + oggdest + " -c copy " + webmdest));
	// console.log concat
	
	if (options.debug) {
		console.log(concat);
		
		try {
			let delta = 0;
			let fullDur = 0;
			let expDur = 0;
			
			for (let i = 0, ary = iter$(files), len = ary.length, item; i < len; i++) {
				item = ary[i];
				let probeDur = Math.round(parseFloat(item.meta.format.duration) * 1000);
				let itemDur = item.duration;
				
				fullDur += probeDur;
				expDur += item.duration;
				
				console.log(("" + (probeDur - item.duration) + ", " + (item.src.split("/").pop()) + " " + probeDur + " " + (item.duration)));
			};
			console.log((fullDur - expDur),"duration diff",fullDur,expDur,oggdest);
		} catch (e) { };
	};
	
	// should also include the actual duration
	return destname;
};

exports.ensureDurations = self.ensureDurations = async function (draft){
	// should be unique files now
	var fids = draft.audio.map(function(marker) { return marker[3]; });
	var files = await self.probeFileIds(fids);
	
	return console.log(draft.audio,files.map(function(v) { return v.metadata.duration; }));
};

exports.audioForCues = self.audioForCues = async function (tl,o){
	if(o === undefined) o = {};
	tl = JSON.parse(JSON.stringify(tl));
	var fids = tl.audio.map(function(marker) { return marker[3]; });
	
	// o:debug = true
	// get the file-durations
	var cues = new TimelineCues(tl);
	var startOffset = tl.start || 0;
	var endOffset = tl.end;
	var startTime = cues.offsetToTime(startOffset);
	var endTime = cues.offsetToTime(endOffset);
	var dur = o.duration = Math.ceil(endTime - startTime);
	var clips = cues.audioclips(startOffset,endOffset);
	
	var filename = await self.copymerge(clips,o);
	return filename;
};

// -itsoffset 5 
// ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex amix=inputs=3:duration=first:dropout_transition=3 OUTPUT

exports.mixAudio = self.mixAudio = async function (timeline,o){
	if(o === undefined) o = {};
	var clips = timeline.audioclips();
	var items = await self.probeClips(clips);
	
	var segments = [];
	var filter = [];
	var mix = "";
	
	for (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
		// let sms = item:skip
		// let tms = item:t1 - item:t0
		// let gap = item:t0 - currTime
		// let fdur = item:fdur
		item = ary[i];
		let src = self.fullpath(item.fid);
		// no skip support
		segments.push(("-i " + src));
		// -itsoffset {item:t0 / 1000} 
		// [2:a]adelay=2000.0[a1];[0][a1][2][3]amix=inputs=4:duration=longest:dropout_transition=0
		filter.push(("[" + i + ":a]adelay=" + (item.t0) + "[a" + i + "];"));
		mix += ("[a" + i + "]");
	};
	
	// console.log segments
	mix += ("amix=inputs=" + (len$(segments)) + ":duration=longest:dropout_transition=0");
	filter.push(mix);
	let cmd = segments.join(" ") + (" -filter_complex \"" + filter.join('') + "\" -c:a libopus -b:a 32k");
	let destname = (o.destname || ('fo-pub-' + crypto.createHash('md5').update(cmd).digest('hex'))) + '.ogg';
	cmd += (" " + self.fullpath(destname));
	// console.log "ffmpeg -n {cmd}"
	await self.run("-n " + cmd);
	return destname;
};
