function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _1 = Imba.createElement, self = {};

var Space = require('../../app/scrimba/space').Space;
var fetch = require('node-fetch');
var escape = require('escape-html');
var cors = require('cors');
var fs = require('fs');
var state$ = require("./space-state"), stateForSpaceId = state$.stateForSpaceId, spaceAtIndex = state$.spaceAtIndex;
var ImbaCompiler = require('imba/compiler');
var babel = require("babel-core");
var babelReact = require('babel-preset-react');
var babelEs2015 = require('babel-preset-es2015');
var SourceMapGenerator = require('source-map').SourceMapGenerator;
var ts = require('typescript');
var sass = require('node-sass');
var env = require('../env');
var path = require('path');

var ImbaCompilers = {
	base: ImbaCompiler,
	"1.2": require('../util/imbac-1.2.1'),
	"1.3": require('../util/imbac-1.3.0'),
	"1.4": require('../util/imbac-1.4.0')
};

ImbaCompilers["1.0"] = ImbaCompilers["1.2"];
ImbaCompilers["1.1"] = ImbaCompilers["1.2"];

var baseCSS = fs.readFileSync(__dirname + '/../scrimba/widgets/browser/normalize.css');

Imba.extendTag('base', function(tag){
	tag.prototype.href = function(v){ return this.getAttribute('href'); }
	tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
});

function Packager(id,snapshot,filename,api){
	this._id = id;
	this._snapshot = snapshot;
	this._api = api;
	
	this._files = snapshot.files;
	this._npmPackages = snapshot.npmPackages;
	this._rootPath = snapshot.rootPath;
	this._catchallPath = snapshot.catchallPath;
	
	this._filename = filename;
};

Packager.prototype.id = function(v){ return this._id; }
Packager.prototype.setId = function(v){ this._id = v; return this; };
Packager.prototype.api = function(v){ return this._api; }
Packager.prototype.setApi = function(v){ this._api = v; return this; };
Packager.prototype.filename = function(v){ return this._filename; }
Packager.prototype.setFilename = function(v){ this._filename = v; return this; };

Packager.prototype.ext = function (filename){
	var m;
	if (m = filename.match(/\.([^\.]+)$/)) {
		return m[1];
	};
};

Packager.prototype.findFile = function (filename){
	for (let i = 0, items = iter$(this._files), len = items.length, file; i < len; i++) {
		file = items[i];
		if (file.path == this._rootPath + filename.slice(1)) {
			return file;
		};
	};
	return;
};

Packager.prototype.injectTracker = function (body){
	var script = (_1('script')).setSrc(this.api().assetsPath('tracker.js')).end();
	return ("" + script + body);
};

Packager.prototype.injectRootURL = function (body,root){
	var script = (_1('script')).setText("SCRIMBA_ROOT = " + JSON.stringify(root));
	return ("" + script + body);
};

Packager.prototype.injectBaseURL = function (body,url){
	var base = (_1('base')).setHref(url).end();
	return ("" + base + body);
};

Packager.prototype.injectBaseCSS = function (body){
	var style = ("<style scrimba-base-css>/*§SR§BASECSS§START*/" + baseCSS + "/*§SR§END*/</style>");
	return ("" + style + body);
};

Packager.prototype.injectDocType = function (body){
	return ("<!DOCTYPE html>" + body);
};

Packager.prototype.injectStatus = function (body,status){
	var script = (_1('script')).setText("SCRIMBA_STATUS = " + status);
	return ("" + script + body);
};

Packager.prototype.injectProxies = function (body,basename){
	// return body
	var shim = ['document','location','history'];
	var pre = '(function(window){ var ' + shim.map(function(v) { return v + ("=window." + v); }).join(",") + ';';
	var requireMgs = ("You need to write <script src=\"" + basename + ".pack.js\"> to use require()");
	pre += ("function require() \{ throw new Error(" + JSON.stringify(requireMgs) + ") \}");
	pre += '\n';
	var post = '\n})(window.SCRIMBA_WINDOW || window)';
	return pre + body + post;
};

Packager.prototype.mappedErrorResult = function (message,line,column){
	var gen = new SourceMapGenerator();
	gen.addMapping(
		{source: "unknown",
		generated: {line: 1,column: 1},
		original: {line: line,column: column}}
	);
	
	return {
		map: gen.toJSON(),
		code: ("throw new Error(" + JSON.stringify(message.toString()) + ")")
	};
};

Packager.prototype.babelify = function (code){
	try {
		return babel.transform(code,{presets: [babelReact,babelEs2015],
		sourceMaps: true});
	} catch (err) {
		if (err.loc) {
			return this.mappedErrorResult(err,err.loc.line,err.loc.column);
		} else {
			throw err;
		};
	};
};

Packager.prototype.imabify = function (code,o){
	if(o === undefined) o = {};
	try {
		console.log(("imbaify with language version " + (o.version)));
		var compiler = ImbaCompilers[o.version] || ImbaCompiler;
		var result = compiler.compile(code,{sourceMap: true,sourcePath: "unknown",target: 'web'});
		return {
			code: result.toString(),
			map: result.sourcemap
		};
	} catch (err) {
		return {
			code: ("throw new Error(" + JSON.stringify(err.toString()) + ")")
		};
	};
};

Packager.prototype.tsify = function (code){
	var diag;
	var options = {
		compilerOptions: {
			module: ts.ModuleKind.CommonJS,
			emitDecoratorMetadata: true,
			experimentalDecorators: true,
			sourceMap: true,
			jsx: "React"
		},
		reportDiagnostics: true
	};
	var result = ts.transpileModule(code,options);
	
	if (diag = result.diagnostics[0]) {
		var loc = diag.file.getLineAndCharacterOfPosition(diag.start);
		return this.mappedErrorResult(diag.messageText,loc.line + 1,loc.character + 1);
	} else {
		return {
			code: result.outputText,
			map: JSON.parse(result.sourceMapText)
		};
	};
};

Packager.prototype.packedFile = function (name){
	var code = function(options,name) {
		if (typeof SCRIMBA_LOADER == 'undefined') {
			window.SCRIMBA_LOADER = new (window.SCRIMBA_PackageLoader)(options);
		};
		return window.SCRIMBA_LOADER.loadVerbose(("/" + name));
	};
	
	var options = {
		files: {},
		sourceMapping: {},
		structure: [],
		id: this.id()
	};
	
	var imbaVersion = null;
	
	if (this._npmPackages) {
		options.structure = this._npmPackages.structure;
	};
	
	for (let i = 0, items = iter$(this._files), len = items.length, file; i < len; i++) {
		file = items[i];
		if (file.blobId) {
			continue;
		};
		
		if (!file.path.startsWith(this._rootPath)) {
			continue;
		};
		
		var compiledName = file.path.slice(this._rootPath.length - 1);
		compiledName = compiledName.replace(/\.([^\.]+)$/,'.js').replace(/^\//,'');
		var ext = this.ext(file.path);
		var result = null;
		
		switch (ext) {
			case "js": {
				result = this.babelify(file.body);
				break;
			}
			case "imba": {
				console.log("nmp str",(this._npmPackages.resolved || []).join(" "));
				try {
					imbaVersion || (imbaVersion = (this._npmPackages.resolved || []).join(" ").match(/imba\@(\d+\.\d+)/)[1]);
				} catch (e) { };
				result = this.imabify(file.body,{version: imbaVersion});
				break;
			}
			case "ts": {
				result = this.tsify(file.body);
				break;
			}
		};
		
		if (result) {
			if (result.map) {
				result.map.sourcesContent = [];
				result.map.sources = [file.path];
			};
			options.files[compiledName] = result.code;
			options.sourceMapping[compiledName] = result.map;
		};
	};
	
	var json = JSON.stringify(options);
	var strName = JSON.stringify(name);
	
	return ("(" + code + ")(" + json + ", " + strName + ")");
};

Packager.prototype.rewriteLinkTags = function (html){
	var self = this;
	var dirname = path.dirname(self.filename());
	
	var result = "";
	var tagRe = /<link ([^>]+)>/g;
	return html.replace(tagRe,function(match,attrString) {
		var attrMatch, styleFile;
		var attrRe = /([^<>=\s\\/]+|\/)(\s*=\s*(("(.*?)")|('(.*?)')|([^>\s]*)))?\s*/g;
		
		var styleBody;
		var relValue;
		while (attrMatch = attrRe.exec(attrString)){
			var key = attrMatch[1];
			var value = attrMatch[5] || attrMatch[7] || attrMatch[8];
			var fullPath = value && path.resolve("/",dirname,value);
			
			if (key == "href" && fullPath && (styleFile = self.findFile(fullPath))) {
				styleBody = styleFile.body;
			};
			
			if (key == "rel") {
				relValue = value;
			};
		};
		
		if (relValue == "stylesheet" && styleBody) {
			styleBody = ("/*SCRIMBA:IGNORE:START*/" + styleBody + "/*SCRIMBA:IGNORE:END*/");
			return ("<style " + attrString + " scrimba-live='" + fullPath + "'>" + styleBody + "</style>");
		} else {
			return match;
		};
	});
};

Packager.prototype.compileCss = function (filename,body){
	if (/\.scss$/.test(filename)) {
		var result = sass.renderSync({data: body});
		return result.css.toString();
	} else {
		return body;
	};
};

Packager.prototype.respondTo = function (req,res,next){
	var m, e;
	var body;
	var file;
	var status = 200;
	var isPack = false;
	
	if (m = this.filename().match(/^(.+)\.pack\.js$/)) {
		res.type('js');
		res.send(this.packedFile(m[1]));
		return;
	};
	
	file = this.findFile(this.filename());
	
	if (file && file.blobId) {
		var blobPath = ("/blobs/" + (file.blobId));
		if (e = this.ext(this.filename())) {
			blobPath += ("." + e);
		};
		var mainhost = req.get('host').replace(/^run\./,'');
		var blobUrl = ("https://" + mainhost + blobPath);
		res.redirect(blobUrl);
		return;
	};
	
	var isFallback = false;
	
	if (!file) {
		file = this.findFile(("/" + (this._catchallPath)));
		if (file) {
			isFallback = true;
		};
	};
	
	if (file) {
		body = file.body;
	} else {
		var withoutCss = this.filename().replace(/\.css$/,"");
		if (file = this.findFile(withoutCss)) {
			body = this.compileCss(withoutCss,file.body);
		} else if (this.filename() == '503.html') {
			status = 503;
			body = "503 Service Unavailable";
		} else {
			status = 404;
			body = "404 File not found";
		};
	};
	
	res.status(status);
	
	var root = req.url;
	if (root.endsWith(this.filename())) {
		root = root.slice(0,root.length - this.filename().length) + "/";
	};
	
	if (/\.html$/.test(this.filename()) || isFallback) {
		body = this.rewriteLinkTags(body);
		body = this.injectRootURL(body,root);
		if (isFallback) { body = this.injectBaseURL(body,root) };
		body = this.injectTracker(body);
		body = this.injectBaseCSS(body);
		body = this.injectStatus(body,status);
		body = this.injectDocType(body);
		return res.type('html').send(body);
	} else if (/\.js$/.test(this.filename())) {
		var basename = this.filename().replace(/\.js$/,"");
		body = this.injectProxies(body,basename);
		return res.type('js').send(body);
	} else {
		return res.type(this.ext(this.filename()) || 'html').send(body);
	};
};

var express = require('express');
var app = exports.app = express();


self.promise = function (cb){
	return function(req,res,next) {
		return cb(req,res,next).catch(function(err) { return next(err); });
	};
};

app.get('/static/timeout.js',function(req,res,next) {
	return setTimeout(function() {
		return res.send("console.log('timeout')");
	},300);
});

app.get('/static/timeout.html',function(req,res,next) {
	return setTimeout(function() { return res.send("hello"); },30000);
});

var TMP_STATE = {};

app.options('/static/tmp/:id',cors());

app.post('/static/tmp/:id',cors(),function(req,res,next) {
	TMP_STATE[req.params.id] = req.body;
	return res.send("ok");
});

app.get('/static/tmp/:id:path(/*)',function(req,res,next) {
	var id = req.params.id;
	var state = TMP_STATE[id];
	if (!state) {
		return res.status(404).send("not found");
	};
	var packager = new Packager(id,state,req.params.path,req.api);
	return packager.respondTo(req,res,next);
});

app.get('/static/:castid/:index:path(/*)',self.promise(async function(req,res,next) {
	var id = req.params.castid;
	var index = Number(req.params.index);
	var cast = req.api.db().spaces().get(id);
	
	if (cast.isLocal()) {
		await cast.fetch();
	};
	
	var snapshot = await spaceAtIndex(req.api,req.params.castid,index,function(_0) { return _0.toRunStaticSnapshot(); });
	var packager = new Packager(id,snapshot,req.params.path,req.api);
	
	// testing delays
	// if req:params:name.indexOf('.html') >= 0
	// 	setTimeout(&,500) do packager.respondTo(res, next)
	// 	return
	
	return packager.respondTo(req,res,next);
}));
