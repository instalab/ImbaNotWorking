function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');
var LongPromise = require('../../util/LongPromise').LongPromise;

var mimeTypes = ['audio/ogg; codecs=opus;',"audio/webm; codecs=opus;",'audio/opus'];

var AudioManager = require('./AudioManager').AudioManager;

// Error handling is messy here. A mix of promises, fake promises (LongPromise),
// and resolving these even when there are errors
function MediaRecording(options){
	if(options === undefined) options = {};
	this._options = options;
	this._space = options.space;
	this._branch = options.branch || this._space.branch();
	this._constraints = options.constraints;
	this._chunkSize = 60 * 8; // 480ms
	this._frameSize = this.api().ua().isChrome() ? 60 : 20; // 20 for firefox
	this._audioBitRate = options.audioBitsPerSecond || 32000;
	this._size = 0;
	this._chunks = [];
	this._warnings = [];
	this._timecodes = [];
	// @setupPromise = LongPromise.new
	this._startPromise = new LongPromise();
	this._donePromise = new LongPromise();
	this._state = 'init';
	
	this._timecodeDuration = 0;
	
	if (window.MediaRecorder) {
		for (let i = 0, len = mimeTypes.length, type; i < len; i++) {
			type = mimeTypes[i];
			if (MediaRecorder.isTypeSupported(type)) {
				this._mimeType = type;
				this._ext = type.match(/\/(\w+)/)[1];
			};
		};
	};
	this;
};

exports.MediaRecording = MediaRecording; // export class 
MediaRecording.prototype.size = function(v){ return this._size; }
MediaRecording.prototype.setSize = function(v){ this._size = v; return this; };
MediaRecording.prototype.warnings = function(v){ return this._warnings; }
MediaRecording.prototype.setWarnings = function(v){ this._warnings = v; return this; };
MediaRecording.prototype.stream = function(v){ return this._stream; }
MediaRecording.prototype.setStream = function(v){ this._stream = v; return this; };
MediaRecording.prototype.options = function(v){ return this._options; }
MediaRecording.prototype.setOptions = function(v){ this._options = v; return this; };
MediaRecording.prototype.state = function(v){ return this._state; }
MediaRecording.prototype.setState = function(v){ this._state = v; return this; };
MediaRecording.prototype.audio = function(v){ return this._audio; }
MediaRecording.prototype.setAudio = function(v){ this._audio = v; return this; };
MediaRecording.prototype.space = function(v){ return this._space; }
MediaRecording.prototype.setSpace = function(v){ this._space = v; return this; };
MediaRecording.prototype.mimeType = function(v){ return this._mimeType; }
MediaRecording.prototype.setMimeType = function(v){ this._mimeType = v; return this; };
MediaRecording.prototype.chunkSize = function(v){ return this._chunkSize; }
MediaRecording.prototype.setChunkSize = function(v){ this._chunkSize = v; return this; };
MediaRecording.prototype.audioBitRate = function(v){ return this._audioBitRate; }
MediaRecording.prototype.setAudioBitRate = function(v){ this._audioBitRate = v; return this; };
MediaRecording.prototype.error = function(v){ return this._error; }
MediaRecording.prototype.setError = function(v){ this._error = v; return this; };
MediaRecording.prototype.widget = function(v){ return this._widget; }
MediaRecording.prototype.setWidget = function(v){ this._widget = v; return this; };

MediaRecording.prototype.startAt = function(v){ return this._startAt; }
MediaRecording.prototype.setStartAt = function(v){ this._startAt = v; return this; };
MediaRecording.prototype.startedAt = function(v){ return this._startedAt; }
MediaRecording.prototype.setStartedAt = function(v){ this._startedAt = v; return this; };
MediaRecording.prototype.stopAt = function(v){ return this._stopAt; }
MediaRecording.prototype.setStopAt = function(v){ this._stopAt = v; return this; };
MediaRecording.prototype.stoppedAt = function(v){ return this._stoppedAt; }
MediaRecording.prototype.setStoppedAt = function(v){ this._stoppedAt = v; return this; };

MediaRecording.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
MediaRecording.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
MediaRecording.prototype.once = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.once.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
MediaRecording.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

MediaRecording.prototype.manager = function (){
	return AudioManager.instance();
};

MediaRecording.prototype.api = function (){
	return App.api();
};

MediaRecording.prototype.log = function (){
	var api_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (api_ = this.api()).log.apply(api_,[].concat(['media'], [].slice.call(params)));
};

MediaRecording.prototype.proxy = function (type,event){
	this.setState(this._recorder.state);
	if (this[("onrec" + type)]) {
		return this[("onrec" + type)](event);
	};
};

MediaRecording.prototype.setup = function (){
	var self = this;
	return self._setupPromise || (self._setupPromise = new Promise(function(resolve,reject) {
		self._state = 'setup';
		var ok = function(stream) {
			self.setStream(stream);
			return setTimeout(function() {
				self._state = 'ready';
				return resolve(self);
			},500);
		};
		
		var err = function(e) {
			self.log("error!!!",e);
			self._error = e;
			self.setState('error');
			return reject(e);
		};
		
		if (self._options.stream) {
			self.setStream(self._options.stream);
			self._state = 'ready';
			return resolve(self);
			// return ok(@options:stream)
		};
		// log "try to getUserMedia",@constraints
		return window.navigator.mediaDevices.getUserMedia({
			video: false,
			audio: self._constraints
		}).then(ok,err);
	}));
};


MediaRecording.prototype.start = async function (){
	var self = this;
	if (self._startAt) { return self._startPromise };
	self._startAt = Date.now();
	
	let val = await self.setup();
	
	if (self._error) {
		self._startPromise.resolve(self);
		return;
	};
	
	self._state = 'starting';
	
	var meta = Object.assign({
		chunkSize: self._chunkSize,
		bitsPerSecond: self._audioBitRate,
		mimeType: self.mimeType()
	// timeOffset: owner?.startTimeOffset
	},self._options.meta || {});
	
	if (self._constraints) {
		meta.constraints = self._constraints;
	};
	
	
	
	if (self._space) {
		// Create the filemodel
		// ask server for an actual file id?
		let fid = self.api().db().files().generateId();
		// include space-id and peer-id?
		self._model = self.api().db().files().build(
			{id: fid + '.' + self._ext,
			uid: self.api().uid(), // should belong to a different user no?
			eid: self._branch && self._branch.id(),
			type: self.mimeType(),
			state: 'streaming',
			size: 0,
			metadata: meta}
		);
		await self._model.save();
		self._writer = self._model.createWriteStream(self.space().api());
	};
	
	var opts = {
		mimeType: self.mimeType(),
		audioBitsPerSecond: self._audioBitRate
	};
	
	// TODO add listeners to stream (oninactive, onerror etc)
	
	self._recorder = new MediaRecorder(self.stream(),opts);
	self._recorder.audioChannels = 1;
	
	// bind events
	['start','stop','error','dataavailable','pause','resume'].map(function(type) {
		return self._recorder[("on" + type)] = function(e) { return self.proxy(type,e); };
	});
	
	self._startAt = Date.now();
	self._recorder.start(self._chunkSize);
	
	window.MRI = self;
	
	return self._startPromise;
};

MediaRecording.prototype.stop = async function (){
	if (this._requestedStop) { return this._donePromise };
	this._requestedStop = true;
	this._stopAt = Date.now();
	this._recorder.stop();
	await this._donePromise;
	if (this.widget()) {
		this.widget().setDuration(this.duration());
	};
	return this._donePromise;
};

MediaRecording.prototype.warn = function (message){
	console.warn(message);
	return this;
};

MediaRecording.prototype.check = function (){
	if (!this._lastChunkAt) { return };
	var timeSinceChunk = (Date.now() - this._lastChunkAt);
	if (timeSinceChunk > (this._chunkSize * 4)) {
		this._warn = true;
		this.warn(("no audio received in the last " + timeSinceChunk + "ms"));
		// stop
	} else {
		if (this._warn) {
			console.log("got back!!");
			this._warn = false;
		};
	};
	
	return this;
};

MediaRecording.prototype.duration = function (){
	if (this._duration) {
		return this._duration;
	} else if (this._stoppedAt) {
		return this._stoppedAt - this._startedAt;
	} else if (this._stopAt) {
		return this._stopAt - this._startedAt;
	} else if (this._startedAt) {
		return Date.now() - this._startedAt;
	} else {
		return 0;
	};
};

MediaRecording.prototype.onrecstart = function (e){
	// @lastChunkAt = Date.now
	
	var self = this, widget_, v_;
	self._checker = setInterval(function() { return self.check(); },self._chunkSize);
	self._startedAt = Date.now();
	self.log("recstart",self._startedAt - self._startAt);
	
	setTimeout(function() {
		if (!len$(self._chunks)) {
			return console.warn("something wrong with recording?! Timed out");
		};
	},5000);
	self._startPromise.resolve(self);
	
	// create widget
	if (self.space()) {
		let data = Object.assign(self._options.data || {},{
			type: 'mediastream',
			audio: !(!(self.stream().getAudioTracks()[0])),
			video: !(!(self.stream().getVideoTracks()[0])),
			mimeType: self.mimeType(),
			fid: self._model.id
		});
		(widget_ = self.widget()) || ((self.setWidget(v_ = self.space().createWidget(data).widget()),v_));
		console.log("created widget for audio",self.widget());
	};
	return self;
};

MediaRecording.prototype.onrecstop = function (e){
	var self = this;
	clearInterval(self._checker);
	self._stoppedAt = Date.now();
	let remainder = self.duration() % self._frameSize;
	self._calcDuration = self._stoppedAt - self._startedAt;
	
	// chrome is recording with 60ms frames, and it will drop the current frame
	// so, if we are 43ms into the last frame, we know that this will not be included
	if (self.api().ua().isChrome()) {
		self._calcDuration -= remainder;
	};
	
	self._duration = self._calcDuration;
	self.log("recstop",self._duration,remainder);
	self.finalize();
	setTimeout(function() { return self.teardown(); },200);
	return self;
};

MediaRecording.prototype.onrecdataavailable = function (e){
	if (this._stoppedAt) {
		console.error("Received audio-data after stopping");
	};
	
	let nr = len$(this._chunks);
	this._chunks.push(e.data);
	this._size += e.data.size;
	let time = Date.now();
	let timecode = e.timecode || 0;
	this._timecodes.push(timecode);
	
	let deltaTime = this._lastTimecode ? ((timecode - this._lastTimecode)) : 0;
	if (len$(this._chunks) % 10 == 0) {
		this.log("audiochunk",e.data.size,this._size,(time - (this._lastChunkAt || time)),deltaTime,timecode);
	};
	
	if (nr == 0) {
		this._timecodeDuration = time - this._startAt;
	} else {
		this._timecodeDuration += deltaTime;
	};
	
	this._lastTimecode = timecode;
	this._lastChunkAt = time;
	this._firstChunkAt || (this._firstChunkAt = this._lastChunkAt);
	this._writer && this._writer.write(e.data,this.api());
	return this;
};

MediaRecording.prototype.onrecerror = function (e){
	this.log("ERROR",e);
	console.error(e);
	if (!this._error) {
		this._error = e;
		this.setState('error');
		this._donePromise.resolve(this._error);
	};
	return this;
};

MediaRecording.prototype.finalize = async function (){
	var self = this;
	var blob = self._blob || (self._blob = new Blob(self._chunks,{type: self.mimeType()}));
	var fast = !window.DEBUG_AUDIO && !self._options.debug;
	await (self._writer && self._writer.close(blob));
	return self._donePromise.resolve(self);
	
	try {
		if (fast && self.api().localStore().get('calcRecDuration')) {
			console.log("trusting the calculated duration");
			self._donePromise.resolve(self);
			return self;
		};
		
		self._audioBuffer = await self.manager().audioBufferFromBlob(blob);
		self.log("response from buffer",self._audioBuffer.duration);
		self._bufferDuration = self._audioBuffer.duration * 1000;
		self._duration = self._bufferDuration;
		
		// check difference
		if (Math.abs(self._bufferDuration - self._calcDuration) < 3) {
			console.log("calculated duration is correct",self._bufferDuration - self._calcDuration);
			self.api().localStore().set('calcRecDuration',1);
		} else {
			self.api().localStore().del('calcRecDuration');
		};
		
		if (fast) {
			self._donePromise.resolve(self);
			return self;
		};
		
		// return
		// this is the duration we do
		// get real duration
		return self.manager().durationForAudioElement(self.audio(),self.duration()).then(function(dur) {
			self.log("duration according to manager",dur);
			self._blobDuration = Math.round(dur);
			
			if (Math.abs(self._blobDuration - self._duration) > 1000) {
				self.setError("Duration mismatch from audio recording");
				App.uxa().flash("Duration mismatch from audio recording");
			};
			// else
			// 	@duration = @blobDuration
			return self._donePromise.resolve(self);
		});
	} catch (e) { };
};

MediaRecording.prototype.audio = function (){
	if (this._audio || !this._stoppedAt) { return this._audio };
	var blob = this._blob || new Blob(this._chunks,{type: this.mimeType()});
	var audio = APB = this._audio = new Audio();
	audio.src = URL.createObjectURL(blob);
	audio.controls = true;
	audio.load();
	return this._audio;
};

MediaRecording.prototype.play = function (){
	this.audio().currentTime = 0;
	this.audio().play();
	return this;
};

MediaRecording.prototype.upload = async function (){
	await this.stop();
	
	if (!this._model) {
		// Create the filemodel
		let fid = this.api().db().files().generateId();
		this._model = this.api().db().files().build(
			{id: fid + '.' + this._ext,
			uid: this.api().uid(),
			type: this.mimeType(),
			state: 'streaming',
			size: 0,
			metadata: {
				constraints: this._constraints,
				chunkSize: this._chunkSize,
				bitsPerSecond: this._audioBitRate,
				mimeType: this.mimeType()
			// timeOffset: owner?.startTimeOffset
			}}
		);
		this._writer = this._model.createWriteStream(this.api());
		for (let i = 0, items = iter$(this._chunks), len = items.length; i < len; i++) {
			this._writer.write(items[i],this.api());
		};
		this._writer.close();
	};
	return this._model.upload();
};

MediaRecording.prototype.discard = function (){
	return this;
};

MediaRecording.prototype.teardown = function (){
	if (this._stream && !this._options.stream) {
		for (let i = 0, items = iter$(this._stream.getAudioTracks()), len = items.length, track; i < len; i++) {
			// window.MTR = track
			track = items[i];
			let ctr = track.getConstraints();
			// log "track with constraints",track,ctr
			window.CTR = ctr;
			track.stop();
		};
		this._stream = null;
	};
	return this;
};
