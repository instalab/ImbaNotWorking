function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), self = {};
var archiver = require("archiver");
var spaceAtIndex = require("./space-state").spaceAtIndex;
var db = require("../server/db").db;
var fs = require('fs');
var path = require('path');

var baseCSS = fs.readFileSync(__dirname + '/../scrimba/widgets/browser/normalize.css');

function PackageJSON(name){
	this._data = {name: name};
};

PackageJSON.prototype.addWebpack = function (){
	this.addDevDependency("webpack","^2.0");
	var scripts = (this._data.scripts == null) ? (this._data.scripts = {}) : this._data.scripts;
	scripts.build = "webpack";
	return scripts.watch = "webpack -w";
};

PackageJSON.prototype.addDevDependency = function (name,version){
	var deps = (this._data.devDependencies == null) ? (this._data.devDependencies = {}) : this._data.devDependencies;
	return deps[name] = version;
};

PackageJSON.prototype.addDependency = function (name,version){
	var deps = (this._data.dependencies == null) ? (this._data.dependencies = {}) : this._data.dependencies;
	return deps[name] = version;
};

PackageJSON.prototype.toString = function (){
	return JSON.stringify(this._data,null,2);
};

function WebpackConfig(){
	this._data = {
		output: {
			filename: '[name].pack.js'
		}
	};
	this._hasEntry = false;
	this._loaders = {};
};

WebpackConfig.prototype.hasEntry = function(v){ return this._hasEntry; }
WebpackConfig.prototype.setHasEntry = function(v){ this._hasEntry = v; return this; };

WebpackConfig.prototype.hasBabel = function (){
	return this._loaders.babel;
};

WebpackConfig.prototype.hasTypeScript = function (){
	return this._loaders.typescript;
};

WebpackConfig.prototype.toString = function (){
	var replacer = function(key,value) {
		if (value instanceof RegExp) {
			value = ("REG:::" + value + ":::EX");
		};
		return value;
	};
	var json = JSON.stringify(this._data,replacer,2);
	json = json.replace(/"REG:::(.*?):::EX"/g,function(m,inner) {
		return JSON.parse(("\"" + inner + "\""));
	});
	return ("module.exports = " + json + ";");
};

WebpackConfig.prototype.addEntry = function (name){
	var entry = (this._data.entry == null) ? (this._data.entry = {}) : this._data.entry;
	entry[name] = ("./" + name);
	this._hasEntry = true;
	return this;
};

WebpackConfig.prototype.addLoader = function (name,loaderConfig){
	if (this._loaders[name]) { return };
	this._loaders[name] = true;
	
	var module = (this._data.module == null) ? (this._data.module = {}) : this._data.module;
	var rules = (module.rules == null) ? (module.rules = []) : module.rules;
	rules.push(loaderConfig);
	return this;
};

WebpackConfig.prototype.addExtension = function (ext){
	var resolve = (this._data.resolve == null) ? (this._data.resolve = {}) : this._data.resolve;
	(resolve.extensions == null) ? (resolve.extensions = [".js",".json"]) : resolve.extensions;
	if (!(Imba.indexOf(ext,resolve.extensions) >= 0)) {
		return resolve.extensions.unshift(ext);
	};
};

WebpackConfig.prototype.addImba = function (){
	this.addExtension('.imba');
	this.addLoader('imba',{use: 'imba/loader',
	test: /\.imba$/});
	return this;
};

WebpackConfig.prototype.addBabel = function (){
	return this.addLoader('babel',{use: {
		loader: 'babel-loader',
		options: {
			presets: ['babel-preset-env','babel-preset-react']
		}
	},
	exclude: /node_modules/,
	test: /\.js$/});
};

WebpackConfig.prototype.addTypeScript = function (){
	this.addExtension('.ts');
	return this.addLoader('typescript',{use: {
		loader: 'ts-loader'
	},
	exclude: /node_modules/,
	test: /\.ts$/});
};

function SpaceArchiver(api,options){
	if(options === undefined) options = {};
	this._api = api;
	this._options = options;
	this._archive = archiver('zip');
};

SpaceArchiver.prototype.api = function(v){ return this._api; }
SpaceArchiver.prototype.setApi = function(v){ this._api = v; return this; };
SpaceArchiver.prototype.archive = function(v){ return this._archive; }
SpaceArchiver.prototype.setArchive = function(v){ this._archive = v; return this; };

SpaceArchiver.prototype.archiveSpace = async function (space,idx){
	await this.appendSpace(space,idx);
	this.archive().finalize();
	return true;
};

SpaceArchiver.prototype.fetchBlob = async function (blobId){
	var row = await db.table('blobs').where({id: blobId}).first('content');
	return row && row.content;
};

SpaceArchiver.prototype.injectNormalize = function (file){
	if (!file.body) { return };
	
	var normalizePath = path.relative(path.dirname(file.path),'/normalize.css');
	var linkTag = '<link rel="stylesheet" href="' + normalizePath + '">';
	var headTag = /<head\b[^>]*>/g;
	
	var body = file.body.replace(headTag,("$&" + linkTag));
	if (body == file.body) {
		// Replace didn't work
		body = ("<!DOCTYPE>" + linkTag + (file.body));
	};
	
	return file.body = body;
};


SpaceArchiver.prototype.appendSpace = async function (space,idx,prefix){
	var self = this, npmPackages_;
	if(prefix === undefined) prefix = "";
	var snapshot = await spaceAtIndex(self._api,space.id,idx,function(_0) { return _0.toRunStaticSnapshot(); });
	var directory = ("" + prefix + (space.owner().username) + "-" + (space.id) + "/");
	
	var readme = [];
	readme.push(("# " + (space.title)),"");
	
	var packageJson = new PackageJSON(space.id);
	var webpackConfig = new WebpackConfig();
	var requiresNormalize = false;
	
	var waitFor = [];
	
	var appendFile = function(file) {
		var fullPath = directory + file.path.slice(1);
		
		if (/\.imba$/.test(file.path)) {
			webpackConfig.addImba();
		} else if (/\.js$/.test(file.path)) {
			webpackConfig.addBabel();
		} else if (/\.ts$/.test(file.path)) {
			webpackConfig.addTypeScript();
		} else if (/\.html$/.test(file.path)) {
			self.injectNormalize(file);
			requiresNormalize = true;
		};
		
		var pushFile = function(body) {
			if (body) { return self.archive().append(body,{name: fullPath}) };
		};
		
		if (file.blobId) {
			var promise = self.fetchBlob(file.blobId).then(pushFile);
			return waitFor.push(promise);
		} else {
			pushFile(file.body);
			
			
			// Add entry points
			return file.body.replace(/\b(\w+)\.pack\.js\b/g,function(m,name) {
				let fullPath = path.join(file.path,'..',name);
				return webpackConfig.addEntry(fullPath.slice(1));
			});
		};
	};
	
	// Add all static files:
	for (let i = 0, items = iter$(snapshot.files), len = items.length; i < len; i++) {
		appendFile(items[i]);
	};
	
	// Add all dependencies:
	for (let i = 0, items = iter$((npmPackages_ = snapshot.npmPackages) && npmPackages_.resolved), len = items.length, dep; i < len; i++) {
		dep = items[i];
		var name = dep.match(/.[^@]*/)[0];
		var version = dep.substr(len$(name) + 1);
		packageJson.addDependency(name,version);
	};
	
	if (requiresNormalize) {
		self.archive().append(baseCSS,{name: directory + 'normalize.css'});
	};
	
	// Add webpack:
	if (webpackConfig.hasEntry()) {
		packageJson.addWebpack();
		
		if (webpackConfig.hasBabel()) {
			packageJson.addDevDependency("babel-core","^6.0");
			packageJson.addDevDependency("babel-loader","^7.0");
			packageJson.addDevDependency("babel-preset-env","*");
			packageJson.addDevDependency("babel-preset-react","*");
		};
		
		if (webpackConfig.hasTypeScript()) {
			packageJson.addDevDependency("ts-loader","*");
			packageJson.addDevDependency("typescript","*");
		};
		
		self.archive().append(webpackConfig.toString(),{name: directory + 'webpack.config.js'});
		
		// TODO: Does it ever make sense to have package.json without webpack.config.js?
		self.archive().append(packageJson.toString(),{name: directory + 'package.json'});
		
		readme.push("Quick start:","");
		readme.push("```");
		readme.push("$ npm install");
		readme.push("$ npm run build");
		readme.push("````","");
		readme.push("## Development","");
		readme.push("Run Webpack in watch-mode to continually compile the JavaScript as you work:","");
		readme.push("```");
		readme.push("$ npm run watch");
		readme.push("```");
	};
	
	self.archive().append(readme.join("\n") + "\n",{name: directory + 'README.md'});
	
	
	return Promise.all(waitFor);
};

exports.archiveSpace = self.archiveSpace = function (api,output,space,idx){
	var spaceArchiver = new SpaceArchiver(api);
	spaceArchiver.archive().pipe(output);
	return spaceArchiver.archiveSpace(space,idx);
};
