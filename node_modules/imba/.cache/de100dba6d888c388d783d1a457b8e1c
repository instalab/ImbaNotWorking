function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba'), _1 = Imba.createElement;
var protocol$ = require('../protocol'), SCON = protocol$.SCON, DIRTY = protocol$.DIRTY, ACTION = protocol$.ACTION;

var SpaceViewHeader = require('./SpaceViewHeader').SpaceViewHeader;
var EditorView = require('./EditorView').EditorView;

var Delay = require('../../util/Delay').Delay;
var PointerView = require('./PointerView').PointerView;
var BrushupView = require('./BrushupView').BrushupView;

var BranchesListView = require('./BranchesListView').BranchesListView;

var Notification = require('./Notification').Notification;

// Dialogs
var SpaceMenu = require('./SpaceMenu').SpaceMenu;
var RecDialog = require('./RecDialog').RecDialog;
var SaveDialog = require('./SaveDialog').SaveDialog;
var PublishDialog = require('./PublishDialog').PublishDialog;
var NewFileDialog = require('./NewFileDialog').NewFileDialog;
var GroupJoinDialog = require('../../site/components/GroupJoinDialog').GroupJoinDialog;
var CastCreateDialog = require('../../site/components/CastCreateDialog').CastCreateDialog;
var DependencyAddDialog = require('./DependencyAddDialog').DependencyAddDialog;
var AskDialog = require('./AskDialog').AskDialog;

var BrushupView = require('./BrushupView').BrushupView;

var InterfaceView = require('./InterfaceView').InterfaceView;
var EditorView = require('./EditorView').EditorView;
var ExplorerView = require('./ExplorerView').ExplorerView;
var SidebarView = require('./SidebarView').SidebarView;
var TitlebarView = require('./TitlebarView').TitlebarView;

var SpaceDrawer = require('./SpaceDrawer').SpaceDrawer;

var PlaybackOverlay = require('./PlaybackOverlay').PlaybackOverlay;

var Cast = require('../../models/Cast').Cast;

var util = require('../util');

Mousetrap = require('../../util/mousetrap');

if (false) {};

var ViewportOverlay = Imba.defineTag('ViewportOverlay', InterfaceView, function(tag){
	
	tag.prototype.render = function (){
		var $ = this.$;
		return this.$open(0).setChildren(
			$[0] || _1('div',$,0,this).flag('PlayButton').flag('button').setNestedAttr('uxa','action','play').setContent(
				$[1] || _1('i',$,1,0).flag('scrimbacon').dataset('icon','play')
			,2)
		,2).synced((
			$[0].end((
				$[1].end()
			,true))
		,true));
	};
});


var SpaceViewport = Imba.defineTag('SpaceViewport', function(tag){
	
	tag.prototype.build = function (){
		var v_;
		return (this.setTabindex(v_ = -1),v_);
	};
});

var LogEntry = require('../widgets/browser/PlayerPage').LogEntry;

// Refactor to use Notification api
var LogEntryTip = Imba.defineTag('LogEntryTip', function(tag){
	
	var currentTip;
	
	tag.show = function (items,target){
		if (currentTip) {
			currentTip.hide();
			currentTip = null;
		};
		return Imba.mount(currentTip = (_1(LogEntryTip)).setData(items).setContainer(target).end(),target);
	};
	
	tag.prototype.container = function(v){ return this._container; }
	tag.prototype.setContainer = function(v){ this._container = v; return this; };
	
	tag.prototype.render = function (){
		var $ = this.$;
		return this.$open(0).flag('xl').flag('dark').setChildren(
			$[0] || _1('div',$,0,this).flag('main')
		,2).synced((
			$[0].setContent([
				($[1] || _1('div',$,1,0).flag('triangle')),
				(len$(this.data()) > 1) ? (
					($[2] || _1('div',$,2,0).flag('more').setText("..."))
				) : void(0),
				($[3] || _1(LogEntry,$,3,0)).bindData(this.data(),len$(this.data()) - 1).end()
			],1)
		,true));
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self.dom().offsetWidth;
		self.flag('show');
		return setTimeout(function() { return self.hide(); },2500);
	};
	
	tag.prototype.setup = function (){
		this.render();
		return this.autosize();
	};
	
	tag.prototype.autosize = function (){
		var Math_;
		let txt = this.dom().innerText;
		let lines = txt.split("\n");
		let longest = Math.max.apply(Math,lines.map(function(l) { return l.length; }));
		let maxWidth = this.container().offsetWidth * 0.8;
		// fontSize to fill
		let maxFont = maxWidth / (longest * 0.6);
		// console.log "autosize?",txt,longest,maxFont
		let fontSize = Math.round(Math.min(Math.max(maxFont,15),30));
		this.css('fontSize',fontSize + 'px');
		this.flag('overflows',maxFont < 15);
		return this;
	};
	
	// def ontap
	// 	self:hide = do yes
	
	tag.prototype.hide = function (){
		var self = this;
		if (self.hasFlag('hide')) { return };
		self.flag('hide');
		return setTimeout(function() {
			self.orphanize();
			if (currentTip == self) { return currentTip = null };
		},3000);
	};
});

var SpaceView = Imba.defineTag('SpaceView', function(tag){
	
	tag.prototype.dirty = function(v){ return this._dirty; }
	tag.prototype.setDirty = function(v){ this._dirty = v; return this; };
	tag.prototype.__activeNode = {watch: 'activeNodeDidSet',name: 'activeNode'};
	tag.prototype.activeNode = function(v){ return this._activeNode; }
	tag.prototype.setActiveNode = function(v){
		var a = this.activeNode();
		if(v != a) { this._activeNode = v; }
		if(v != a) { this.activeNodeDidSet && this.activeNodeDidSet(v,a,this.__activeNode) }
		return this;
	};
	tag.prototype.__activeWidget = {watch: 'activeWidgetDidSet',name: 'activeWidget'};
	tag.prototype.activeWidget = function(v){ return this._activeWidget; }
	tag.prototype.setActiveWidget = function(v){
		var a = this.activeWidget();
		if(v != a) { this._activeWidget = v; }
		if(v != a) { this.activeWidgetDidSet && this.activeWidgetDidSet(v,a,this.__activeWidget) }
		return this;
	};
	tag.prototype.shortcuts = function(v){ return this._shortcuts; }
	tag.prototype.setShortcuts = function(v){ this._shortcuts = v; return this; };
	
	tag.prototype.__showInspector = {watch: 'markLayout',name: 'showInspector'};
	tag.prototype.showInspector = function(v){ return this._showInspector; }
	tag.prototype.setShowInspector = function(v){
		var a = this.showInspector();
		if(v != a) { this._showInspector = v; }
		if(v != a) { this.markLayout && this.markLayout(v,a,this.__showInspector) }
		return this;
	};
	tag.prototype.__showNavDrawer = {watch: 'markLayout',name: 'showNavDrawer'};
	tag.prototype.showNavDrawer = function(v){ return this._showNavDrawer; }
	tag.prototype.setShowNavDrawer = function(v){
		var a = this.showNavDrawer();
		if(v != a) { this._showNavDrawer = v; }
		if(v != a) { this.markLayout && this.markLayout(v,a,this.__showNavDrawer) }
		return this;
	};
	tag.prototype.__mode = {watch: 'modeDidSet',name: 'mode'};
	tag.prototype.mode = function(v){ return this._mode; }
	tag.prototype.setMode = function(v){
		var a = this.mode();
		if(v != a) { this._mode = v; }
		if(v != a) { this.modeDidSet && this.modeDidSet(v,a,this.__mode) }
		return this;
	};
	tag.prototype.__size = {'default': 'auto',watch: 'sizeDidSet',name: 'size'};
	tag.prototype.size = function(v){ return this._size; }
	tag.prototype.setSize = function(v){
		var a = this.size();
		if(v != a) { this._size = v; }
		if(v != a) { this.sizeDidSet && this.sizeDidSet(v,a,this.__size) }
		return this;
	}
	tag.prototype._size = 'auto';
	
	tag.prototype.tab = function(v){ return this._tab; }
	tag.prototype.setTab = function(v){ this._tab = v; return this; }; // hacky way to highlight tab
	
	tag.prototype.__fontSize = {'default': 12,watch: 'fontSizeDidSet',name: 'fontSize'};
	tag.prototype.fontSize = function(v){ return this._fontSize; }
	tag.prototype.setFontSize = function(v){
		var a = this.fontSize();
		if(v != a) { this._fontSize = v; }
		if(v != a) { this.fontSizeDidSet && this.fontSizeDidSet(v,a,this.__fontSize) }
		return this;
	}
	tag.prototype._fontSize = 12;
	tag.prototype.__userFontSize = {watch: 'userFontSizeDidSet',name: 'userFontSize'};
	tag.prototype.userFontSize = function(v){ return this._userFontSize; }
	tag.prototype.setUserFontSize = function(v){
		var a = this.userFontSize();
		if(v != a) { this._userFontSize = v; }
		if(v != a) { this.userFontSizeDidSet && this.userFontSizeDidSet(v,a,this.__userFontSize) }
		return this;
	};
	tag.prototype.__sidebarWidth = {watch: 'syncStyleVar',unit: 'px',reflow: true,name: 'sidebarWidth'};
	tag.prototype.sidebarWidth = function(v){ return this._sidebarWidth; }
	tag.prototype.setSidebarWidth = function(v){
		var a = this.sidebarWidth();
		if(v != a) { this._sidebarWidth = v; }
		if(v != a) { this.syncStyleVar && this.syncStyleVar(v,a,this.__sidebarWidth) }
		return this;
	};
	
	tag.prototype.syncStyleVar = function (value,prev,key){
		let name = key.name;
		let unit = key.unit;
		this.dom().style.setProperty('--' + name,unit ? ((value + unit)) : value);
		if (key.reflow) { return this.space().emit('reflow') };
	};
	
	tag.prototype.userFontSizeDidSet = function (size){
		return (this.setFontSize(size),size);
	};
	
	tag.prototype.fontSizeDidSet = function (size){
		this.setFlag('fontSize',("fs" + size));
		if (this._mounted) { return this.reflow() };
	};
	
	tag.prototype.hasTouchInterface = function (){
		return this.hasFlag('touch-ux');
	};
	
	tag.prototype.space = function (){
		return this.data();
	};
	
	tag.prototype.browser = function (){
		return this.space().browser();
	};
	
	tag.prototype.model = function (){
		return this.space().model();
	};
	
	tag.prototype.branch = function (){
		return this.space().branch();
	};
	
	tag.prototype.timeline = function (){
		return this.space().timeline();
	};
	
	tag.prototype.client = function (){
		return this.data().client();
	};
	
	tag.prototype.setup = function (){
		this._autoFontSize = 12;
		this._dirty = DIRTY.SIZE;
		
		if (false) {};
		return this;
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self._mounted = true;
		self.setTabindex(0);
		// size = 'auto'
		self.space().emit('mounted');
		
		document.title = self.data().model().title;
		
		self._onresized = new Delay(function() {
			self._dirty |= DIRTY.SIZE;
			return self.reflow();
		});
		
		self._onresize = function() {
			self._resized = true;
			return self._onresized.delay(200);
		};
		
		self._onreflow = function() {
			self._resized = false;
			return self.reflow();
		};
		
		window.addEventListener('resize',self._onresize,true);
		window.addEventListener('orientationchange',self._onreflow,true);
		self.api().on('reflow',self._onreflow);
		
		if (self.api().isEmbed() && !(self.playerjsBridge()) && self.space().timeline().audio) {
			self.setPlayerjsBridge({});
			setTimeout(function() {
				if (self.space().timeline().audio()) {
					self.setPlayerjsBridge(new (self.playerjs().HTML5Adapter)(self.space().timeline().audio()));
					return self.playerjsBridge().ready();
				};
			},10);
		};
		
		// if model.group and !model.group.membership(api.uid)
		//	uxa.open <GroupJoinDialog[model.group].modal cast=model dismissable=no>	
		self.mountLogAlerts();
		return self;
	};
	
	tag.prototype.mountLogAlerts = function (){
		var self = this;
		let logs = [];
		let showLogs = function() {
			let last = logs[logs.length - 1];
			let currOffset = self.space().timeline().currentOffset();
			if (last && Math.abs(currOffset - last.timeOffset()) < 1000) {
				LogEntryTip.show(logs.map(function(item) { return item._params; }),self._viewport.dom());
			};
			return logs = [];
		};
		
		return self.space().on('log',function(item) {
			logs.push(item);
			return logs.TIMEOUT || (logs.TIMEOUT = setTimeout(showLogs,15));
		});
	};
	
	tag.prototype.unmount = function (){
		var space_;
		(space_ = this.space()) && space_.emit  &&  space_.emit('unmounted');
		window.removeEventListener('resize',this._onresize,true);
		window.removeEventListener('orientationchange',this._onreflow,true);
		this.api().un('reflow',this._onreflow);
		
		if (this._modeNotification) {
			this._modeNotification.hide();
			this._modeNotification = null;
		};
		return this;
	};
	
	tag.prototype.dispose = function (){
		var self = this;
		self._activeEl = null;
		self._controls && self._controls.dispose  &&  self._controls.dispose();
		self._shortcuts && self._shortcuts.disable  &&  self._shortcuts.disable();
		self._shortcuts = null; // ?.dispose
		self.render = function() { return self; };
		// Fix to make sure tweenmax removes the last reference
		// TweenMax.to(document.createElement('div'),0.1,{opacity: 0.1})
		return self;
	};
	
	tag.prototype.alert = function (text,options){
		// automatically hide if already shown?
		return Notification.show(text,options);
	};
	
	tag.prototype.box = function (){
		return this._box || (this._box = {
			top: 0,
			left: 0,
			width: window.innerWidth,
			height: window.innerHeight
		});
	};
	
	tag.prototype.modeDidSet = function (mode,prev){
		// console.log "changed mode",mode,prev
		
		if (this._modeNotification) {
			this._modeNotification.hide();
			this._modeNotification = null;
		};
		
		let text;
		if (mode == 'paused' && prev == 'playing' && this.space().timeline().progress() < 0.99) {
			text = "_pause_ paused";
		} else if (mode == 'playing' && prev == 'paused' && this.space().timeline().currentTime() > 50) {
			text = "_play_ resumed";
		} else if (mode == 'editing' && this.branch().isLocal()) {
			text = "Entered playground mode â€“ click _play_ to resume watching";
			return this.alert(this._modeNotification = (_1(Notification).flag('info').flag('l').setSticky(true)).setText(text).end());
		};
		
		if (text) {
			return this.alert(this._modeNotification = (_1(Notification).flag('system')).setText(text).end());
		};
	};
	
	
	tag.prototype.checkActiveWidget = function (){
		var v_;
		var el = document.activeElement;
		if (el && el._tag && this._viewport.contains(el)) {
			return (this.setActiveWidget(v_ = util.callClosest(el._tag,'focusWidgetForNode')),v_);
		};
	};
	
	tag.prototype.activeNodeDidSet = function (node,prev){
		// log "activeNodeDidSet",node,prev
		var v_;
		if (node && this._viewport.contains(node)) {
			return (this.setActiveWidget(v_ = util.callClosest(node,'focusWidgetForNode')),v_);
		};
	};
	
	tag.prototype.activeWidgetDidSet = function (widget,prev){
		this.log("activeWidgetDidSet",widget && widget.TYPE,prev && prev.TYPE);
		if (prev) { this._prevActiveWidget = prev };
		this.space().agent().setFocus(widget);
		if (!this.browser().windowed()) {
			if (widget == this.browser()) { (this.browser().setMinimized(false),false) };
			if (prev == this.browser()) { return (this.browser().setMinimized(true),true) };
		};
	};
	
	tag.prototype.sizeDidSet = function (size,prev){
		this.setFlag('size',("size-" + size));
		this.flagIf('centered',size && size != 'auto');
		if (this._mounted) { return this.reflow() };
	};
	
	tag.prototype.checkActiveElement = function (){
		this.setActiveNode(Imba.getTagForDom(document.activeElement));
		return this;
	};
	
	tag.prototype.focusViewport = function (){
		if (!this._viewport.contains(document.activeElement)) {
			this._viewport.dom().focus();
		};
		return this;
	};
	
	tag.prototype.reflow = function (){
		var self = this;
		var el = self._viewport && self._viewport.dom();
		
		if (!el) { return };
		if (self._reflowing) { return };
		
		var box = self._box;
		var bounds = el.getBoundingClientRect();
		var ow = bounds.width;
		var oh = bounds.height;
		
		if (ow == 0) { return };
		
		self._reflowing = true;
		
		// round numbers
		self._box = {
			top: Math.round(bounds.top), // (el:offsetTop + dom:offsetTop + par:offsetTop)
			left: Math.round(bounds.left), // (el:offsetLeft + dom:offsetLeft + par:offsetLeft)
			width: Math.round(bounds.width), // ow
			height: Math.round(bounds.height) // oh
		};
		
		// should use userFontSize as well?
		let prevAutoFontSize = self._autoFontSize;
		self._autoFontSize = (ow < 500) ? 10 : (((ow < 900) ? 11 : (((ow < 1280) ? 12 : 13))));
		if (self.fontSize() == prevAutoFontSize) {
			self.setFontSize(self._autoFontSize);
		};
		
		self._dirty |= DIRTY.SIZE;
		
		var area = ow * oh;
		
		if (area > 0 && area < 360000 && !self.hasFlag('touch-ux')) {
			self.flag('touch-controls');
		};
		
		self.flag('touch-ux',area < 360000 && 'ontouchstart' in window);
		self.flag('portrait',oh >= ow);
		self.flag('landscape',oh < ow);
		self.flag('sidebar-float',ow < 700);
		
		if (self._dirty) {
			self.flag('reflowing');
			clearTimeout(self._reflowTimeout);
			self._reflowTimeout = setTimeout(function() {
				return self.unflag('reflowing');
			},300);
		};
		
		// include viewport size in stream
		self.space().agent().setVw(self._box.width);
		self.space().agent().setVh(self._box.height);
		
		self.space().emit('resize'); // what if it was not resized?
		self.space().emit('reflow',self._dirty);
		self.space().emit('resized');
		
		self._dirty = 0;
		self._reflowing = false;
		return self;
	};
	
	
	tag.prototype.onfocusin = function (e){
		return;
	};
	
	tag.prototype.onfocusout = function (e){
		return;
	};
	
	tag.prototype.getStyleVar = function (varname){
		var cs = window.getComputedStyle(this.dom());
		var val = cs.getPropertyValue('--' + varname);
		return val;
	};
	
	tag.prototype.setStyleVar = function (varname,value){
		this.dom().style.setPropertyValue('--' + varname,value);
		return this;
	};
	
	tag.prototype.targetForPointer = function (el){
		let browser = this.space().browser();
		
		// always keep pointer-focus on browser when it is front and center
		if (this.space().agent().focus() == browser && !browser.windowed() && !browser.minimized() && !browser.node().contains(el)) {
			return browser.node();
		};
		
		let target = el.closest('[data-sref]');
		return target ? ((target._tag || target)) : null;
		// return target ? SCON.strToPath(target:dataset:ref) : null
	};
	
	tag.prototype.lookup = function (key){
		if (key instanceof Element) {
			return key._tag;
		};
		
		if (key instanceof Imba.Tag) {
			return key;
		};
		
		if (!((typeof key=='string'||key instanceof String))) {
			key = SCON.pathToStr(key);
		};
		
		let target = this.dom().querySelector(("[data-sref=\"" + key + "\"]"));
		// log "lookup",key,target
		return target ? target._tag : null;
	};
	
	tag.prototype.layoutForNode = function (node){
		var $1;
		if (!((node instanceof Imba.Tag))) { return null };
		
		if (node.nodeForLayout) {
			node = node.nodeForLayout();
		};
		
		if (node.layoutForNode) {
			return node.layoutForNode(this);
		};
		
		var el = node._dom || node; // should be possible to force?
		
		if (!this.dom().contains(el)) {
			return null;
		};
		
		// should we cache?
		let rect = el.getBoundingClientRect();
		
		let layout = [
			Math.round(rect.top - this.box().top),
			Math.round(rect.left - this.box().left),
			Math.round(rect.width),
			Math.round(rect.height),
			(($1 = node) && $1.layoutMask  &&  $1.layoutMask() || 0)
		];
		return layout;
	};
	
	
	tag.prototype.pushNodeLayout = function (node,layout){
		// only if element has a reference?
		if (!this.space().isEditing()) { return };
		
		var sref = node.sref();
		layout || (layout = this.layoutForNode(node));
		
		var existing = this.space().branch().stream().layouts()[sref];
		
		if (String(layout) != String(existing)) {
			this.log("force add layout!",sref,layout,existing);
			this.branch().push_(ACTION.NODE_LAYOUT,[sref,layout],{});
		};
		return node;
	};
	
	tag.prototype.oncontextmenu = function (e){
		return e.prevent().halt();
	};
	
	// action handlers
	tag.prototype.onannotate = function (e,branch){
		e.stop();
		branch.startAnnotating();
		return this.dom().focus();
		// let mode = @brushup = <BrushupView[space].abs enabled=yes>
		// uxa.open(mode)
	};
	
	tag.prototype.onask = function (e){
		e.halt();
		return this._drawer && this._drawer.onask  &&  this._drawer.onask(e);
	};
	
	tag.prototype.onbrushupstop = function (e){
		e.halt();
		return this.branch().stopAnnotating();
		// if @brushup
		// 	@brushup.unschedule
		// 	@brushup.trigger('uxa:hide')
		// 	@brushup = null
	};
	
	tag.prototype.oneditstart = function (e,branch){
		branch.startEditing();
		return e.halt();
	};
	
	tag.prototype.oneditstop = function (e,branch){
		e.halt();
		return branch.stopEditing();
	};
	
	tag.prototype.onrecstart = function (e,branch){
		e.halt();
		branch.space().navigateTo(branch);
		return this.uxa().open((_1(RecDialog)).setData(branch).end());
	};
	
	tag.prototype.onrecstop = function (e,branch){
		e.halt();
		branch.stopRecording();
		return this;
	};
	
	tag.prototype.onspacezip = function (e){
		e.halt();
		let index = this.space().cursor().current().index();
		if (!this.space().branch().isLocal()) {
			this.uxa().flash("Generating .zip");
			return window.location = ("/casts/" + (this.space().branch().id()) + ".zip?index=" + index);
		} else {
			return this.uxa().flash("You need to save before downloading .zip");
		};
	};
	
	tag.prototype.onspaceclone = async function (e){
		var params = this.space().clone();
		this.log('onspaceclone',e,params);
		await this.api().tryLogin();
		if (!this.api().user()) { return };
		return this.uxa().open((_1(CastCreateDialog)).setData(params).end());
	};
	
	tag.prototype.onspacemenu = function (e){
		e.halt();
		return e.uxa().open((_1(SpaceMenu)).bindData(this,'space',[]).end());
	};
	
	tag.prototype.onshowannotation = function (e,annotation){
		e.halt();
		return (this.space().setAnnotation(annotation),annotation);
	};
	
	tag.prototype.onbranchsave = async function (e,branch){
		var v_;
		e.halt();
		this.log('onbranchsave',branch);
		await this.api().tryLogin();
		if (!this.api().user()) { return };
		
		if (branch.isLocal()) {
			// make sure note is private
			if (branch.type() == 'note') {
				branch.model().privacy = 'private';
			};
			return branch.save();
		};
		
		// <CastCreateDialog[params]>
		var params = SCON.clone(branch.model());
		params.stream = branch.model().stream().toJSON();
		params.snapshot = branch._initialSnapshot;
		(((v_ = params.id),delete params.id, v_));
		this.log("params is",params);
		return this.uxa().open((_1(CastCreateDialog)).setData(params).end());
	};
	
	tag.prototype.onbranchdiscard = function (e,branch){
		e.halt();
		branch.discard();
		return this;
	};
	
	tag.prototype.onbranchpublish = function (e,branch){
		e.halt();
		return this.uxa().open((_1(PublishDialog)).setData(branch).end());
	};
	
	tag.prototype.onbranchenter = function (e,branch){
		e.halt();
		return this.space().navigateTo(branch);
	};
	
	tag.prototype.onbranchdelete = async function (e,branch){
		e.halt();
		var ok = await e.uxa().confirm(("Are you sure you want to delete '" + (branch.title()) + "'?"));
		if (!ok) { return };
		
		if (this.space().branch() == branch) {
			this.space().navigateTo(this.space().trunk());
		};
		
		return await branch.model().update({archived_at: new Date()});
	};
	
	tag.prototype.onnotedel = async function (e,note){
		e.halt();
		
		var ok = await e.uxa().confirm(("Are you sure you want to delete '" + (note.title) + "'?"));
		if (!ok) { return };
		
		// set archived archived_at
		if (this.space().branch().model() == note) {
			this.space().navigateTo(this.space().trunk());
		};
		
		await note.destroy();
		return this;
	};
	
	tag.prototype.onnotediscard = async function (e,note){
		e.halt();
		let branch = await this.space().resolveBranchForModel(note);
		if (branch && note.isLocal()) {
			return branch.discard();
		};
	};
	
	tag.prototype.onnotesave = async function (e,note){
		e.halt();
		let branch = await this.space().resolveBranchForModel(note);
		return this.onbranchsave(e,branch);
	};
	
	tag.prototype.onbrowsertoggle = function (e){
		e.halt();
		if (this.space().simulator()) {
			this.space().simulator().setVisible(false);
		};
		this.space().browser().setVisible(!this.space().browser().visible());
		return this;
	};
	
	tag.prototype.onconsoletoggle = function (e){
		var v_;
		e.halt();
		return (this.space().console().setEnabled(v_ = !this.space().console().enabled()),v_);
	};
	
	tag.prototype.onbrowserrun = function (e){
		// log 'onbrowserrun',e
		e.halt();
		this.space().browser().run();
		return this;
	};
	
	tag.prototype.onnewfile = function (e){
		e.halt();
		return this.uxa().open((_1(NewFileDialog)).bindData(this,'space',[]).end());
	};
	
	tag.prototype.onplay = function (e){
		e.halt();
		var tl = this.space().timeline();
		if (tl.isPaused()) {
			tl.play();
			return this.trigger('spaceplay');
		};
	};
	
	tag.prototype.ontoggleplayback = function (e,timeline){
		e.halt();
		var tl = timeline || this.space().timeline();
		
		if (tl.isPlaying()) {
			tl.pause();
			return this.trigger('spacepaused');
		} else if (tl.isPaused()) {
			tl.play();
			// should happen when playing through other means as well?
			return this.trigger('spaceplay');
		};
	};
	
	tag.prototype.resume = function (){
		if (this.space().timeline().isPaused()) {
			this.space().timeline().play();
			this.trigger('spaceplay');
			this.dom().focus();
		};
		return this;
	};
	
	tag.prototype.ondependencyadd = function (e){
		e.halt();
		this.log("ondependencyadd");
		return this.uxa().open((_1(DependencyAddDialog)).bindData(this,'space',[]).end());
	};
	
	tag.prototype.oncontrolsevent = function (e){
		if (e.event() instanceof Event) {
			return;
		};
		
		return e.redirect(this);
	};
	
	tag.prototype.onactionevent = function (e){
		// redirect the custom events to this view
		if (e.event() instanceof Event) { return };
		return e.redirect(this);
	};
	
	tag.prototype.ontoggledrawer = function (e){
		e.halt();
		return this._drawer.toggle();
	};
	
	tag.prototype.onimportslides = function (e){
		e.halt();
		var url = window.prompt("Link to presentation");
		if (url && url.match(/google\.com(.*)\/pub/)) {
			return this.space().slides().importFromGoogleSlides(url);
		} else {
			return this.uxa().flash("Link must be to a 'Publish to the web' link from Google Slides");
		};
	};
	
	tag.prototype.onreimportslides = function (e){
		e.halt();
		if (this.space().slides().url()) {
			return this.space().slides().importFromGoogleSlides(this.space().slides().url());
		};
	};
	
	tag.prototype.ongoto = function (e,target){
		e.halt();
		// log 'ongoto',target
		return this.space().navigateTo(target);
	};
	
	tag.prototype.markLayout = function (value,prev,desc){
		this.flag(desc.name,!!value);
		return this._dirty |= DIRTY.LAYOUT;
	};
	
	tag.prototype.synced = function (){
		tag.prototype.__super__.synced.apply(this,arguments);
		if (this._dirty || !this._ow) {
			this.reflow();
		};
		return this;
	};
	
	tag.prototype.editor = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._editor || (this._editor = this._editor||_1(EditorView,this).flag('editor')).bindData(this.space(),'primaryEditor',[]).end();
	};
	
	tag.prototype.drawer = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._drawer || (this._drawer = this._drawer||_1(SpaceDrawer,this).flag('drawer')).bindData(this.space(),'model',[]).setSpace(this.space()).end();
	};
	
	tag.prototype.titlebar = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._titlebar || (this._titlebar = this._titlebar||_1(TitlebarView,this).flag('titlebar').setEnabled(true)).bindData(this,'space',[]).end();
	};
	
	tag.prototype.sidebar = function (){
		let $ = this.$$ || (this.$$ = {});
		return this._sidebar || (this._sidebar = this._sidebar||_1(SidebarView,this).flag('sidebar')).bindData(this.space(),'sidebar',[]).end();
	};
	
	tag.prototype.render = function (){
		var $ = this.$, simulator_, t0;
		if (true) { return this };
		if (this.data().readyState() == 'init' || this.data().readyState() == 'disposing') { return this };
		
		let isReady = this.data().readyState() == 'complete';
		
		if (isReady) {
			this.flag('browser-on',this.data().browser().visible());
			this.flag('simulator-on',(simulator_ = this.data().simulator()) && simulator_.enabled  &&  simulator_.enabled());
			
			this.setShowInspector(this.data().console().enabled());
			this.setShowNavDrawer(this.drawer().enabled());
			this.setMode(this.space().timeline().playState());
			
			// setFlag('focus',"focus-{data.agent.focus and data.agent.focus.TYPE}")
			this.flag('play',this.data().timeline().isPlaying());
			this.setFlag('playstate',"ps-" + this.data().timeline().state());
			this.flag('is-annotating',this.branch().isAnnotating());
			this.flag('ws-unstable',this.branch().syncer().latency() > 1500);
			this.flag('can-edit',this.branch().canEdit());
			this.flag('unsaved',this.branch().isLocal());
			this.flag('mine',this.branch().isMine());
			
			this.setSidebarWidth(this.space().sidebar().width());
			this.checkActiveElement();
		};
		
		if (this.space()._isNavigating) { return };
		
		return this.$open(0).flag('resize').flag('night').setFlag(-1,("trunk-" + (this.space().trunk().type()))).setFlag(-2,this.space().state()).setFlag(-3,this.space().branch().type()).setChildren([
			this.drawer().end(),
			(t0 = this._viewport = this._viewport||(t0=_1(SpaceViewport,this)).flag('viewport')).setContent([
				this.titlebar().end(),
				this.editor().end(),
				this.space().inspector().node().end(),
				this.sidebar().end(),
				
				(isReady && this.space().simulator()) ? (
					this.space().simulator().node().end()
				) : void(0),
				
				this.space().browser().node().end(),
				// these should be register by the widgets themselves instead
				this.space().slides().node().end(),
				(this._pointer = this._pointer||_1(PointerView,t0).flag('pointer')).bindData(this,'space',[]).end(),
				
				(this.space().type() == 'tutorial') ? (
					($[0] || _1(ViewportOverlay,$,0,t0)).bindData(this,'space',[]).setEnabled((this.space().timeline().currentTime() == 0 && this.space().isPaused() && this.branch() == this.space().trunk())).end()
				) : void(0),
				
				(this.space().type() == 'lab') ? (
					($[1] || _1(BranchesListView,$,1,t0)).bindData(this.space(),'model',[]).setSpace(this.space()).end()
				) : void(0)
			],1).end(),
			this.branch().isAnnotating() ? (
				($[2] || _1(BrushupView,$,2,this).setEnabled(true)).bindData(this,'space',[]).end()
			) : void(0),
			($[3] || _1(PlaybackOverlay,$,3,this)).bindData(this,'space',[]).end()
		],1).synced();
	};
})
exports.SpaceView = SpaceView;


