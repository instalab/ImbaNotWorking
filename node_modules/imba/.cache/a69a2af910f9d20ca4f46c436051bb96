function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');
var protocol$ = require('../protocol'), ACTION = protocol$.ACTION, LAYOUTMASK = protocol$.LAYOUTMASK;
var MonacoView = require('./MonacoView').MonacoView;
var Keyboard = require('../widgets/terminal/keyboard').Keyboard;
var stylingToClassName = require('../widgets/terminal/styles').stylingToClassName;
var TextModel = require('../util/TextModel').TextModel;

// externs;
let terminalCount = 0;

if (false) {};

function MonacoTerminalModel(widget,editor,screen){
	var self = this;
	self._widget = widget;
	self._editor = editor;
	self._screen = screen;
	self._screen._monaco = self;
	self._version = self._row = self._col = -1;
	var uri = monaco.Uri.parse(("term" + (self.space().namespace()) + "/" + (terminalCount++)));
	self._monaco = monaco.editor.createModel(self.rawBody(),null,uri);
	self._differ = new TextModel('');
	self._decorations = [];
	self._carets = [];
	// TODO share selections implementations with FileModel
	self._selections = [];
	self._versions = {selections: -1};
	self.space().once('dispose',function() { return self.dispose(); });
	self;
};

MonacoTerminalModel.prototype.widget = function(v){ return this._widget; }
MonacoTerminalModel.prototype.setWidget = function(v){ this._widget = v; return this; };
MonacoTerminalModel.prototype.monaco = function(v){ return this._monaco; }
MonacoTerminalModel.prototype.setMonaco = function(v){ this._monaco = v; return this; };
MonacoTerminalModel.prototype.screen = function(v){ return this._screen; }
MonacoTerminalModel.prototype.setScreen = function(v){ this._screen = v; return this; };

MonacoTerminalModel.prototype.space = function (){
	return this._widget.space();
};

MonacoTerminalModel.prototype.monacoModel = function (){
	return this._monaco;
};

MonacoTerminalModel.prototype.changed = function (key){
	let v = this.widget().options().version(key);
	if (this._versions[key] != v) {
		this._versions[key] = v;
		return true;
	};
	return false;
};

MonacoTerminalModel.prototype.rawBody = function (){
	var body = "";
	
	for (let idx = 0, items = iter$(this.screen().lines()), len = items.length; idx < len; idx++) {
		if (idx > 0) {
			body += "\n";
		};
		body += items[idx].text();
	};
	return body;
};

MonacoTerminalModel.prototype.willDetach = function (){
	this._row = this._col = -1;
	return this;
};

MonacoTerminalModel.prototype.didAttach = function (){
	// set scrollTop?
	return this;
};

MonacoTerminalModel.prototype.sync = function (){
	var diff = null;
	var t = Date.now();
	var dirty = this.screen().version() != this._version;
	
	if (dirty) {
		this._version = this.screen().version();
		
		var lines = this.screen().lines();
		var slines = this.screen().lines();
		var mlines = this._monaco._lines;
		var startLine = Math.max(0,Math.min(slines.length,mlines.length) - this.screen().height());
		
		this._differ._lines = lines.map(function(ln) { return ln._text; });
		diff = this._differ.getDiff(mlines);
	};
	
	// console.log "diff!",diff
	
	if (diff) { // for now - we only change decorations if there are changes as well
		this._monaco.applyEdits([{range: this.monacoBridge().arrayToRange(diff[0]),text: diff[1]}]);
	};
	
	if (dirty) {
		var newDecorations = [];
		var startPos = [1,1];
		// var currentStyle = TextStyling.DEFAULT
		// Next build up the decorators
		var currentStyle = [null,null,0]; // TextStyling.DEFAULT
		var defaultStyle = [null,null,0];
		
		var defaultClass = stylingToClassName(defaultStyle);
		var currentClass = defaultClass;
		
		for (let lineIdx = 0, items = iter$(lines), len = items.length, line; lineIdx < len; lineIdx++) {
			line = items[lineIdx];
			for (let columnIdx = 0, ary = iter$(line.styles()), len = ary.length, style; columnIdx < len; columnIdx++) {
				style = ary[columnIdx];
				let styleClass = stylingToClassName(style);
				// this is probably VERY slow - 100 iterations PER line
				// we only need to change decorations for the lines that changed
				if (currentClass != styleClass) {
					// Change of styling!
					var position = [lineIdx + 1,columnIdx + 1];
					
					// dont add decorations for default class
					if (currentClass && currentClass != defaultClass) {
						var dec = {
							range: {
								startLineNumber: startPos[0],
								startColumn: startPos[1],
								endLineNumber: position[0],
								endColumn: position[1]
							},
							
							options: {
								inlineClassName: currentClass
							}
						};
						newDecorations.push(dec);
					};
					
					startPos = position;
					currentStyle = style;
					currentClass = styleClass;
				};
			};
		};
		
		this._decorations = this._monaco.deltaDecorations(this._decorations,newDecorations);
	};
	
	var row = this.screen().indexForRow(this.widget().caretRow()) + 1;
	var col = this.widget().caretCol() + 1;
	
	if (row != this._row || col != this._col) {
		this._row = row;
		this._col = col;
		
		// var range = monacoBridge.arrayToRange([row,col,1])
		var sel = new (monaco.Selection)(row,col,row,col);
		
		var range = {
			startLineNumber: row,
			startColumn: col,
			endLineNumber: row,
			endColumn: col
		};
		
		var options = {
			className: 'caret'
		};
		var bg = {
			range: {
				startLineNumber: row,
				startColumn: col,
				endLineNumber: row,
				endColumn: col + 1
			},
			options: {
				inlineClassName: 'inline-caret'
			}
		};
		
		this._carets = this._monaco.deltaDecorations(this._carets,[{range: range,options: options},bg]);
		this._editor.setSelections([sel]);
	};
	
	// how do we deal with scroll overrides?
	// need to make sure this is synced when 
	if (this.widget().scrollTop() != this._editor.getScrollTop()) {
		// @scrollTop = widget.scrollTop
		this._editor.setScrollTop(this.widget().scrollTop() || 0);
	};
	
	if (this.changed('selections')) {
		// should include ones own selection here?
		// let rsel = widget.selections(null)
		// let sel = widget.selections
		let decorations = [];
		
		for (let i = 0, items = iter$(this.space().agents()), len = items.length, agent; i < len; i++) {
			// wondering how this should work with different screens
			agent = items[i];
			let sel = this.widget().selections(agent);
			if (sel == undefined) { continue; }; // or agent.isMe
			let dec = this.monacoBridge().arrayToSelDecoration(sel,{name: ("sel agent-" + (agent.color()))});
			decorations.push.apply(decorations,dec);
		};
		
		decorations = decorations.reduce(function(a,b) { return a.concat(b); },[]);
		this._selections = this._monaco.deltaDecorations(this._selections,decorations);
		
		// if rsel
		// 	dec.push monacoBridge.arrayToSelDecoration(rsel, name: 'sel agent-sel')
		// if sel and sel != rsel
		// 	dec.push monacoBridge.arrayToSelDecoration(sel, name: 'sel local-sel')
		// @selections = @monaco.deltaDecorations(@selections, dec)
	};
	
	let elapsed = Date.now() - t;
	// if elapsed > 0
	//	console.log "TerminalModel.sync took",elapsed
	return this;
};

MonacoTerminalModel.prototype.dispose = function (){
	this._editor = null;
	if (this._monaco) { this._monaco.dispose() };
	this._monaco = null;
	return this;
};

var TerminalView = Imba.defineTag('TerminalView', MonacoView, function(tag){
	
	tag.prototype.__context = {watch: 'contextDidSet',name: 'context'};
	tag.prototype.context = function(v){ return this._context; }
	tag.prototype.setContext = function(v){
		var a = this.context();
		if(v != a) { this._context = v; }
		if(v != a) { this.contextDidSet && this.contextDidSet(v,a,this.__context) }
		return this;
	};
	tag.prototype.__screen = {watch: 'screenDidSet',name: 'screen'};
	tag.prototype.screen = function(v){ return this._screen; }
	tag.prototype.setScreen = function(v){
		var a = this.screen();
		if(v != a) { this._screen = v; }
		if(v != a) { this.screenDidSet && this.screenDidSet(v,a,this.__screen) }
		return this;
	};
	// prop model watch: yes
	
	tag.prototype.setup = function (){
		var self = this, v_;
		tag.prototype.__super__.setup.apply(self,arguments);
		
		self.space().on('refocus',function(target) {
			self.log('Space:refocus',target);
			if (target == self.context()) { return self.focus() };
		});
		
		return (self.setSref(v_ = self.data().id()),v_);
	};
	
	tag.prototype.mount = function (){
		return tag.prototype.__super__.mount.apply(this,arguments);
	};
	
	tag.prototype.unmount = function (){
		return tag.prototype.__super__.unmount.apply(this,arguments);
	};
	
	tag.prototype.getDynamicOptions = function (){
		return Object.assign(tag.prototype.__super__.getDynamicOptions.apply(this,arguments),{
			lineNumbers: 'off',
			scrollBeyondLastLine: false,
			trimTrailingWhitespace: false,
			roundedSelection: false,
			readOnly: true
		});
	};
	
	tag.prototype.contextDidSet = function (context){
		this.log('contextDidSet',context);
		return this;
	};
	
	tag.prototype.screenDidSet = function (screen){
		this.setModel(screen ? ((screen._monaco || new MonacoTerminalModel(this.context(),this._editor,screen))) : null);
		return this;
	};
	
	tag.prototype.render = function (){
		var self = this;
		if (self._editor) {
			if (self.context() && self.context().readyState() == 'connecting') { return };
			self.batch(function() {
				self.setScreen(self.context() ? self.context().screen() : null);
				if (self.model()) { self.model().sync() };
				return self.pushLayout();
			});
		};
		return self;
	};
	
	tag.prototype.keyboard = function (){
		var self = this;
		return self._keyboard || (self._keyboard = new Keyboard(self,function(str) { return self.context() && self.context().write(str); }));
	};
	
	tag.prototype.syncFocus = function (){
		let sel = this._editor.getSelection();
		let collapsed = sel.endColumn == sel.startColumn && sel.startLineNumber == sel.endLineNumber;
		let focus = this._editor.isFocused();
		
		if (focus && collapsed) {
			return this.keyboard().installKeyboard();
		} else {
			return this.keyboard().uninstallKeyboard();
		};
	};
	
	tag.prototype.posToScreen = function (agent,x,y){
		return this.data().posToScreen(agent,x,y);
	};
	
	tag.prototype.onDidLayoutChange = function (e){
		this.log('onDidLayoutChange',e);
		return this;
	};
	
	tag.prototype.onDidFocusEditor = function (e){
		this.log('onDidFocusEditor',e);
		this.flag('hasFocus');
		return this.syncFocus();
	};
	
	tag.prototype.onDidBlurEditor = function (e){
		this.log('onDidBlurEditor',e);
		this.unflag('hasFocus');
		return this.syncFocus();
	};
	
	tag.prototype.onDidScrollChange = function (e){
		if (this.space().isEditing() && this.context() && (e.scrollTopChanged || e.scrollLeftChanged)) {
			// console.log "updating scroll",e,e:scrollTop
			this.context().setScrollTop(e.scrollTop);
			this.context().setScrollLeft(e.scrollLeft);
			return this;
		};
	};
	
	tag.prototype.onDidChangeCursorSelection = function (e){
		var v_;
		let sel = e.selection;
		let collapsed = sel.endColumn == sel.startColumn && sel.startLineNumber == sel.endLineNumber;
		
		this.syncFocus();
		
		sel = this.monacoBridge().selectionToArray(sel);
		var msel = [sel];
		
		for (let i = 0, items = iter$(e.secondarySelections), len = items.length; i < len; i++) {
			sel = null;
			msel.push(this.monacoBridge().selectionToArray(items[i]));
		};
		
		if (this.context() && !this._syncing) {
			if (!collapsed) {
				if (this.space().me()) { // what if we are just paused?
					// for fancy optimization?
					return this.context().push_(ACTION.LCSELECTION,[this.context().id()].concat(sel || msel));
				} else {
					// less stress than pushing LCSELECTION
					return (this.context().setSelections(v_ = (sel || msel)),v_);
				};
			} else {
				return (this.context().setSelections(null),null);
			};
		};
	};
	
	// bind to editor events
	tag.prototype.loaded = function (){
		tag.prototype.__super__.loaded.apply(this,arguments);
		return;
	};
	
	tag.prototype.dispose = function (){
		this.keyboard().uninstallKeyboard();
		tag.prototype.__super__.dispose.apply(this,arguments);
		this._context = null;
		this._screen = null;
		this._model = null;
		this._data = null;
		
		return this;
	};
	
	tag.prototype.layoutMask = function (){
		return LAYOUTMASK.SCALED | LAYOUTMASK.BOUNDLESS;
	};
})
exports.TerminalView = TerminalView;
