function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _3 = Imba.createTagList, _2 = Imba.createTagMap, _1 = Imba.createElement;
var IconButton = require('uxa').IconButton;
var ScrimbaGesture = require('../../scrimba/util/ScrimbaGesture').ScrimbaGesture;

var Item = Imba.defineTag('Item', function(tag){
	// prop visibility watch: yes
	tag.prototype.__startCol = {watch: 'startColDidSet',name: 'startCol'};
	tag.prototype.startCol = function(v){ return this._startCol; }
	tag.prototype.setStartCol = function(v){
		var a = this.startCol();
		if(v != a) { this._startCol = v; }
		if(v != a) { this.startColDidSet && this.startColDidSet(v,a,this.__startCol) }
		return this;
	};
	tag.prototype.__col = {watch: 'colDidSet',name: 'col'};
	tag.prototype.col = function(v){ return this._col; }
	tag.prototype.setCol = function(v){
		var a = this.col();
		if(v != a) { this._col = v; }
		if(v != a) { this.colDidSet && this.colDidSet(v,a,this.__col) }
		return this;
	};
	
	
	// def visibilityDidSet val
	// 	flagIf('oob',val == 0)
	
	tag.prototype.startColDidSet = function (val){
		this.setCol(val);
		return this.flagIf('late',val > 7);
	};
	
	tag.prototype.colDidSet = function (val,prev){
		if (prev == null) {
			this.flag('abs');
		};
		this.css({transform: ("translate3d(" + (val * 100) + "%,0px,0px)")});
		return this;
	};
});

var CarouselBody = Imba.defineTag('CarouselBody');

var Pager = Imba.defineTag('Pager', function(tag){
	tag.prototype.ontouchstart = function (){
		return this;
	};
});


var Pagebar = Imba.defineTag('Pagebar', function(tag){
	tag.prototype.ontouchstart = function (t){
		let box = t._box = this.dom().getBoundingClientRect();
		let pos = (t.x() - box.left) / box.width;
		// log "pos",pos
		ScrimbaGesture.wrap(t,{type: 'seek'});
		return this;
	};
	
	tag.prototype.ontouchupdate = function (t){
		let cnt = this.parent().count();
		let pct = Math.max(0,Math.min((t.x() - t._box.left) / t._box.width,1));
		// let col = Math.max(1,Math.round(pct * cnt))
		let col = Math.max(1,Math.ceil(pct / (1 / cnt)));
		// console.log pct,col,parent.count,Math.ceil(pct / (1 / cnt))
		return this.parent().gotoPage(col - 1,{dur: 50});
	};
});

function PanGesture(){ return ScrimbaGesture.apply(this,arguments) };

Imba.subclass(PanGesture,ScrimbaGesture);
PanGesture.prototype.ontouchupdate = function (t){
	if (!this._started && Math.abs(t.dx()) > 7) {
		this.onstart(t);
		this._started = true;
	};
	if (this._started) { this.onupdate(t) };
	return this;
};

var Carousel = Imba.defineTag('Carousel', function(tag){
	tag.prototype.__offset = {'default': 0,name: 'offset'};
	tag.prototype.offset = function(v){ return this._offset; }
	tag.prototype.setOffset = function(v){ this._offset = v; return this; }
	tag.prototype._offset = 0;
	tag.prototype.__limit = {'default': 10000,name: 'limit'};
	tag.prototype.limit = function(v){ return this._limit; }
	tag.prototype.setLimit = function(v){ this._limit = v; return this; }
	tag.prototype._limit = 10000;
	tag.prototype.renderer = function(v){ return this._renderer; }
	tag.prototype.setRenderer = function(v){ this._renderer = v; return this; };
	tag.prototype.context = function(v){ return this._context; }
	tag.prototype.setContext = function(v){ this._context = v; return this; };
	
	tag.prototype.__rows = {'default': 1,name: 'rows'};
	tag.prototype.rows = function(v){ return this._rows; }
	tag.prototype.setRows = function(v){ this._rows = v; return this; }
	tag.prototype._rows = 1;
	tag.prototype.__count = {watch: 'countDidSet',name: 'count'};
	tag.prototype.count = function(v){ return this._count; }
	tag.prototype.setCount = function(v){
		var a = this.count();
		if(v != a) { this._count = v; }
		if(v != a) { this.countDidSet && this.countDidSet(v,a,this.__count) }
		return this;
	};
	tag.prototype.__colOffset = {watch: 'colOffsetDidSet',name: 'colOffset'};
	tag.prototype.colOffset = function(v){ return this._colOffset; }
	tag.prototype.setColOffset = function(v){
		var a = this.colOffset();
		if(v != a) { this._colOffset = v; }
		if(v != a) { this.colOffsetDidSet && this.colOffsetDidSet(v,a,this.__colOffset) }
		return this;
	};
	tag.prototype.colOffsetTarget = function(v){ return this._colOffsetTarget; }
	tag.prototype.setColOffsetTarget = function(v){ this._colOffsetTarget = v; return this; };
	tag.prototype.__infinite = {'default': true,name: 'infinite'};
	tag.prototype.infinite = function(v){ return this._infinite; }
	tag.prototype.setInfinite = function(v){ this._infinite = v; return this; }
	tag.prototype._infinite = true;
	
	tag.prototype.build = function (){
		this._colOffset = this._colOffsetTarget = 0;
		this._count = 0;
		return tag.prototype.__super__.build.apply(this,arguments);
	};
	
	tag.prototype.body = function (){
		var $ = this.$$ || (this.$$ = {}), self = this, t0;
		let limit = (true && 4);
		let count = 0;
		(t0 = self._body = self._body||(t0=_1(CarouselBody,self)).flag('body')).setContent(
			(function tagLoop($0) {
				var $$ = $0.$iter();
				for (let i = 0, items = iter$(self.data()), len = items.length, item; i < len; i++) {
					item = items[i];
					if (i >= limit) { continue; };
					$$.push(($0[i] || _1(Item,$0,i)).setStartCol(i).setContent(self._renderer(item,item.id,self.context(),count++),3).end());
				};return $$;
			})(t0.$['A'] || _2(t0.$,'A',self._body))
		,5).end();
		
		self.setCount(count);
		return self._body;
	};
	
	tag.prototype.ontouchstart = function (t){
		if (this._count > this.cols()) {
			return PanGesture.wrap(t,{handler: this,type: 'pan'});
		};
	};
	
	tag.prototype.onpanstart = function (g){
		g._colOffset = this.colOffset();
		g._dx0 = g.dx();
		return this.flag('_panning');
	};
	
	tag.prototype.onpanupdate = function (g){
		return this.scrollTo(g._colOffset - ((g.dx() - g._dx0) / this.colWidth()));
	};
	
	tag.prototype.onpanend = function (g){
		var self = this;
		let diff = self.colOffset() - g._colOffset;
		let page = Math.round(self.colOffset() + Math.max(-0.5,Math.min(diff,0.5)));
		self.gotoPage(page,{ease: 'easeInOutCubic'});
		return setTimeout(function() { return self.unflag('_panning'); },20);
	};
	
	tag.prototype.ontaplink = function (e){
		if (this.hasFlag('_panning')) {
			return e.prevent();
		};
	};
	
	tag.prototype.gotoPage = function (nr,pars){
		
		// var pageWidth = colWidth
		var self = this;
		if(!pars||pars.constructor !== Object) pars = {};
		var dur = pars.dur !== undefined ? pars.dur : -1;
		var ease = pars.ease !== undefined ? pars.ease : 'easeOutCubic';
		var from = self.colOffset();
		var offset = self.isInfinite() ? nr : Math.max(0,Math.min(nr,self._count - self.cols()));
		if (offset < 0) { offset = 0 };
		
		if (offset == self._colOffsetTarget) {
			return self;
		};
		
		self._colOffsetTarget = offset;
		// var offset = pageWidth * nr
		// offset = Math.max(0,Math.min(scrollWidth - offsetWidth,offset))
		if (dur == -1) {
			dur = 250 + Math.abs(offset - from) * 100;
		};
		
		var setter = function(v) { return self.scrollTo(v); };
		self.anim().animate(from,offset,dur,setter,ease,function() { return self.render(); });
		return self;
	};
	
	tag.prototype.scrollForward = function (){
		return this.gotoPage(this.currentPage() + 1);
	};
	
	tag.prototype.scrollBack = function (){
		return this.gotoPage(this.currentPage() - 1);
	};
	
	tag.prototype.scrollWidth = function (){
		return this.colWidth() * Math.ceil(this._count / this.rows());
	};
	
	tag.prototype.scrollTo = function (offset){
		this.setColOffset(offset);
		return this;
	};
	
	tag.prototype.isInfinite = function (){
		return this._count > 4 && this.infinite();
	};
	
	tag.prototype.colOffsetDidSet = function (offset,prev){
		return this.draw();
	};
	
	tag.prototype.countDidSet = function (){
		return this.scheduler().mark();
	};
	
	tag.prototype.tick = function (){
		// console.log "carousel tick"
		this.draw();
		return this;
	};
	
	tag.prototype.mount = function (){
		// console.log "mounted carousel"
		return this.draw();
	};
	
	tag.prototype.draw = function (){
		// calculate
		let offset = this.colOffset();
		let width = this.dom().offsetWidth || 0;
		let colWidth = this._body.dom().offsetWidth || 0;
		let cols = Math.round(width / colWidth);
		let rows = this.rows();
		
		// disallow scrolling
		if (this._count <= cols) { offset = 0 };
		
		let val = ("translateX(" + (offset * -100).toFixed(6) + "%)");
		this._body.css({transform: val});
		
		if (cols == 0 || colWidth == 0 || this.count() == 0) { return };
		
		let firstCol = Math.round(offset);
		let firstVisible = Math.max(Math.round(offset - 1),0);
		let lastVisible = firstVisible + Math.min(cols + 2,this._count); // not wrap around?
		let index = firstVisible;
		
		this.flagIf('tiny',colWidth < 250);
		
		let children = this._body.dom().children;
		
		if (offset == this._colOffsetTarget) {
			this._colOffsetTarget = null;
		};
		
		if (firstCol == this._firstCol) {
			return this;
		};
		
		this._firstCol = firstCol;
		// console.log "should show",firstVisible,lastVisible
		
		while (index < lastVisible){
			// actual item
			let itemNr = index % this._count;
			let item = children[itemNr];
			if (item) {
				item._tag.setCol(index);
			};
			index++;
		};
		
		this.flag('abs');
		
		this.flagIf('no-scroll',cols >= this._count);
		
		
		// set the track-position
		if (this._track) {
			// should snap to nearest 
			let barWidth = 100;
			let totalWidth = 1 / (this._count);
			let prog = (firstCol % this._count);
			// let left = (barWidth - totalWidth * barWidth) /   firstCol
			let left = (barWidth / this._count) * (firstCol % this._count);
			// flagIf('no-scroll',totalWidth > 0.5)
			
			this._track.css(
				{width: (totalWidth * 100).toFixed(2) + '%',
				// transform: "translate3d({prog * 100}%,0px,0px)"
				transform: ("translate3d(" + left + "px,0px,0px)")}
			);
		};
		
		return;
	};
	
	tag.prototype.currentPage = function (){
		return Math.round(this.colOffset());
	};
	
	tag.prototype.gridWidth = function (){
		return this.dom().offsetWidth || 0;
	};
	
	tag.prototype.colWidth = function (){
		return this._body.dom().offsetWidth || 0;
	};
	
	tag.prototype.cols = function (){
		return Math.round(this.gridWidth() / this.colWidth());
	};
	
	tag.prototype.render = function (){
		var $ = this.$, t0;
		return this.$open(0).setChildren([
			this.body(),
			$[0] || _1(Pager,$,0,this).flag('pager').flag('prev').dataset('icon','mleft').on$(0,['tap','prevent','scrollBack'],this),
			$[1] || _1(Pager,$,1,this).flag('pager').flag('next').dataset('icon','mright').on$(0,['tap','prevent','scrollForward'],this),
			t0 = $[2] || (t0=_1(Pagebar,$,2,this)).setContent(this._track = this._track||_1('div',t0).flag('track'),2)
		],1).synced((
			$[0].end(),
			$[1].end(),
			$[2].end()
		,true));
		
		// change colWidth?
		// draw if colWidth != 
	};
})
exports.Carousel = Carousel;


