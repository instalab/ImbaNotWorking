function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};

var WebSocketServer = require('ws').Server;

var MSG = require('../scrimba/protocol').MSG;
var api$ = require("./api"), API = api$.API, PeerAPI = api$.PeerAPI;
var SessionParser = require("./session").SessionParser;
var PeerWebSocket = require('../models/PeerWebSocket').PeerWebSocket;

var services = require('../services/index');
var twilio = require('../services/twilio');
var tracking = require('../scrimba/tracking');
var env = require('../env');
var util = require('../util');

function SocketServer(server){
	var self = this;
	self.setWss(new WebSocketServer(
		{server: server,
		perMessageDeflate: false,
		path: "/socket"}
	));
	
	self._heartbeat = function() {
		this.isAlive = true;
		this.lastPong = Date.now();
		this.lastRoundtrip = this.lastPong - this.lastPing;
		self.stats().roundtrip.update(this.lastRoundtrip);
		return self;
	};
	
	self.setup();
	setInterval(self.pongSockets.bind(self),30 * 1000);
	self;
};

exports.SocketServer = SocketServer; // export class 
SocketServer.prototype.wss = function(v){ return this._wss; }
SocketServer.prototype.setWss = function(v){ this._wss = v; return this; };

SocketServer.prototype.stats = function (){
	return API.STATS;
};

SocketServer.prototype.clients = function (){
	return this.wss().clients;
};

SocketServer.prototype.waitForSession = function (req){
	var res = {};
	return new Promise(function(resolve,reject) {
		return SessionParser(req,res,function() { return resolve(req.session); });
	});
};

SocketServer.prototype.scheduleClose = function (peer){
	return peer._timeout = setTimeout(function() {
		if (!peer.ws()) {
			return services.peers.release(peer.id);
		};
	},2000);
};

SocketServer.prototype.setup = function (){
	var self = this;
	return self.wss().on('connection',async function(ws,req) {
		
		var passport_, $1;
		var peer = null;
		var channel = null;
		
		ws.lastPong = new Date();
		
		ws.on('message',function(message) {
			var now = Date.now();
			self.stats().messages.mark();
			if (peer && peer.ws()) {
				return peer.ws().channel().receive(message);
			};
			// channel.onmessage(message)
		});
		
		ws.on('close',function() {
			console.log("close socket",ws.pid,ws.uid,ws.ip);
			self.stats().sockets.dec();
			if (peer) {
				peer.setWs(null);
				self.scheduleClose(peer);
				// services:peers.release(peer:id)
			};
			ws.peer = null;
			return self;
		});
		
		ws.on('error',function(err) {
			return console.log("error from socket",err);
		});
		
		ws.on('pong',self._heartbeat);
		
		var ip = req.headers['x-forwarded-for'];
		var ua = req.headers['user-agent'];
		var q = {};
		
		req.url.replace(/\b(\w+)=([^\&]+)/g,function(m,key,val) {
			return q[key] = val;
		});
		
		console.log(("wss.connection " + (q.id) + " " + (q.r) + " " + ip + " " + ua + " " + (q.secret)));
		// check if machine
		
		var session = await self.waitForSession(req);
		var uid = (passport_ = ($1 = session) && $1.passport) && passport_.user;
		
		// console.log "session secrets",Object.keys(session),req:sessionID # Object.keys(req:headers),req:sessionID,session:cookie,req:headers:cookie # ,req:cookies['sid']
		
		ws.clientVersion = q.scv;
		
		ws.ua = req.headers['user-agent'];
		ws.ip = req.headers['x-forwarded-for'];
		ws.pid = q.id;
		ws.uid = uid;
		ws.sid = req.sessionID;
		
		peer = await self.acquirePeer(ws);
		
		// check if we have changed id?
		ws.pid = peer.id;
		ws.peer = peer;
		
		if (session && session.secrets) {
			// console.log "add secrets to peer",ws:pid,session:secrets
			for (let o = session.secrets, secret, i = 0, keys = Object.keys(o), l = keys.length, key; i < l; i++){
				key = keys[i];secret = o[key];peer.secrets()[key] = secret;
			};
		};
		
		// create api for this peer / socket
		var api = await PeerAPI.spawn(ws.uid);
		peer._api = api;
		peer._secret = q.secret || util.uuid();
		api._peer = peer;
		peer.setWs(new PeerWebSocket(peer,ws));
		
		console.log(("connecting " + (ws.pid)));
		let twilioToken = await twilio.createToken();
		peer.ws().send([MSG.CONNECTED,peer,peer._secret,{ice: twilioToken.iceServers}]);
		console.log(("connected " + (ws.pid)));
		
		self.stats().sockets.inc();
		
		return peer;
	});
};

SocketServer.prototype.pongSockets = function (){
	console.log(("pong " + (len$(this.clients())) + " sockets"));
	var count = 0;
	var roundtrips = [];
	
	this.clients().forEach(function(ws) {
		if (!ws.lastPong) {
			console.log("terminate",ws.pid,ws.uid,ws.ip);
			return ws.terminate();
		};
		
		roundtrips.push(ws.lastRoundtrip);
		ws.lastPong = null;
		ws.lastPing = Date.now();
		count++;
		return ws.ping('',false,true);
	});
	
	return this.stats().sockets.reset(count);
};

SocketServer.prototype.acquirePeer = async function (ws){
	// extending the ws object
	var peer = API.db().peers().get(ws.pid);
	
	if (peer && peer._socket) {
		console.log("peer already connected to other socket?!");
		// reuse this socket??
	};
	
	if (peer) {
		clearTimeout(peer._timeout);
		peer._timeout = null;
	};
	
	var pid = await services.peers.acquire(
		{id: ws.pid,
		uid: ws.uid,
		sid: ws.sid,
		worker: env.get('WORKER_ID'),
		ua: ws.ua,
		ip: ws.ip}
	);
	
	return API.db().peers().summon(pid);
};

SocketServer.prototype.broadcast = function (msg){
	return this.clients().forEach(function(client) {
		let peer = client.peer;
		if (client.peer) { return client.peer.send(msg) };
	});
};

SocketServer.prototype.ondatachange = function (items){
	console.log("broadcast changes",items.map(function(item) { return item.id; }));
	this.clients().forEach(function(client) {
		let peer = client.peer;
		if (peer && !peer.isMachine()) {
			console.log(("broadcasting to peer " + (peer.id)));
			return peer.send([MSG.SYNC,items]);
		};
	});
	return this;
};
