function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var self = {};
var LCRange = require('../protocol').LCRange;
var Range$ = require('./Range'), Position = Range$.Position, Range = Range$.Range, Selection = Range$.Selection;

var compareRangesUsingEnds = function(a,b) {
	var al1 = a[0] - 1;
	var ac1 = a[1] - 1;
	var al2 = (a[0] + (a[3] || 0)) - 1;
	var ac2 = (a[1] + (a[2] || 0)) - 1;
	
	var bl1 = b[0] - 1;
	var bc1 = b[1] - 1;
	var bl2 = (b[0] + (b[3] || 0)) - 1;
	var bc2 = (b[1] + (b[2] || 0)) - 1;
	
	if (al2 == bl2) {
		if (ac2 == bc2) {
			if (al1 == bc1) {
				return ac1 - bc1;
			};
			return al1 - bl1;
		};
		return ac2 - bc2;
	};
	return al2 - bl2;
};

var sortOpsAscending = function(a,b) {
	let r = compareRangesUsingEnds(a[0],b[0]);
	if (r == 0) {
		return a.I - b.I;
	};
	return r;
};


var sortOpsDescending = function(a,b) {
	let r = compareRangesUsingEnds(a[0],b[0]);
	if (r == 0) {
		return b.I - a.I;
	};
	return -r;
};

var diffString = exports.diffString = function(str0,str1) {
	var i = 0;
	var l0 = str0.length;
	var l1 = str1.length;
	var minLen = Math.min(l0,l1);
	var maxLen = Math.max(l0,l1);
	var l = maxLen;
	
	var left = 0;
	// find first part that is different
	while (i < minLen){
		var chr0 = str0[i];
		var chr1 = str1[i];
		i++;
		
		if (chr0 == chr1) {
			left++;
		} else {
			break;
		};
	};
	
	// equal all the way
	if (left == i) {
		// cut it
		if (l0 > l1) {
			return [left,l0,''];
		} else if (l1 > l0) {
			return [left,left,str1.slice(left)];
		};
		return [];
	};
	
	// go from the end -- look at first part that is the same
	while (l0 >= left && l1 >= left){
		chr0 = str0[--l0];
		chr1 = str1[--l1];
		
		if (chr0 != chr1) {
			break;
		};
	};
	
	// right = Math.max(l0 + 1,left)
	var ins = str1.slice(left,l1 + 1);
	return [left,l0 + 1,ins];
};


var patchString = exports.patchString = function(str,diff) {
	if (diff instanceof Array) {
		return str.substr(0,diff[0]) + diff[2] + str.slice(diff[1]);
	} else {
		return diff;
	};
};

var getLineMaxColumn = exports.getLineMaxColumn = function(line) {
	return line.length;
};

var rangeToArray = exports.rangeToArray = function(range,direction) {
	if(direction === undefined) direction = 0;
	if (direction == 1) {
		return LCRange.lclcToArray(range.endLineNumber,range.endColumn,range.startLineNumber,range.startColumn);
	} else {
		return LCRange.lclcToArray(range.startLineNumber,range.startColumn,range.endLineNumber,range.endColumn);
	};
};

var arrayToSelection = exports.arrayToSelection = function(val) {
	return new Selection(val[0],val[1],val[0] + (val[3] || 0),val[1] + (val[2] || 0));
};

var arrayToRange = exports.arrayToRange = function(val) {
	if (val.length == 5) {
		return new Range(val[0],val[1],val[2],val[3]);
	};
	return new Range(val[0],val[1],val[0] + (val[3] || 0),val[1] + (val[2] || 0));
};



var adjustSelection = exports.adjustSelection = function(sel,before,after,raw) {
	// console.log "adjust",sel,before,after
	let l1 = sel.startLineNumber;
	let l2 = sel.endLineNumber;
	let c1 = sel.startColumn;
	let c2 = sel.endColumn;
	
	let bl1 = before.startLineNumber;
	let bl2 = before.endLineNumber;
	
	// al1 is pointless
	// let al1 = after:startLineNumber
	let al2 = after.endLineNumber;
	
	let dir = sel.getDirection();
	let ary = raw.slice();
	
	let colDiff = after.endColumn - before.endColumn;
	let rowDiff = after.endLineNumber - before.endLineNumber;
	
	if (l2 < bl1 || (l2 == bl1 && before.startColumn > c2)) {
		// selection ends before this adjustment begins
		return raw;
	};
	
	if (l1 > bl2) {
		if (rowDiff) {
			ary[0] += rowDiff;
			return ary;
		} else {
			return raw;
		};
	};
	
	let selStart = sel.getStartPosition();
	let selEnd = sel.getEndPosition();
	
	let opStart = before.getStartPosition();
	let opEnd = before.getEndPosition();
	
	let intersection = Range.intersectRanges(sel,before);
	
	if (intersection) {
		let start = intersection.getStartPosition();
		let end = intersection.getEndPosition();
		
		let atStart = start.equals(sel.getStartPosition());
		let atEnd = end.equals(sel.getEndPosition());
		
		// we are inside
		if (opStart.isBefore(start) && end.isBefore(opEnd)) {
			ary = rangeToArray(after,dir);
			return ary;
		};
		
		// the whole selection should expand
		if (selStart.isBefore(opStart) && opEnd.isBefore(selEnd)) {
			self;
		};
		
		if (intersection.isEmpty()) {
			atStart = atEnd = false;
		};
		
		if (atStart && atEnd) {
			ary = rangeToArray(after,dir);
			return ary;
		} else if (atStart) {
			// let range = after.cloneRange
			sel = sel.setStartPosition(end.lineNumber,end.column);
			ary = LCRange.selectionToArray(sel);
			return adjustSelection(sel,before,after,ary);
		} else if (atEnd) {
			// it matters if it ends further out, no?
			// console.log 'at end!!'
			sel = sel.setEndPosition(start.lineNumber,start.column);
			ary = LCRange.selectionToArray(sel);
			return adjustSelection(sel,before,after,ary);
		};
	};
	
	
	// op ends at the same line
	if (opEnd.isBefore(selStart)) {
		true;
	};
	
	// selection starts after range
	if (l1 == bl2 && c1 >= before.endColumn) {
		if (rowDiff) {
			ary[0] += rowDiff; // we move by lines
			let col = after.endColumn + (c1 - before.endColumn);
			// console.log "changing row before",rowDiff,col,after:endColumn,before:endColumn,c1
			if (dir) {
				ary[2] = (col - ary[1]);
			} else {
				ary[1] = col;
			};
			// if our selection is 
			return ary;
		} else {
			if (dir) {
				ary[2] = (ary[2] + colDiff); // - ary[1]
			} else {
				ary[1] = ary[1] + colDiff;
			};
			return ary;
		};
	};
	
	// single line
	if (bl2 == al2 && bl1 == bl2) {
		// let move = after:endColumn - before:endColumn
		// if the edit is before - move the selection forward
		if (l1 == bl1 && l1 == l2) {
			if (Math.min(c1,c2) >= before.endColumn) {
				// edit is fully before selection
				ary[1] = ary[1] + colDiff;
				// ary = [raw[0],raw[1] + move,raw[2] or 0,raw[3] or 0]
				return ary;
			} else if (before.startColumn > c1 && before.endColumn < c2) {
				// console.log "we are inside!!!"
				ary = dir ? [l1,c2 + colDiff,raw[2] - colDiff] : [l1,c1,raw[2] + colDiff];
				return ary;
			};
		};
	};
	
	
	
	// if we are inside - many more possibilities
	if ((l1 == bl1 && before.startColumn > c1 && before.endColumn < c2)) {
		// console.log "starting inside!!"
		if (rowDiff) {
			
			ary[3] = (ary[3] || 0) + rowDiff;
			// if sel ends after before line - we only add to rows
			if (bl2 >= l2) {
				let col = after.endColumn + (c2 - before.endColumn);
				// console.log "column should be",col,after:endColumn,before:endColumn
				ary[2] = (col - ary[1]);
			};
			return ary;
		};
	};
	
	
	
	return ary;
};

var LINE_REGEX = /\r\n|\r|\n/;

function TextModel(raw){
	if(raw === undefined) raw = '';
	this._raw = raw;
	this._lines = raw.split(LINE_REGEX);
	this._markers = {};
	this.reset();
};

exports.TextModel = TextModel; // export class 
TextModel.prototype.lines = function(v){ return this._lines; }
TextModel.prototype.setLines = function(v){ this._lines = v; return this; };
TextModel.prototype.markers = function(v){ return this._markers; }
TextModel.prototype.setMarkers = function(v){ this._markers = v; return this; };

TextModel.prototype.reset = function (){
	this._edited = [];
	this._body = null;
	return this;
};

TextModel.prototype.reversedOperation = function (op){
	var str = this.textInRange(op[0]);
	var rng = this.expandedRange(op[0],op[1]);
	return [rng,str];
};

TextModel.prototype.expandedRange = function (start,text){
	var range;
	var lines = (text || '').split(LINE_REGEX);
	var l2 = start[0] + (lines.length - 1);
	var col = lines[lines.length - 1].length;
	if (start[0] == l2) {
		col += start[1];
	} else {
		col += 1;
	};
	
	return range = [start[0],start[1],col - start[1],l2 - start[0]];
};

TextModel.prototype.textInRange = function (pos,lines){
	if(lines === undefined) lines = this._lines;
	var l1 = pos[0] - 1;
	var c1 = pos[1] - 1;
	
	var l2 = (pos[0] + (pos[3] || 0)) - 1;
	var c2 = (pos[1] + (pos[2] || 0)) - 1;
	
	// var l2 = (pos[2] or pos[0]) - 1
	// var c2 = (pos[3] or pos[1]) - 1
	
	if (l1 == l2) {
		return lines[l1].slice(c1,c2);
	};
	
	var parts = lines[l1++].slice(c1);
	while (l1 < l2){
		parts += "\n" + lines[l1++];
	};
	
	parts += "\n" + lines[l2].slice(0,c2);
	return parts;
};

TextModel.prototype.adjustMarker = function (pos,before,after){
	let sel = arrayToSelection(pos);
	let pos2 = adjustSelection(sel,before,after,pos);
	return pos2;
};

TextModel.prototype.adjustMarkers = function (range1,range2){
	
	let before = arrayToRange(range1);
	let after = arrayToRange(range2);
	let changes = {};
	
	// nested marker-changes?
	
	for (let o = this._markers, pos, i = 0, keys = Object.keys(o), l = keys.length, ref; i < l; i++){
		ref = keys[i];pos = o[ref];if (pos[0] instanceof Array) {
			let res = [];
			for (let j = 0, items = iter$(pos), len = items.length; j < len; j++) {
				res.push(this.adjustMarker(items[j],before,after));
			};
			this._markers[ref] = changes[ref] = res;
		} else {
			let res = this.adjustMarker(pos,before,after);
			// let sel1 = arrayToSelection(pos)
			// let pos2 = adjustSelection(sel1,before,after,pos)
			if (res != pos && !LCRange.equals(pos,res)) {
				this._markers[ref] = changes[ref] = LCRange.optimize(res);
			};
		};
	};
	
	return changes;
};


TextModel.prototype.apply = function (ops){
	var lines = this._lines;
	var rev = null;
	
	// uncache body
	this._body = null;
	
	if (!ops.UNDO) {
		ops.FWD = 1;
		rev = ops.UNDO = [];
		rev.UNDO = ops;
		rev.REV = 1;
	};
	
	let len = ops.length;
	let i = 0;
	
	// if first apply - sort	
	if (len > 1 && ops.FWD) {
		ops = ops.map(function(op,i) {
			op.I = i;
			return op;
		}).sort(sortOpsDescending);
	};
	
	// apply the operations in order
	while (i < len){
		let op = ops[i++];
		var pos = op[0];
		var ins = op[1] || '';
		
		var ln = pos[0] - 1;
		var col = pos[1] - 1;
		var ln2 = (pos[0] + (pos[3] || 0)) - 1;
		var col2 = (pos[1] + (pos[2] || 0)) - 1;
		
		if (rev) {
			let revOp = this.reversedOperation(op);
			// this is a reversible operation
			rev.unshift(revOp);
			op.REVRANGE = revOp[0];
			op.MARKERS = this.adjustMarkers(pos,revOp[0]);
		} else if (ops.FWD) {
			op.MARKERS = this.adjustMarkers(pos,op.REVRANGE);
		};
		
		// the range spans multiple lines
		if (ln != ln2) {
			let start = lines[ln].slice(0,col);
			let end = lines[ln2].slice(col2);
			lines[ln] = start + end;
			lines.splice(ln + 1,(ln2 - ln));
			col2 = col;
		};
		
		let line = lines[ln];
		
		line = line.slice(0,col) + ins + line.slice(col2);
		
		if (ins.indexOf('\n') >= 0) {
			lines.splice.apply(lines,[].concat([ln,1], [].slice.call(line.split(LINE_REGEX))));
		} else {
			lines[ln] = line;
		};
	};
	
	return ops;
};

TextModel.prototype.getValue = function (){
	return this.body();
};

TextModel.prototype.body = function (){
	return this._body || (this._body = this._lines.join("\n"));
};

TextModel.prototype.getDiff = function (lines){
	var locals = this._lines;
	
	if ((typeof lines=='string'||lines instanceof String)) {
		lines = lines.split(LINE_REGEX).map(function(text,nr) { return {_text: text}; });
	};
	
	var remote = lines;
	
	var rl = len$(remote);
	var ll = len$(locals);
	
	var l1 = 0;
	var c1 = 0;
	var l2 = rl - 1;
	var c2 = 0;
	var text;
	
	var lEnd = ll - 1;
	var minLines = Math.min(rl,ll);
	
	// compare forwards
	while (l1 < minLines){
		if (locals[l1] != remote[l1]._text) {
			// console.log "line different",l1,[locals[l1],remote[l1]:_text]
			break;
		};
		l1 += 1;
	};
	
	// all lines shared are the same
	if (l1 == minLines) {
		if (ll == rl) {
			return null;
		} else if (ll > rl) {
			// insert at the end of last line
			l1 = l2;
			c1 = c2 = getLineMaxColumn(remote[l2]._text);
			text = "\n" + locals.slice(rl).join("\n");
			// end column as well
		} else if (rl > ll) {
			// we should remove from the end
			// there are more lines in remote
			l1 = ll - 1;
			c1 = getLineMaxColumn(locals[l1]);
			l2 = rl - 1;
			c2 = getLineMaxColumn(remote[l2]._text); // max length
			text = '';
		};
	} else {
		while (lEnd > l1 && l2 > l1){
			if (locals[lEnd] != remote[l2]._text) {
				// console.log "different line",locals[lEnd],remote[l1]
				break;
			};
			lEnd -= 1;
			l2 -= 1;
		};
		
		// console.log l1,l2,lEnd,rl,ll
		// some lines should be removed at end?
		if (rl > ll && false) { // lEnd == (ll - 1)
			l2 = l2 + 1;
			c2 = 0;
			// get the content that have changed though?
			text = '';
		} else {
			c2 = getLineMaxColumn(remote[l2]._text);
		};
		
		if (l1 == l2 && lEnd >= l2) {
			var txt = remote[l1]._text;
			var localStr = locals.slice(l1,lEnd + 1).join("\n");
			var strdiff = diffString(txt,localStr);
			c1 = strdiff[0];
			c2 = strdiff[1];
			text = strdiff[2];
			// console.log "diffed",strdiff,[txt,localStr]
		};
	};
	
	var pos = [l1 + 1,c1 + 1,(c2 - c1),(l2 - l1)];
	
	if (text == undefined) {
		text = this.textInRange([l1 + 1,c1 + 1,1000,(lEnd - l1)]);
	};
	
	return [pos,text];
};
