function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _4 = Imba.createTagList, _2 = Imba.createTagMap, _3 = Imba.createTagLoopResult, _1 = Imba.createElement;
var protocol$ = require('../../protocol'), ACTION = protocol$.ACTION, DOM = protocol$.DOM, SCON = protocol$.SCON, KEYS = protocol$.KEYS;
// var mime = require 'mime-types'
var M = DOM.MUTS;

var patchString = require('../simulator/differ').patchString;
var helpers = require('./helpers');

var styleProcessor = require('./styleProcessor');

var parentForNodeType = {
	head: 'html',
	body: 'html',
	thead: 'table',
	tbody: 'table',
	tr: 'tbody',
	td: 'tr',
	th: 'td',
	option: 'select'
};

var mimeTypes = {
	jpg: "image/jpeg",
	png: "image/png",
	svg: "image/svg+xml",
	gif: "image/gif",
	css: "text/css",
	json: "application/json"
};

var baseCSS = null;

if (false) {};

var LogAttributes = Imba.defineTag('LogAttributes', function(tag){
	
	tag.prototype.render = function (){
		var $ = this.$;
		var pairs = [];
		
		for (let i = 0, items = iter$(this.data()), len = items.length, val; i < len; i++) {
			val = items[i];
			if (!(i % 2)) { continue; };
			var pair = [SCON.refToKey(this.data()[i - 1])];
			if (val != null) {
				pair.push(val);
			};
			pairs.push(pair);
		};
		
		var count = len$(pairs);
		
		return this.$open(0).setChildren(
			(function tagLoop($0,$1,$2,$$) {
				for (let i = 0, len = pairs.length, pair; i < len; i++) {
					pair = pairs[i];
					$$.push(' ');
					$$.push(($0[i] || _1('span',$0,i).flag('name')).setContent(pair[0],3));
					if (pair[1]) {
						$$.push(($1[i] || _1('u',$1,i).setText('=')));
						$$.push(($2[i] || _1(LogVal,$2,i)).bindData(pair,1).end());
					};
				};return $$;
			})($[0] || _2($,0),$[1] || _2($,1),$[2] || _2($,2),[])
		,3).synced();
	};
});

var LogVal = Imba.defineTag('LogVal', function(tag){
	
	tag.prototype.type = function (){
		var data_, $1;
		if (this.data() instanceof Array) {
			return KEYS[this.data()[0]];
		} else if ((typeof (data_ = this.data())=='string'||data_ instanceof String)) {
			return 'string';
		} else if ((typeof ($1 = this.data())=='number'||$1 instanceof Number)) {
			return 'number';
		} else if (this.data() == null) {
			return 'null';
		} else if (this.data() == undefined) {
			return 'undefined';
		} else if (this.data() == true || this.data() == false) {
			return 'bool';
		} else if (this.data() instanceof Array) {
			return 'array';
		} else if (this.data() instanceof Object) {
			return 'object';
		} else {
			return 'value';
		};
	};
	
	tag.prototype.errorPosition = function (data){
		try {
			var fstFrame = data[3][2];
		} catch (e) { };
		return fstFrame ? ((" (" + (fstFrame[2]) + ":" + (fstFrame[3]) + ")")) : "";
	};
	
	tag.prototype.render = function (){
		var $ = this.$;
		var type = this.type();
		var data = this.data();
		var chars = 0;
		
		return this.$open(0).setFlag(-1,"tok-" + type).setChildren(
			(type == 'string') ? Imba.static([
				($[0] || _1('u',$,0,this).setText('"')),
				data,
				($[1] || _1('u',$,1,this).setText('"'))
			],1,1) : ((type == 'array') ? Imba.static([
				($[2] || _1('u',$,2,this).setText('[')),
				(function tagLoop($0,$1,$$) {
					for (let i = 0, items = iter$(data), len = items.length; i < len; i++) {
						if (i <= 1) { continue; };
						if (i > 2) {
							$$.push(($0[i] || _1('u',$0,i).setText(', ')));
						};
						$$.push(($1[i] || _1(LogVal,$1,i)).setData(items[i]).end());
					};return $$;
				})($[3] || _2($,3),$[4] || _2($,4),_3()),
				(data.length < data[1]) ? Imba.static([
					($[5] || _1('u',$,5,this).setText(', ')),
					($[6] || _1('u',$,6,this).flag('more').setText('...'))
				],2,2) : void(0),
				($[7] || _1('u',$,7,this).setText(']'))
			],1,3) : ((type == 'function') ? (
				data[1]
			) : ((type == 'element') ? Imba.static([
				($[8] || _1('u',$,8,this).setText('<')),
				($[9] || _1('span',$,9,this).flag('name')).setContent(SCON.refToKey(data[1]),3),
				($[10] || _1(LogAttributes,$,10,this)).bindData(data,2).end(),
				($[11] || _1('u',$,11,this).setText('>'))
			],2,4) : ((type == 'error') ? Imba.static([
				($[12] || _1('span',$,12,this).flag('category')).setContent(data[1] + ': ',3),
				($[13] || _1('span',$,13,this).flag('message')).setContent(data[2],3),
				($[14] || _1('span',$,14,this)).setContent(this.errorPosition(data),3)
			],2,5) : ((type == 'object') ? Imba.static([
				($[15] || _1('u',$,15,this).setText('{')),
				(function tagLoop($0,$1,$$) {
					var t0;
					for (let i = 0, items = iter$(Object.keys(data)), len = items.length, key; i < len; i++) {
						key = items[i];
						if (i > 0) {
							$$.push(($0[i] || _1('u',$0,i).flag('delim').setText(', ')));
						};
						$$.push((t0 = $1[i] || (t0=_1('span',$1,i)).flag('kv').setContent([
							_1('span',t0.$,'A',t0).flag('tok-key'),
							_1('u',t0.$,'B',t0).setText(': '),
							_1(LogVal,t0.$,'C',t0).flag('value')
						],2)).end((
							t0.$.A.setContent(key,3),
							t0.$.C.bindData(data,key).end()
						,true)));
					};return $$;
				})($[16] || _2($,16),$[17] || _2($,17),_3()),
				
				($[18] || _1('u',$,18,this).setText('}'))
			],1,6) : ((type == 'null') ? (
				'null'
			) : ((type == 'undefined') ? (
				'undefined'
			) : ((type == 'bool') ? (
				data ? 'true' : 'false'
			) : ((data instanceof Array) ? (
				data[1]
			) : (
				data
			))))))))))
		,3).synced();
	};
});

var LogEntry = Imba.defineTag('LogEntry', function(tag){
	
	tag.prototype.__data = {watch: 'dataDidSet',name: 'data'};
	tag.prototype.data = function(v){ return this._data; }
	tag.prototype.setData = function(v){
		var a = this.data();
		if(v != a) { this._data = v; }
		if(v != a) { this.dataDidSet && this.dataDidSet(v,a,this.__data) }
		return this;
	};
	
	let icons = {
		warn: "▲",
		error: "!"
	};
	
	tag.prototype.dataDidSet = function (){
		return this._dirty = true;
	};
	
	tag.prototype.type = function (){
		return this.data()[0];
	};
	tag.prototype.items = function (){
		return this.data()[1];
	};
	tag.prototype.badge = function (){
		return this.data()[2];
	};
	
	tag.prototype.render = function (){
		var $ = this.$, self = this;
		if (!self._dirty) { return };
		self._dirty = false;
		
		let typ = KEYS[self.type()];
		// drop .scon
		self.$open(0).flag('scon').setFlag(-1,("typ-" + typ)).setChildren([
			($[0] || _1('i',$,0,self)).setContent(icons[typ] || '>',3),
			(self.badge() > 1) ? (
				($[1] || _1('div',$,1,self).flag('badge').setContent($[2] || _1('span',$,2,1).flag('num'),2)).end((
					$[2].setContent(self.badge(),3)
				,true))
			) : void(0),
			(function tagLoop($0,$1,$$) {
				for (let i = 0, items = iter$(self.items()), len = items.length; i < len; i++) {
					$$.push(($0[i] || _1(LogVal,$0,i)).setData(items[i]).end());
					$$.push(($1[i] || _1('u',$1,i).setText(",")));
				};return $$;
			})($[3] || _4($,3),$[4] || _4($,4),_3())
		],1).synced();
		return self;
	};
})
exports.LogEntry = LogEntry;

var Logs = Imba.defineTag('Logs', function(tag){
	
	tag.prototype.build = function (){
		return this._dirty = true;
	};
	
	tag.prototype.push = function (item){
		this._dirty = true;
		return this._data.push(item);
	};
	
	tag.prototype.pop = function (){
		this._dirty = true;
		return this._data.pop();
	};
	
	tag.prototype.len = function (){
		return this._data.length;
	};
	
	tag.prototype.render = function (){
		var self = this, $ = this.$;
		if (!self._dirty) { return };
		self._dirty = false;
		
		return self.$open(0).setChildren(
			(function tagLoop($0) {
				for (let i = 0, items = iter$(self.data()), len = $0.taglen = items.length; i < len; i++) {
					($0[i] || _1(LogEntry,$0,i)).setData(items[i]).end();
				};return $0;
			})($[0] || _4($,0))
		,4).synced();
	};
});


function PlayerPage(initiator,o){
	if(o === undefined) o = {};
	if (false) {} else {
		this._logs = [].concat(o.logs || []);
	};
	this;
};

exports.PlayerPage = PlayerPage; // export class 
PlayerPage.prototype.html = function(v){ return this._html; }
PlayerPage.prototype.setHtml = function(v){ this._html = v; return this; };

PlayerPage.prototype.__selection = {watch: 'selectionDidSet',name: 'selection'};
PlayerPage.prototype.selection = function(v){ return this._selection; }
PlayerPage.prototype.setSelection = function(v){
	var a = this.selection();
	if(v != a) { this._selection = v; }
	if(v != a) { this.selectionDidSet && this.selectionDidSet(v,a,this.__selection) }
	return this;
};
PlayerPage.prototype.focusNode = function(v){ return this._focusNode; }
PlayerPage.prototype.setFocusNode = function(v){ this._focusNode = v; return this; };
PlayerPage.prototype.hoverNode = function(v){ return this._hoverNode; }
PlayerPage.prototype.setHoverNode = function(v){ this._hoverNode = v; return this; };
PlayerPage.prototype.activeNode = function(v){ return this._activeNode; }
PlayerPage.prototype.setActiveNode = function(v){ this._activeNode = v; return this; };
PlayerPage.prototype.__baseURI = {watch: 'baseURIDidSet',name: 'baseURI'};
PlayerPage.prototype.baseURI = function(v){ return this._baseURI; }
PlayerPage.prototype.setBaseURI = function(v){
	var a = this.baseURI();
	if(v != a) { this._baseURI = v; }
	if(v != a) { this.baseURIDidSet && this.baseURIDidSet(v,a,this.__baseURI) }
	return this;
};

PlayerPage.prototype.logs = function(v){ return this._logs; }
PlayerPage.prototype.setLogs = function(v){ this._logs = v; return this; };
PlayerPage.prototype.href = function(v){ return this._href; }
PlayerPage.prototype.setHref = function(v){ this._href = v; return this; };

PlayerPage.prototype.requestAction = function(v){ return this._requestAction; }
PlayerPage.prototype.setRequestAction = function(v){ this._requestAction = v; return this; };
PlayerPage.prototype.loadAction = function(v){ return this._loadAction; }
PlayerPage.prototype.setLoadAction = function(v){ this._loadAction = v; return this; };
PlayerPage.prototype.loadedAction = function(v){ return this._loadedAction; }
PlayerPage.prototype.setLoadedAction = function(v){ this._loadedAction = v; return this; };

PlayerPage.prototype.location = function(v){ return this._location; }
PlayerPage.prototype.setLocation = function(v){ this._location = v; return this; };
PlayerPage.prototype.status = function(v){ return this._status; }
PlayerPage.prototype.setStatus = function(v){ this._status = v; return this; };
PlayerPage.prototype.loaded = function(v){ return this._loaded; }
PlayerPage.prototype.setLoaded = function(v){ this._loaded = v; return this; };
PlayerPage.prototype.loading = function(v){ return this._loading; }
PlayerPage.prototype.setLoading = function(v){ this._loading = v; return this; };
PlayerPage.prototype.tracker = function(v){ return this._tracker; }
PlayerPage.prototype.setTracker = function(v){ this._tracker = v; return this; };
PlayerPage.prototype.__tracking = {'default': true,name: 'tracking'};
PlayerPage.prototype.tracking = function(v){ return this._tracking; }
PlayerPage.prototype.setTracking = function(v){ this._tracking = v; return this; }
PlayerPage.prototype._tracking = true;
PlayerPage.prototype.cancelled = function(v){ return this._cancelled; }
PlayerPage.prototype.setCancelled = function(v){ this._cancelled = v; return this; };
PlayerPage.prototype.__errored = {'default': false,name: 'errored'};
PlayerPage.prototype.errored = function(v){ return this._errored; }
PlayerPage.prototype.setErrored = function(v){ this._errored = v; return this; }
PlayerPage.prototype._errored = false;

PlayerPage.toOptionValue = function (value){
	return value;
};

PlayerPage.fromOptionValue = function (value,widget){
	if (value instanceof PlayerPage) {
		return value;
	} else if (value instanceof Object) {
		if (value._RICH) {
			return value._RICH;
		} else {
			var rich = new this(widget,value);
			Object.defineProperty(this,'_RICH',{value: rich,enumerable: false,configurable: true});
			return rich;
		};
	};
};

PlayerPage.prototype.load = function (){
	
};

PlayerPage.prototype.branch = function (){
	return this._initiator && this._initiator.branch  &&  this._initiator.branch();
};

PlayerPage.prototype.browser = function (){
	return this._initiator && this._initiator.browser  &&  this._initiator.browser();
};

PlayerPage.prototype.space = function (){
	return this._initiator && this._initiator.space  &&  this._initiator.space();
};

PlayerPage.prototype.resolvePath = function (path){
	let host = window.location.host;
	let space = this._initiator && this._initiator.space  &&  this._initiator.space();
	for (let i = 0, items = iter$(space.files()), len = items.length, file; i < len; i++) {
		file = items[i];
		if (file.path() == path) {
			var ext = (path.match(/\.[^\.]+$/) || [""])[0];
			if (file.blobId()) {
				return ("https://" + host + "/blobs/" + (file.blobId()) + ext);
			} else {
				var type = mimeTypes[ext] || ""; // mime.lookup(file.name) || ""
				return ("data:" + type + "," + (file.body()));
			};
		};
	};
	return null;
};

PlayerPage.prototype.lookupResource = function (path){
	// should know if this particular page was accessed through proxy?
	if (!(this._href && this._href.match(/^https?\:\/\//))) { return null };
	
	let url = new URL(path,this._href);
	let href = url.href;
	let cache = this.browser() && this.browser()._resourceCache;
	
	if (cache && cache[href]) {
		return cache[href];
	};
	return null;
};

PlayerPage.prototype.isLoading = function (){
	return !(this.loaded());
};

PlayerPage.prototype.toJSON = function (){
	// we want to be able to serialize the data from client and ignore the style inside live nodes
	var json = {
		html: [this.serializeNode(this.html(),false,true),this.serializeAttributes(this.html())],
		logs: this.logs().data(),
		status: this.status(),
		url: this._options.url
	};
	
	return json;
};

PlayerPage.prototype.doc = function (){
	return this._document;
};

PlayerPage.prototype.scrollingElement = function (){
	if (false && App.api().ua().isIOS()) {
		return this.space().browser()._node._body.dom();
	};
	
	return this.doc().scrollingElement;
};

PlayerPage.prototype.selectionDidSet = function (op,old){
	this._selectionDidChange = true;
	if (op) {
		var anchor = op.NODE;
		return op.ENDNODE || (op.ENDNODE = op[3] ? this.nodeForPath(op[3]) : anchor);
	};
};

PlayerPage.prototype.render = function (window){
	var document = window.document;
	var docEl = document.documentElement;
	
	if (docEl != this._html) {
		this._document = document;
		if (docEl) {
			document.replaceChild(this._html,docEl);
		} else {
			document.appendChild(this._html);
		};
	};
	
	// should rather check syncedFocusNode vs prevFocusNode
	if (this._focusNodeSynced != this._focusNode) {
		var old = this._focusNodeSynced;
		var new$ = this._focusNode;
		if (old && old.classList) {
			old.classList.remove('__focus');
		};
		if (new$ && new$.classList) {
			new$.classList.add('__focus');
		};
		this._focusNodeSynced = this._focusNode;
	};
	
	if (this._hoverNodeSynced != this._hoverNode) {
		this.refreshPseudoClass('__hover',this._hoverNode,this._hoverNodeSynced);
		this._hoverNodeSynced = this._hoverNode;
	};
	
	if (this._activeNodeSynced != this._activeNode) {
		this.refreshPseudoClass('__active',this._activeNode,this._activeNodeSynced);
		this._activeNodeSynced = this._activeNode;
	};
	
	if (this._selectionDidChange) {
		this.applySelection(window);
		this._selectionDidChange = false;
	};
	
	return this;
};

PlayerPage.prototype.detach = function (){
	return this;
};

PlayerPage.prototype.indexNode = function (node){
	if (!node.hasChildNodes()) {
		let len = this._nodes.push(node);
		node.SCRIMBA_INDEX = len - 1;
		return this;
	};
	
	var show = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT;
	var walker = this.doc().createNodeIterator(node,show,null);
	var item;
	while (item = walker.nextNode()){
		if ((item.nodeName == 'BASE' || item.nodeName == 'STYLE') && item.dataset.scrimbaInternal) { continue; };
		item.SCRIMBA_INDEX = this._nodes.push(item) - 1;
	};
	
	return this;
};

PlayerPage.prototype.reindexNodes = function (){
	this._nodes = [];
	this.indexNode(this._root);
	return this;
};

PlayerPage.prototype.nodeForPath = function (path){
	return this._nodes ? this._nodes[path] : null;
};

PlayerPage.prototype.serializeAttributes = function (node){
	var attrs = [];
	
	Array.from(node.attributes).forEach(function(attr) {
		let key = SCON.keyToRef(attr.name);
		attrs.push(key);
		return attrs.push(attr.value || null);
	});
	
	return attrs;
};

// copied from Recorder. Should split out probably, or create a recorder for this
PlayerPage.prototype.serializeNode = function (node,force,excludeSelf){
	return helpers.serializeNode(this.doc(),node,force,excludeSelf);
};

PlayerPage.prototype.deserializeNode = function (value){
	if ((typeof value=='number'||value instanceof Number)) {
		return this.nodeForPath(value);
	} else {
		return this.nodeForHTML(value);
	};
};

PlayerPage.prototype.nodeForHTML = function (html){
	if (html instanceof Array) {
		// really?
		html = "<div>placeholder</div>";
	} else if (html.text) {
		return this.doc().createTextNode(html.text);
	} else if (html.comment) {
		return this.doc().createComment(html.comment);
	} else if (html.TYPE == 8) {
		return this.doc().createComment(html.value);
	};
	
	var type = html.slice(1).match(/^\w+/)[0];
	var wrap = this.doc().createElement(parentForNodeType[type] || 'div');
	wrap.innerHTML = html;
	var ele = (type == 'body') ? wrap.lastElementChild : wrap.firstElementChild;
	return ele;
};

PlayerPage.prototype.cleanTextSplitters = function (node){
	
	var walker = this.doc().createNodeIterator(node,NodeFilter.SHOW_COMMENT,null);
	var item;
	while (item = walker.nextNode()){
		if (item.textContent == '§S§') {
			item.parentNode.removeChild(item);
		} else if (item.textContent == '§S§B') {
			item.parentNode.replaceChild(this.doc().createTextNode(""),item);
		};
	};
	return node;
};

PlayerPage.prototype.rewriteImageSrc = function (img){
	if (img.src.startsWith(this.baseURI())) {
		let rel = img.src.substr(this.baseURI().length);
		let fullPath = this.resolvePath(("/" + rel));
		if (fullPath) { return img.src = fullPath };
	};
};

PlayerPage.prototype.rewriteLinkHref = function (node){
	let resource = this.lookupResource(node.getAttribute('href'));
	// let url = URL.new(node.getAttribute('href'),@href)
	// let href = url:href
	// console.log "rewriteLinkHref",node,resource
	
	if (resource) {
		let style = document.createElement('style');
		style.textContent = resource.body;
		style.dataset.scrimbaInternal = true;
		node.parentNode.replaceChild(style,node);
	};
	
	return this;
};

PlayerPage.prototype.rewriteSrc = function (node){
	for (let i = 0, items = iter$(node.querySelectorAll('img[src]')), len = items.length; i < len; i++) {
		this.rewriteImageSrc(items[i]);
	};
	
	for (let i = 0, items = iter$(node.querySelectorAll('link[href]')), len = items.length; i < len; i++) {
		this.rewriteLinkHref(items[i]);
	};
	
	return node;
};

PlayerPage.prototype.applyInitialState = function (op){
	// console.log "applyInitialState",op
	// inject basehref here?
	var html = op[0];
	
	var tree = op[2];
	
	// set url correctly
	// TODO only if external?
	this._base.href = this.href();
	
	// inject base
	html = html.replace(/(<\s*head[^\>]*>)/,"$1" + this._base.outerHTML);
	html = helpers.deserializeReferences(html,{BASECSS: baseCSS});
	// console.log "initialhtml",html
	this._html.innerHTML = html;
	
	if (op[0].indexOf('§S§') >= 0) {
		this.cleanTextSplitters(this._html);
	};
	
	this.rewriteSrc(this._html);
	this.applyAttributes(this._html,op[1]);
	// @html:firstElementChild.appendChild(@base)
	this.reindexNodes();
	this._currentStyleSheets = {};
	return this;
};

PlayerPage.prototype.applyAttributes = function (node,pairs){
	if (!pairs) { return };
	
	var i = 0;
	var l = pairs.length;
	while (i < l){
		let name = SCON.refToKey(pairs[i]);
		let val = pairs[i + 1];
		node.setAttribute(name,val);
		i += 2;
	};
	return;
};

PlayerPage.prototype.applyMutations = function (muts){
	if (this._errored) { return };
	
	// console.log 'applying mutations!!',muts
	var node;
	var reindex = false;
	
	for (let i = 0, items = iter$(muts), len = items.length, mut; i < len; i++) {
		mut = items[i];
		if (mut[0] == M.INSERT) {
			reindex = true;
			var parentNode = this.nodeForPath(mut[1]);
			var insertIndex = mut[2];
			var nodeToInsert = mut.NODE || (mut.NODE = this.deserializeNode(mut[3]));
			
			var rel = parentNode.childNodes[insertIndex];
			if (rel) {
				// console.log 'insert at index?',rel
				parentNode.insertBefore(nodeToInsert,rel);
			} else {
				parentNode.appendChild(nodeToInsert);
			};
			
			this.indexNode(nodeToInsert);
		} else if (mut[0] == M.INSERT_ADJACENT) {
			// console.log 'INSERT_ADJACENT',mut
			reindex = true;
			
			let relNode = mut.RELNODE || (mut.RELNODE = this.nodeForPath(mut[1]));
			let relPos = M.POS[mut[2]];
			
			// if this has already been applied before - just redo
			if (mut.NODES) {
				for (let j = 0, ary = iter$(mut.NODES), len = ary.length, el; j < len; j++) {
					el = ary[j];
					if (mut[2] == 0) { // beforebegin
						relNode.parentNode.insertBefore(el,relNode);
					} else if (mut[2] == 2) { // beforeend
						relNode.appendChild(el); // .insertAdjacentElement( relPos, el )
					} else {
						console.log("node not added in M.INSERT_ADJACENT!!",mut);
					};
				};
				// continue?
				continue;
			};
			
			let elements = mut[3];
			let relPrev = relNode.previousSibling;
			let relNext = relNode.nextSibling;
			let relPar = relNode.parentNode;
			let relLastChild = relNode.lastChild;
			let mockNode = null;
			let mockHTML = '';
			
			// if we have preindexed items -- skip indexing these
			let skipIndexing = [];
			
			/*
							We need to track which events we are adding. Since
							insertAdjacentHTML could add several elements we want a
							clean general way to track it. The easiest is to simply
							look at the common parent -- then iterate over all of them
							at the end
							*/
			
			
			// if we are supposed to insert before a non-element node
			// we need to hack around it to still allow using insertAdjacent
			if (mut[2] == 0 && relNode.nodeType != Node.ELEMENT_NODE) {
				
				mockNode = document.createElement('span');
				relPar.insertBefore(mockNode,relNode);
				relNode = mockNode;
			};
			
			if (typeof elements == 'number') {
				let insNode = this.nodeForPath(elements);
				relNode.insertAdjacentElement(relPos,insNode);
				skipIndexing.push(insNode); // should it skip though?
				mut.NODES = [insNode];
				if (mockNode) { relPar.removeChild(mockNode) };
				continue;
			} else if (typeof elements == 'string') {
				if (relNode.nodeName == 'HTML') {
					let element = this.nodeForHTML(elements);
					relNode.insertAdjacentElement(relPos,element);
				} else {
					relNode.insertAdjacentHTML(relPos,elements);
				};
				mockHTML += elements;
			} else {
				// add all the nodes into a shared node first?
				// or add a helpernode at the first place and remove it later
				for (let i = 0, ary = iter$(elements), len = ary.length, el; i < len; i++) {
					el = ary[i];
					if (typeof el == 'string') {
						if (relNode.nodeName == 'HTML') {
							let element = this.nodeForHTML(el);
							relNode.insertAdjacentElement(relPos,element);
						} else {
							relNode.insertAdjacentHTML(relPos,el);
						};
						mockHTML += el;
					} else if (typeof el == 'number') {
						let insNode = this.nodeForPath(el);
						relNode.insertAdjacentElement(relPos,insNode);
						skipIndexing.push(insNode);
					};
				};
			};
			
			// not needed for single preindexed elements
			let addEl;
			let addedElements = [];
			
			// are there textsplitters here we need to erase?
			if (mockHTML.indexOf('§S§') >= 0) {
				this.cleanTextSplitters(relPar);
			};
			
			if (relPos == 'beforeend') {
				addEl = relLastChild ? relLastChild.nextSibling : relNode.firstChild;
			} else if (relPos == 'beforebegin') {
				addEl = relPrev ? relPrev.nextSibling : relPar.firstChild;
			};
			
			while (addEl){
				if (addEl == relNode) { break; };
				
				if (skipIndexing.indexOf(addEl) < 0) {
					// should we really skip?
					this.indexNode(addEl);
				};
				
				addedElements.push(addEl);
				addEl = addEl.nextSibling;
			};
			
			if (mockNode && mockNode.parentNode == relPar) {
				relPar.removeChild(mockNode);
			};
			// console.log "added elements",addedElements
			mut.NODES = addedElements;
		} else if (mut[0] == M.REMOVE) {
			reindex = true;
			// var node = nodeForPath(mut[1])
			if (node = (mut.NODE || (mut.NODE = this.nodeForPath(mut[1])))) {
				// to remember where to reinsert it?
				// what if the sibling is also altered within the same mutation?
				mut.REL || (mut.REL = node.nextSibling);
				mut.PARENT || (mut.PARENT = node.parentNode);
				
				if (node.parentNode) {
					node.parentNode.removeChild(node);
				} else {
					console.warn("M.REMOVE has no parent",node,node.parentNode,mut,mut.PARENT);
				};
			};
		} else if (mut[0] == M.SETTEXT) {
			if (node = mut.NODE = this.nodeForPath(mut[1])) {
				mut.PREV = node.textContent;
				node.textContent = patchString(mut.PREV,mut[2]);
			};
		} else {
			node = mut.NODE = this.nodeForPath(mut[1]);
			
			if (node && mut[0] == M.SETPROP) {
				var key = M.NAME_MAP[mut[2]] || mut[2];
				mut.PREV || (mut.PREV = node[key]);
				node[key] = mut[3];
			} else if (node && mut[0] == M.SETATTR) {
				key = M.NAME_MAP[mut[2]] || mut[2];
				mut.PREV || (mut.PREV = node.getAttribute(key));
				
				if (key == 'class') {
					mut.STATEFLAGS || (mut.STATEFLAGS = node.className.split(" ").filter(function(f) { return f.match(/^__\w+/); }));
				};
				
				if (node.nodeName == "STYLE" || node.nodeName == "LINK") {
					// do nothing
				} else if (mut[3] == null) {
					node.removeAttribute(key);
				} else {
					node.setAttribute(key,mut[3]);
				};
				
				if (node.nodeName == 'IMG' && key == 'src') {
					this.rewriteImageSrc(node);
				};
				
				if (mut.STATEFLAGS) {
					// add stateflags afterwards
					mut.STATEFLAGS.map(function(f) { return node.classList.add(f); });
				};
			};
		};
	};
	
	if (reindex) this.reindexNodes();
	return this;
};

PlayerPage.prototype.revertMutations = function (muts){
	if (this.errored()) { return };
	
	var node;
	var reindex = false;
	var nr = len$(muts) - 1;
	
	while (nr >= 0){
		var mut = muts[nr--];
		// we should remove it instead
		if (mut[0] == M.INSERT) {
			reindex = true;
			if (node = mut.NODE) {
				if (node.parentNode) {
					node.parentNode.removeChild(node);
				} else {
					console.warn("revert INSERT - no parent!",node);
				};
			};
		} else if (mut[0] == M.INSERT_ADJACENT) {
			reindex = true;
			for (let i = 0, items = iter$(mut.NODES), len = items.length, node; i < len; i++) {
				node = items[i];
				if (node.parentNode) {
					node.parentNode.removeChild(node);
				} else {
					console.warn("revert INSERT_ADJACENT - no parent!",node,mut);
				};
			};
		} else if (mut[0] == M.REMOVE) {
			reindex = true;
			// insert it where it was when removed.. including index?
			var par = mut.PARENT;
			mut.REL ? par.insertBefore(mut.NODE,mut.REL) : par.appendChild(mut.NODE);
		} else if (mut[0] == M.SETTEXT && mut.NODE) {
			mut.NODE.textContent = mut.PREV;
		} else if (mut[0] == M.SETPROP && mut.NODE) {
			var key = M.NAME_MAP[mut[2]] || mut[2];
			mut.NODE[key] = mut.PREV;
		} else if (mut[0] == M.SETATTR && mut.NODE) {
			key = M.NAME_MAP[mut[2]] || mut[2];
			
			if (mut.PREV == null) {
				mut.NODE.removeAttribute(key);
			} else {
				mut.NODE.setAttribute(key,mut.PREV);
			};
		};
	};
	
	if (reindex) this.reindexNodes();
	return this;
};

// FIXME if the dom has mutated since earler, moving upwards is not enough
// we need to keep an actual reference to all the nodes we flagged with hover
// to make sure we clean up the classes when changing
PlayerPage.prototype.refreshPseudoClass = function (flag,new$,old){
	// remove hover classes upwards
	while (old && old != this._root && (!(new$) || !old.contains(new$))){
		if (old.classList) {
			old.classList.remove(flag);
		};
		old = old.parentNode;
	};
	
	// old.removeAttribute('mhover') if old
	// new.setAttribute('mhover','hover') if new
	while (new$ && new$ != this._root && this._root.contains(new$)){
		if (new$.classList) { new$.classList.add(flag) };
		new$ = new$.parentNode;
	};
	return;
};

PlayerPage.prototype.applySelection = function (window){
	var op = this.selection();
	
	var sel = window.getSelection();
	
	if (!sel) { return };
	
	if (!op || !op.NODE || op.NODE == this._document.body) {
		if (sel) { sel.removeAllRanges() };
		return this;
	};
	
	var anchor = op.NODE;
	var a = op[1];
	var b = op[2];
	var endNode = op.ENDNODE;
	
	if (anchor.nodeName == 'INPUT' || anchor.nodeName == 'TEXTAREA') {
		var reg = /text|search|password|tel|url/;
		
		if (anchor.nodeName == 'INPUT' && !reg.test(anchor.type)) {
			return;
		};
		
		if (a < b) {
			return anchor.setSelectionRange(a,b,'forward');
		} else if (a > b) {
			return anchor.setSelectionRange(b,a,'backward');
		} else {
			return anchor.setSelectionRange(a,b,'none');
		};
	} else {
		// if anchor:nodeType == 3
		var range = this.doc().createRange();
		
		if (anchor != endNode) {
			var diff = anchor.compareDocumentPosition(endNode); //  & Node.DOCUMENT_POSITION_FOLLOWING
			var preceding = diff & Node.DOCUMENT_POSITION_PRECEDING;
			// console.warn "SELECTION",diff,preceding
			
			if (preceding) {
				range.setStart(endNode,b);
				range.setEnd(anchor,a);
			} else {
				range.setStart(anchor,a);
				range.setEnd(endNode,b);
			};
		} else {
			// text
			if (anchor.nodeType == 3) {
				a = Math.min(anchor.length,a);
				b = Math.min(anchor.length,b);
			};
			
			if (a <= b) {
				range.setStart(anchor,a);
				range.setEnd(anchor,b);
			} else {
				range.setStart(anchor,b);
				range.setEnd(anchor,a);
			};
			if (a == b) {
				range.collapse(false);
			};
		};
		
		sel.removeAllRanges();
		return sel.addRange(range);
	};
};

PlayerPage.prototype.syncStyleSheets = function (files){
	// if @html:parentNode == null
	// 	return
	let res = [];
	for (let i = 0, items = iter$(files), len = items.length, file; i < len; i++) {
		file = items[i];
		if (file.lang() == 'css') {
			var path = file.path();
			if (!path.startsWith(this.browser().rootPath())) {
				continue;
			};
			
			path = path.slice(len$(this.browser().rootPath()) - 1);
			var body = file.currentBody();
			res.push((this._currentStyleSheets[path] != body) && (
				this._currentStyleSheets[path] = body,
				
				this.setCSSText(path,styleProcessor.process(body,{rewritePseudoStates: true}))
			));
		};
	};
	return res;
};

PlayerPage.prototype.setCSSText = function (path,text){
	// FIXME no support for multiple stylesheets referencing the same file
	var node;
	var name = path.slice(1);
	if (node = this.html().querySelector(("style[scrimba-live='" + path + "'],style[scrimba-live][href='" + name + "']"))) {
		text = "/*SCRIMBA:IGNORE:START*/" + text + "/*SCRIMBA:IGNORE:END*/";
		// replace pseudo-states
		// text = text.replace(/:(hover|focus|active)\b/g) do |m,state| ".__{state}"
		return node.textContent = text;
	};
};
