function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Resource = require('../store/Resource').Resource;
var ROLES = require('../scrimba/protocol').ROLES;

function Fetcher(api,query,cursor){
	this._api = api;
	this._query = query;
	this._startedAt = Date.now();
	this._data = {};
	this._cursor = cursor;
	this._selects = [];
	this._models = [];
	this._autoDependents = [];
};

exports.Fetcher = Fetcher; // export class 
Fetcher.prototype.api = function(v){ return this._api; }
Fetcher.prototype.setApi = function(v){ this._api = v; return this; };
Fetcher.prototype.data = function(v){ return this._data; }
Fetcher.prototype.setData = function(v){ this._data = v; return this; };
Fetcher.prototype.models = function(v){ return this._models; }
Fetcher.prototype.setModels = function(v){ this._models = v; return this; };

Fetcher.prototype.uid = function (){
	return this._api.uid();
};

Fetcher.prototype.q = function (table,o){
	if(o === undefined) o = {};
	o.table = table;
	let v = o.v = (this._cursor[table] || 0);
	let sel = this.api().knex().table(table);
	sel = sel.select();
	// sel = o:full ? sel.select : sel.select('id','v')
	
	if (this._raw && v > 0 && !o.list) {
		sel = sel.where('v','>',v);
		// if v > 0 and !o:list and !o:full
	};
	sel._ctx = o; // queryContext(o) if o
	this._selects.push(sel);
	return sel;
};

Fetcher.prototype.run = function (o){
	if(o === undefined) o = {};
	this._options = o;
	this._raw = o.raw;
	
	if (this._query instanceof Array) {
		return this[this._query[0]].apply(this,this._query.slice(1));
	} else {
		return this[this._query]();
	};
};

Fetcher.prototype.get = async function (id){
	if (!id) { return null };
	if (!this.api().db().has(id)) { await this.api().db().fetch(id) };
	let item = this.api().db().get(id);
	this.include(item);
	return item;
};

Fetcher.prototype.getUserRoles = async function (uid){
	var roles = {};
	var links = await this.api().knex().table('entities').whereRaw("roles \\? ?",[uid]);
	for (let i = 0, items = iter$(links), len = items.length, link; i < len; i++) {
		link = items[i];
		roles[link.id] = link.roles[uid];
	};
	return roles;
};

Fetcher.prototype.include = function (item,collection){
	if(collection === undefined) collection = this._models;
	if (item instanceof Array) {
		for (let j = 0, items = iter$(item), len = items.length, i; j < len; j++) {
			i = items[j];
			if (i) { this.include(i,collection) };
		};
		return collection;
	};
	
	if ((typeof item=='string'||item instanceof String)) {
		item = this.api().db().get(item);
	};
	
	if (item && collection.indexOf(item) == -1) {
		if (item instanceof Resource) {
			collection.push(item);
			if (item.dependsOn) {
				// call autofetch here?
				this.include(item.dependsOn(),collection);
			};
		};
	};
	return collection;
};

Fetcher.prototype.tagged = function (sel,tags){
	let tagsraw = "'" + tags.map(function(_0) { return _0; }).join("','") + "'";
	return sel.whereRaw(("tags && array[" + tagsraw + "]"),[]);
};

Fetcher.prototype.finalize = async function (){
	this._fetches = await Promise.all(this._selects);
	
	var versions = {};
	
	for (let o = this.data(), val, i = 0, keys = Object.keys(o), l = keys.length, key; i < l; i++){
		key = keys[i];val = o[key];this.include(val);
	};
	
	for (let i = 0, ary = iter$(this._fetches), len = ary.length, items; i < len; i++) {
		items = ary[i];
		let ctx = this._selects[i]._ctx || {};
		let store = this.api().db().stores()[ctx.table];
		let typ = store._name;
		// let vmax = ctx:v or 0
		
		if (ctx.list) {
			// only include items that are allowed?
			this.data()[ctx.list] = items.map(function(item) { return item.id; });
		};
		
		// skipping items that are not newer than client version
		for (let j = 0, array = iter$(items), len = array.length, item; j < len; j++) { // when item:v > ctx:v
			item = array[j];
			let v = item.v;
			store.read(item);
			this.include(item.id);
			if (this._raw && (!versions[typ] || v > versions[typ])) {
				versions[typ] = v;
			};
		};
		
		// versions[ctx:table] = Math.max(vmax,versions[ctx:table] or 0)
	};
	await this.api().db().autosync();
	
	if (this._raw) {
		return [null,null,versions];
	};
	
	// we need to do it at the model-level instead, after including
	var models = [];
	
	for (let i = 0, items = iter$(this._models), len = items.length, model; i < len; i++) {
		model = items[i];
		if (!model) { continue; };
		let typ = model._ns;
		let v = model.v;
		if (!versions[typ] || v > versions[typ]) {
			versions[typ] = v;
		};
		
		if (!this._cursor[typ] || v > this._cursor[typ]) {
			// only include models that are allowed
			// console.log "check model",model:id,api.secrets
			if (!model.allowed || model.allowed('read',this.api())) { models.push(model) };
		};
	};
	
	console.log("fetcher",this._query,Date.now() - this._startedAt,this._models.length,models.length,versions);
	return [this._data,models,versions];
};

// add methods for each one
Fetcher.prototype.home = function (){
	// should be prefetched by common
	// q(:topics).orderBy('id','desc').whereNotNull('logo').limit(24)
	this.q('entities',{list: 'courses'}).where({type: 'course'}).whereNotNull('pubts').orderBy('pubts','desc').limit(16);
	
	// q(:users).where('karma','>',100).orderBy('karma','desc').limit(16)
	return this;
	
	// uid && q(:viewings).where(uid: uid).orderBy('updated_at','desc').limit(16)
};

Fetcher.prototype.space = function (id){
	if (id[0] == 'e') {
		return this.entity(id);
	};
};

// stuff loaded for the client - always
Fetcher.prototype.common = function (){
	this.q('topics',{list: 'topics'}).orderBy('id','asc');
	return this;
};

Fetcher.prototype.cast = function (id){
	return this.space(id);
};

Fetcher.prototype.note = async function (id){
	let note = this.data().note = await this.get(id); // sdb.notes.get(query[1])
	// nested replies?
	if (note) {
		if (note.nid) { this.q('notes').where({id: note.nid}) };
		if (note.cid) { this.q('spaces').where({id: note.cid}) };
	};
	
	// preload replies?
	this.q('notes',{list: 'replies'}).where({nid: id}).orderBy('cretime','desc');
	
	return this;
};

Fetcher.prototype.topic = async function (id){
	// deprecate
	console.log("fetch topic!!!",id);
	this.data().model = await this.get(id);
	this.q('entities',{list: 'entities'}).whereRaw("topics @> array[?]",[id]);
	this.q('users',{list: 'members'}).whereRaw("topics @> array[?]",[id]).whereNotNull('username').orderBy('karma','desc').orderBy('created_at','asc').limit(24);
	// q(:groups, list: 'courses').whereRaw("tags @> array[?]",[id])
	// q(:spaces, list: 'spaces').whereRaw("tags @> array[?]",[id])
	// q(:notes, list: 'notes').where(nid: null).whereRaw("tags @> array[?]",[id])
	return this;
};

Fetcher.prototype.group = async function (id){
	this.data().group = await this.get(id);
	this.q('spaces',{list: 'spaces'}).where({gid: id});
	this.q('playlists').where({gid: id});
	this.q('notes').where({gid: id});
	this.q('groups').where({type: 'course'}).whereNotNull('coverart').orderBy('created_at','desc').limit(16);
	// TODO all users should not get all memberships(!)
	if (this.uid()) { this.q('memberships').where({gid: id,uid: this.uid()}) };
	return this;
};

Fetcher.prototype.courses = function (){
	// public and private?!
	this.q('entities',{list: 'items'}).where({type: 'course'});
	return this;
};

Fetcher.prototype.topics = function (){
	// top level only?
	this.q('topics',{list: 'items'}).where({type: 'topic'});
	return this;
};

Fetcher.prototype.playlist = async function (id){
	this.data().playlist = await this.get(id);
	return this;
};

Fetcher.prototype.templates = function (){
	this.q('spaces').where({type: 'template',privacy: 'public'}).whereNull('archived_at');
	return this;
};

Fetcher.prototype.viewings = function (){
	this.q('viewings').where({uid: this.uid()});
	return this;
};

Fetcher.prototype.me = async function (){
	// data for user
	this.data().user = await this.get(this.uid());
	this.q('entities').where({uid: this.uid()});
	this.q('links').where({uid: this.uid()});
	// deprecate soon
	// q(:spaces).where(uid: uid)
	// q(:groups).where(creator_id: uid)
	// q(:playlists).where(uid: uid)
	// q(:memberships).where(uid: uid)
	return this;
};

Fetcher.prototype.entity = async function (id){
	console.log("fetching entity",id);
	this.data().model = await this.get(id);
	this.q('entities').whereRaw("path ~ ?",[("*." + id + ".*\{0,3\}")]);
	return this;
};

Fetcher.prototype.ls = async function (ref){
	// not for id
	let item = await this.api().knex().table('entities').where({ref: ref}).first();
	console.log("found item?");
	this.data().model = item;
	// should we wait for this?
	this.q('entities',{list: 'items'}).where('ref','like',ref + '/%');
	return this;
};

Fetcher.prototype.members = async function (eid){
	this.data().model = await this.get(eid);
	// check permissions - are we allowed to see members?
	this.q('links',{list: 'members'}).where({eid: eid}).where('role','>',0).limit(100); //  .whereRaw("path ~ ?",["*.{id}.*\{0,3\}"])
	return this;
};


Fetcher.prototype.status = async function (){
	this.data().user = await this.get(this.uid());
	if (this.uid()) {
		var roles = await this.getUserRoles(this.uid());
		var eids = Object.keys(roles);
		
		if (len$(eids)) {
			// will fetch everything now
			this.q('entities').whereRaw("path ~ ?",[("*." + eids.join('|') + ".*\{0,3\}")]).orWhere({uid: this.uid()});
		};
		
		// q(:entities).where(uid: uid)
		// q(:entities).whereRaw("id in (select eid from links where uid = ?)",uid)
		this.q('links').where({uid: this.uid()});
	};
	
	return this;
};

Fetcher.prototype.userdata = function (uid){
	this.q('links').where({uid: uid});
	return this;
};

Fetcher.prototype.user = async function (ref){
	if (ref[0] == '@') {
		let user = await this.api().knex().table('users').where({username: ref.slice(1)}).first();
		this.api().db().read(user);
		ref = user.id;
	};
	
	this.data().model = await this.get(ref);
	this.q('users').where({id: ref});
	this.q('entities').where({uid: ref}); // .whereNotNull('pubtime')
	// q(:notes).where(uid: ref).whereNotNull('pubtime')
	// q(:spaces).where(uid: ref)
	// q(:playlists).where(uid: ref)
	// q(:groups).where(creator_id: ref) # what about privacy?
	return this;
};

// for loading data related to a user that we want to exist - synchronously
Fetcher.prototype.userState = function (id){
	if(id === undefined) id = this.uid();
	if (!(this.uid())) { return this };
	// console.log "userState for user?!",uid
	this.q('memberships',{full: true}).where({uid: this.uid()});
	this.q('reactions',{full: true}).where({uid: this.uid()});
	return this;
};
