function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var animlib = require('../../site/utils/anim.js');

function SlideAnimator(slide,svg,steps){
	var self = this;
	self._slide = slide;
	self._space = slide.space();
	self._svg = svg;
	self._steps = steps;
	self._time = 0;
	self._duration = 0;
	self._stops = [];
	self._animations = [];
	self._updater = function(val) { return self.update(val); };
	self.build();
	self;
};


exports.SlideAnimator = SlideAnimator; // export class 
SlideAnimator.prototype.svg = function(v){ return this._svg; }
SlideAnimator.prototype.setSvg = function(v){ this._svg = v; return this; };
SlideAnimator.prototype.space = function(v){ return this._space; }
SlideAnimator.prototype.setSpace = function(v){ this._space = v; return this; };
SlideAnimator.prototype.steps = function(v){ return this._steps; }
SlideAnimator.prototype.setSteps = function(v){ this._steps = v; return this; };
SlideAnimator.prototype.duration = function(v){ return this._duration; }
SlideAnimator.prototype.setDuration = function(v){ this._duration = v; return this; };
SlideAnimator.prototype.animations = function(v){ return this._animations; }
SlideAnimator.prototype.setAnimations = function(v){ this._animations = v; return this; };
SlideAnimator.prototype.__animator = {watch: 'animatorDidSet',name: 'animator'};
SlideAnimator.prototype.animator = function(v){ return this._animator; }
SlideAnimator.prototype.setAnimator = function(v){
	var a = this.animator();
	if(v != a) { this._animator = v; }
	if(v != a) { this.animatorDidSet && this.animatorDidSet(v,a,this.__animator) }
	return this;
};
SlideAnimator.prototype.__currentStep = {'default': -1,watch: 'currentStepDidSet',name: 'currentStep'};
SlideAnimator.prototype.currentStep = function(v){ return this._currentStep; }
SlideAnimator.prototype.setCurrentStep = function(v){
	var a = this.currentStep();
	if(v != a) { this._currentStep = v; }
	if(v != a) { this.currentStepDidSet && this.currentStepDidSet(v,a,this.__currentStep) }
	return this;
}
SlideAnimator.prototype._currentStep = -1;

SlideAnimator.prototype.build = function (){
	var self = this;
	for (let i = 0, items = iter$(self.steps()), len = items.length, step; i < len; i++) {
		step = items[i];
		let stepDur = 0;
		step.T0 = self.duration();
		step[0].map(function(anim) {
			let t0 = step.T0;
			
			// animation for slide itself?
			if (anim[6] == 2) {
				return;
			};
			
			anim.EL = self.svg().querySelector('#' + anim[1]); // svg.getElementById(anim[1])
			let dur = anim.DUR = anim[2];
			let delay = anim.DELAY = anim[3];
			// create the animator here?
			stepDur = Math.max(stepDur,anim.DELAY + anim.DUR);
			anim.PROGRESS = 1;
			
			anim.UPDATE = function(t) {
				let relTime = Math.max(Math.min(t - t0 - delay,dur),0);
				let relPct = relTime / dur;
				let prevPct = this.PROGRESS;
				let el = this.EL || (this.EL = self.svg().querySelector('#' + anim[1])); // svg.getElementById(this[1])
				// no need to do anything if animation is already at correct step
				if (prevPct == relPct || !this.EL) {
					return;
				};
				
				this.PROGRESS = relPct;
				
				let obj = this.EL.style;
				
				for (let j = 0, ary = iter$(this[0]), len = ary.length, fx; j < len; j++) {
					fx = ary[j];
					let val;
					
					if (fx[0] == 0) { // FADE IN/OUT
						val = fx[1] + (fx[2] - fx[1]) * relPct;
						obj.opacity = val;
					} else if (fx[0] == 3) { // SLIDE IN/OUT
						let eased = animlib.easings.easeInOutCubic(relPct,0,1,1);
						let x = fx[1] + (fx[3] - fx[1]) * eased;
						let y = fx[2] + (fx[4] - fx[2]) * eased;
						// console.log "found slide anim!!!",x,y,fx[1],fx[3]
						obj.transform = ("translate(" + (x * 100) + "%," + (y * 100) + "%)");
					};
				};
				return;
			};
			
			return self._animations.push(anim);
		});
		
		self.setDuration(self.duration() + stepDur);
		step.T1 = self.duration(); // there is an actual pause here after this step
	};
	return self;
};

SlideAnimator.prototype.reset = function (){
	this._time = this.duration();
	this.update(0);
	return this;
};

SlideAnimator.prototype.update = function (t1){
	let t0 = this._time;
	let anims = this.animations();
	// move through steps between t0 and t1 to get to the correct starting pos
	// console.log "anim update",t0,t1
	// console.log "update",t1,Date.now
	
	if (t1 > t0) {
		for (let i = 0, items = iter$(anims), len = items.length; i < len; i++) {
			items[i].UPDATE(t1,t0);
		};
	} else if (t1 < t0) {
		let i = len$(anims);
		while (i > 0){
			anims[--i].UPDATE(t1,t0);
		};
	};
	this._time = t1;
	return this;
};

SlideAnimator.prototype.animate = function (from,to,dur){
	if (dur == undefined) {
		dur = Math.abs(to - from);
	};
	// console.log "animate",from,to,dur
	this.setAnimator(animlib.animate(from,to,dur,this._updater,'linear'));
	return this;
};

SlideAnimator.prototype.animatorDidSet = function (animator,prev){
	if (prev) { return prev.cancel() };
};

SlideAnimator.prototype.currentStepDidSet = function (value,prev){
	let t = 0;
	let step = this._steps[value];
	if (step) {
		t = step.T1;
	};
	
	this.setAnimator(null);
	// animate forward
	if ((value - prev) == 1) {
		// continue animating from previous?
		let dur = (step.T1 - step.T0) / (this.space().timeline().playbackRate() || 1);
		this.animate(step.T0,t,dur);
	} else {
		
		this.update(t);
	};
	return this;
};
