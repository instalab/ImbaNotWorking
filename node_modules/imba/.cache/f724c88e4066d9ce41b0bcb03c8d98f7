function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Store = require('./Store').Store;

var Action = require('../models/Action').Action;
var Topic = require('../models/Topic').Topic;
var File = require('../models/File').File;
var Cast = require('../models/Cast').Cast;
var Playlist = require('../models/Playlist').Playlist;
var User = require('../models/User').User;
var Message = require('../models/Message').Message;
var Group = require('../models/Group').Group;
var Membership = require('../models/Membership').Membership;
var Viewing = require('../models/Viewing').Viewing;
var ViewSession = require('../models/ViewSession').ViewSession;

var LocalStore = require('../util/StoreWrapper').LocalStore;

var msgpack = require('msgpack-lite');

var protocol$ = require('../scrimba/protocol'), MSG = protocol$.MSG, SCON = protocol$.SCON, SPIV = protocol$.SPIV;

// FIXME We should move all app-specific stuff (models, db-connection etc)
// out from this, and structure store/* as if it was a fully separate project/module

if (true) {
	var serverDB = require("../server/db");
};

function FakePromise(){
	this._value = undefined;
	this._resolved = false;
	this._listeners = [];
	this;
};

FakePromise.prototype.then = function (cb){
	if (this._resolved) {
		cb(this._value);
	} else {
		this._listeners.push(cb);
	};
	return this;
};

FakePromise.prototype.resolve = function (value){
	this._resolved = true;
	this._value = value;
	for (let i = 0, items = iter$(this._listeners), len = items.length; i < len; i++) {
		items[i](this._value);
	};
	this._listeners = [];
	return this;
};

function DB(api){
	var self = this;
	self._api = api;
	self._ts = Date.now();
	self._dbname = 'scrimba2';
	
	self._scope = {};
	self._stores = [];
	self._prefixes = {};
	self._loadQueue = [];
	
	if (false) {} else if (true) {
		self._kvs = new LocalStore('db:' + self._dbname);
	};
	
	self._spaces = new Store(self,'spaces',Cast,{ns: 'c'});
	self._topics = new Store(self,'topics',Topic,{ns: '#'});
	self._users = new Store(self,'users',User,{ns: 'u'});
	self._messages = new Store(self,'messages',Message,{ns: 'm'});
	self._playlists = new Store(self,'playlists',Playlist,{ns: 'p'});
	self._actions = new Store(self,'actions',Action,{ns: 'a'});
	self._groups = new Store(self,'groups',Group,{ns: 'g'});
	self._memberships = new Store(self,'memberships',Membership,{ns: 'x'});
	self._viewings = new Store(self,'viewings',Viewing,{ns: 'y'});
	self._viewsessions = new Store(self,'viewsessions',ViewSession,{ns: 'v',preload: false});
	self._files = new Store(self,'files',File,{ns: 'f',preload: false});
	
	self._autosyncer = function() { return self.autosync(); };
	self._loadPromise = new FakePromise();
	self._readyPromise = new FakePromise();
	self._sync;
	
	self._local = true;
	
	if (true) {
		self.open();
	};
	self;
};

exports.DB = DB; // export class 
DB.prototype.api = function(v){ return this._api; }
DB.prototype.setApi = function(v){ this._api = v; return this; };
DB.prototype.stores = function(v){ return this._stores; }
DB.prototype.setStores = function(v){ this._stores = v; return this; };
DB.prototype.dexie = function(v){ return this._dexie; }
DB.prototype.setDexie = function(v){ this._dexie = v; return this; };
DB.prototype.scope = function(v){ return this._scope; }
DB.prototype.setScope = function(v){ this._scope = v; return this; };
DB.prototype.kvs = function(v){ return this._kvs; }
DB.prototype.setKvs = function(v){ this._kvs = v; return this; };

DB.prototype.touch = function (){
	if (false) {};
	this.time();
	return this;
};

DB.instance = function (){
	return this._instance || (this._instance = new this());
};

if (true) {
	DB.prototype.open = function (){
		var self = this;
		return serverDB.pgconnect(function(err,client) {
			// should send first immediately, but then start to delay
			// and batch if there are tons of changes over a very short period
			// leaky bucket?
			var queue = self._pusher = {
				count: 0,
				timeout: null,
				syncer: self.sync.bind(self),
				ids: [],
				models: []
			};
			client.on('notification',async function(msg) {
				var id = msg.payload;
				
				clearTimeout(queue.timeout);
				queue.timeout = setTimeout(queue.syncer,10000);
				queue.ids.push(id);
				
				var store = self.storeForId(id);
				if (store) {
					var item = await store.fetch(id);
					queue.models.push(item);
					if (len$(queue.ids) == len$(queue.models)) {
						return self.broadcastChanges();
					};
				};
			});
			
			return client.query("LISTEN changes");
		});
	};
	
	DB.prototype.broadcastChanges = function (){
		// should add some timeout for this as well?
		var ids = this._pusher.ids;
		var items = this._pusher.models;
		if (len$(items)) {
			this._pusher.models = [];
			this._pusher.ids = [];
			this._pusher.flushed = Date.now();
			this.propagate(items);
			return console.log('broadcastChanges',ids.length,ids.slice(0,100));
		};
	};
	
	
	DB.prototype.propagate = function (items){
		var self = this;
		if (self.broadcast) {
			
			var batches = {};
			
			for (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
				item = ary[i];
				let channels = item.notifyChannels();
				if (channels) {
					let batch = batches[channels] || (batches[channels] = []);
					batch.push(item);
				};
			};
			
			let serializer = function(socket,data) {
				var params = data.map(function(item) { return item.serialize({uid: socket.uid,user: self._users._map[socket.uid]}); });
				// broadcasting different versions to each socket
				var msg = [MSG.SYNC,params];
				// the encoding should happen somewhere else
				return msgpack.encode(msg);
			};
			
			for (let batch, i = 0, keys = Object.keys(batches), l = keys.length, batchname; i < l; i++){
				batchname = keys[i];batch = batches[batchname];console.log("propagate",batchname,len$(batch));
				self.broadcast(batchname,batch,null,serializer);
			};
			
			return;
			
			//  do |socket,data|
			// 	var params = data.map do |item| item.serialize(uid: socket:uid, user: @users.@map[socket:uid])
			// 	# broadcasting different versions to each socket
			// 	var msg = [MSG.SYNC,params]
			// 	# the encoding should happen somewhere else
			// 	return msgpack.encode(msg)
			
			// console.log "propagate to",items.len
		};
	};
	
	DB.prototype.autofetch = async function (){
		return await Promise.all(this.stores().map(function(store) { return store.autofetch(); }));
	};
};

if (false) {};

DB.prototype.autoload = function (item){
	if (this._loadQueue.indexOf(item) < 0) { this._loadQueue.push(item) };
	clearTimeout(this._autoloader);
	this._autoloader = setTimeout(this._autosyncer,10);
	return this;
};

DB.prototype.autosync = function (){
	if (!len$(this._loadQueue)) { return };
	var ids = this._loadQueue.filter(function(item) { return item.v == -3; }).map(function(item) { return item.id; });
	// console.log "autosync",@loadQueue.len,ids
	// what if there are too many?
	this._loadQueue = [];
	this._api.rpc('get',[ids],{models: true});
	return this;
};

DB.prototype.scoped = function (scope,blk){
	var prev = this._scope;
	this._scope = scope;
	var res = blk();
	this._scope = prev;
	return res;
};

DB.prototype.cacheKey = function (){
	return false ? true : "sdb";
};

DB.prototype.casts = function (){
	return this._spaces;
};

DB.prototype.knex = function (){
	return serverDB.db;
};

DB.prototype.storeForId = function (id){
	return this._prefixes[id[0]];
};

DB.prototype.storeDidLoad = function (store){
	if (len$(this.stores().filter(function(store) { return !store.isReady(); })) == 0) {
		this._readyPromise.resolve(this);
		return this;
	};
};

DB.prototype.storesDidLoad = function (){
	return this._readyPromise;
};

DB.prototype.get = function (id){
	if (!id) { return };
	var store = this.storeForId(id);
	return store ? store.get(id) : null;
};

DB.prototype.read = function (item,force){
	if(force === undefined) force = false;
	if (!(item && item.id)) { return };
	var store = this.storeForId(item.id);
	return store ? store.read(item,force) : null;
};

DB.prototype.put = function (item){
	return this.storeForId(item.id).put(item);
};

DB.prototype.fetch = function (id){
	if (!id) { return };
	var store = this.storeForId(id);
	return store ? store.fetch(id) : null;
};

DB.prototype.cache = function (){
	return this._cache || (this._cache = {});
};

DB.prototype.cacheGet = function (key){
	// console.log "cacheGet",key
	return Promise.resolve(this.cache()[key]);
	
	if (!this._dexie || this._inmemory) {
		return Promise.resolve(null);
	};
	
	return this._dexie.cache.get(key);
};

DB.prototype.cacheSet = function (key,val){
	// console.log "cacheSet",key
	this.cache()[key] = val;
	return Promise.resolve(true);
	
	if (!this._dexie || this._inmemory) {
		return Promise.resolve(null);
	};
	
	val.id = key;
	return this._dexie.cache.put(val);
};

DB.prototype.deserialize = function (data,force){
	if(force === undefined) force = true;
	if (data instanceof Array) {
		for (let i = 0, items = iter$(data), len = items.length; i < len; i++) {
			data[i] = this.read(items[i],force);
		};
	} else if ((data instanceof Object) && data.id) {
		data = this.read(data,force);
	};
	return data;
};


DB.prototype.preload = function (items){
	for (let i = 0, ary = iter$(items), len = ary.length; i < len; i++) {
		// we simply read these items into the db-memory
		this.read(ary[i]);
	};
	return this;
};

DB.prototype.drop = function (){
	return this;
};

DB.prototype.migrate = function (){
	return this;
};

DB.prototype.persist = function (){
	for (let i = 0, items = iter$(this.stores()), len = items.length; i < len; i++) {
		this.stores().persist();
	};
	return this;
};

DB.prototype.sync = async function (sel){
	var versions = {};
	var reqs = [];
	if (sel instanceof Object) {
		for (let v, i = 0, keys = Object.keys(sel), l = keys.length, k, store; i < l; i++){
			k = keys[i];v = sel[k];if (store = this._stores[k]) {
				reqs.push([k,v,store.lastVersion(v)]);
			};
		};
	} else if (sel instanceof Array) {
		reqs = sel;
	} else if ((typeof sel=='string'||sel instanceof String)) {
		this.stores().map(function(tbl) {
			return versions[tbl.name()] = tbl.lastVersion(sel);
		});
		reqs = [sel,versions];
	} else {
		reqs = this.stores().map(function(tbl) { return [tbl.name(),'all',sel ? (-1) : tbl.lastVersion('all')]; });
	};
	
	if (false) {} else {
		console.log("db.sync");
		var diff = await serverDB.db.syncStores(reqs);
		return this.patch(diff,reqs);
	};
};

DB.prototype.prefetch = async function (sel,api){
	var self = this;
	api || (api = self.api());
	
	// check for preloaded version
	let prev = self.kvs().getobj(sel);
	
	if (prev && (Date.now() - prev.ts) < 1000) {
		let ret = null;
		if (prev.result instanceof Array) {
			ret = prev.result.map(function(id) { return self.get(id); });
		} else if (prev.result) {
			ret = self.get(prev.result);
		};
		
		return Promise.resolve(ret);
	};
	
	var versions = {};
	
	self.stores().map(function(tbl) {
		return versions[tbl.name()] = (false ? true : 0);
	});
	
	var params = [sel,versions];
	var patch = await (false ? true : api.syncFind(sel,versions));
	
	if (!patch || len$(patch) == 0) {
		return null;
	};
	
	// read dependencies
	for (let i = 0, items = iter$(patch[1]), len = items.length; i < len; i++) {
		self.read(items[i]);
	};
	
	if (false) {};
	
	if (true) {
		api.registerPrefetched(sel,patch);
	};
	
	if (patch[0] instanceof Array) {
		return patch[0].map(function(id) { return self.get(id); });
	} else if (patch[0]) {
		return self.get(patch[0]);
	} else {
		return null;
	};
};

DB.prototype.prefetched = function (sel,result){
	for (let i = 0, items = iter$(result[1]), len = items.length; i < len; i++) {
		this.read(items[i]);
	};
	
	// get(result[0]) if result[0]
	
	for (let o = result[2], value, i = 0, keys = Object.keys(o), l = keys.length, key; i < l; i++){
		key = keys[i];value = o[key];var store = this.stores()[key];
		store.lastVersion(sel,value);
	};
	
	// mark as already fetched
	this.kvs().set(sel,{ts: Date.now(),result: result[0]});
	return this;
};

DB.prototype.patch = function (diff,reqs){
	var $1;
	this.log("patch",diff[1],reqs);
	
	var models = diff[0];
	var versions = diff[1];
	
	// for item in diff
	// 	var store = stores[item[0]]
	// 	store?.patch(item)
	
	for (let i = 0, items = iter$(models), len = items.length; i < len; i++) {
		this.read(items[i]);
	};
	
	for (let i = 0, items = iter$(versions), len = items.length; i < len; i++) {
		var req = reqs[i];
		var store = this.stores()[req[0]];
		($1 = store) && $1.lastVersion  &&  $1.lastVersion(req[1],items[i]);
	};
	return this;
};

DB.prototype.rebuild = function (){
	for (let i = 0, items = iter$(this.stores()), len = items.length; i < len; i++) {
		items[i].clear();
	};
	return this.sync(true);
};

DB.prototype.rebuildHard = function (){
	for (let i = 0, items = iter$(this.stores()), len = items.length; i < len; i++) {
		items[i].clear();
	};
	
	return setTimeout(function() { return document.location.reload(); },2000);
};

DB.prototype.syncLocal = function (){
	let res = [];
	for (let i = 0, items = iter$(this.stores()), len = items.length; i < len; i++) {
		res.push(items[i].syncLocal());
	};
	return res;
};

DB.prototype.log = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	if (false) {} else {
		return console.log.apply(console,params);
	};
};

DB.prototype.rpc = function (name,args,o){
	var self = this;
	if(o === undefined) o = {};
	var promise = self._api.rpc(name,args,o);
	var transformer = function(item) {
		if ((typeof item=='string'||item instanceof String)) {
			return self.get(item);
		} else if (item && item.id) {
			return self.read(item);
		};
	};
	
	return promise.then(function(res) {
		if (res instanceof Array) {
			return res.map(transformer);
		} else {
			return transformer(res);
		};
	});
};

DB.prototype.time = function (){
	// console.log Date.now - @ts
	return this;
};

// predefined collections
DB.prototype.presets = function (){
	return this._presets || (this._presets = this.casts().sel(function(_0) { return _0.type == 'template' && _0.spiv == SPIV; }));
};

