function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');

var db = require("./db").db;

var fs = require('fs');
var path = require('path');
var msgpack = require('msgpack-lite');
var crypto = require('crypto');

var env = require('../env');
var manifest = require('../../assets/manifest.json');
var util = require('../util');

var protocol$ = require('../scrimba/protocol'), MSG = protocol$.MSG, SCON = protocol$.SCON, ACTION = protocol$.ACTION, ROLES = protocol$.ROLES;
var DB = require('../store/db').DB;

// var DB_INSTANCE = DB.instance

var services$ = require('../services'), github = services$.github, ffmpeg = services$.ffmpeg, git = services$.git, emailer = services$.emailer, publisher = services$.publisher, entities = services$.entities, stripe = services$.stripe;

var Resource = require('../store/Resource').Resource;
var Packet = require('../scrimba/core/Packet').Packet;
var Mailchimp = require('../util/mailchimp').Mailchimp;
var Logger = require('../util/Logger').Logger;
var Fetcher = require('./fetcher').Fetcher;

var password$ = require('./password'), hashPassword = password$.hashPassword, verifyPassword = password$.verifyPassword;

var googleSlidesImporter = require('../services/google-slides-importer');

// TODO URGENT currently we expose all methods in rpc
// should prefix private methods with _ or somehow mark
// the public methods public

// Should have a client-like api wrapper around the serverside api
var UserAgent = require('../util/UserAgent').UserAgent;

function API(user,req){
	this._cache = {};
	this._secrets = {};
	this._preloads = [];
	this._logger = new Logger();
	if (user || req) { this.setup(user,req) };
	return this;
};

exports.API = API; // export class 
API.prototype.cache = function(v){ return this._cache; }
API.prototype.setCache = function(v){ this._cache = v; return this; };
API.prototype.peer = function(v){ return this._peer; }
API.prototype.setPeer = function(v){ this._peer = v; return this; };
API.prototype.__user = {watch: 'userDidSet',name: 'user'};
API.prototype.user = function(v){ return this._user; }
API.prototype.setUser = function(v){
	var a = this.user();
	if(v != a) { this._user = v; }
	if(v != a) { this.userDidSet && this.userDidSet(v,a,this.__user) }
	return this;
};
API.prototype.sid = function(v){ return this._sid; }
API.prototype.setSid = function(v){ this._sid = v; return this; };
API.prototype.ua = function(v){ return this._ua; }
API.prototype.setUa = function(v){ this._ua = v; return this; };
API.prototype.ws = function(v){ return this._ws; }
API.prototype.setWs = function(v){ this._ws = v; return this; };

API.manifest = function (){
	return manifest;
};

API.assetsPath = function (name){
	return ("/assets/" + (manifest[name] || name));
};

API.assetsUrl = function (name){
	var port;
	var portstr = '';
	if ((port = env.get('NGINX_PORT')) != 443) {
		portstr = (":" + port);
	};
	return ("https://" + env.get('HOSTNAME') + portstr + this.assetsPath(name));
};

API.spawn = async function (user,req){
	// console.log "spawning api"
	var api = new this();
	await api.setup(user,req);
	return api;
};

API.db = function (){
	return DB.instance();
};

API.prototype.stats = function (){
	return API.STATS;
};

API.prototype.platform = function (){
	return 'Server';
};

API.prototype.manifest = function (){
	return manifest;
};

API.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
API.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
API.prototype.once = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.once.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
API.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

API.prototype.log = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return this._logger.log.apply(this._logger,params);
};


API.prototype.setup = async function (user,req){
	var pid;
	this._req = req;
	
	if (req) {
		// console.log "inited api with req",req
		this._ua = new UserAgent(req.get('user-agent'));
		this._secrets = req.session && req.session.secrets || {};
		if (pid = req.get('scrimba-peer')) {
			let peer = this.db().peers().get(pid);
			if (peer && peer._secret && peer._secret == req.get('scrimba-handshake')) {
				// console.log "this is the correct peer!"
				this.setPeer(peer);
			};
		};
	};
	
	if ((typeof user=='string'||user instanceof String)) {
		user = await this.db().fetch(user);
	} else if (user) {
		user = this.db().read(user);
	};
	
	if (this._user = user) {
		await this.db().links().where({uid: user.id});
	};
	
	return this;
};

API.prototype.secrets = function (){
	return this._peer ? this._peer.secrets() : this._secrets;
};

API.prototype.userDidSet = function (user,prev){
	return this;
};

API.prototype.can = function (perm,model){
	return model.can(this,perm);
};

API.prototype.guardAllowed = async function (perm,model){
	if ((typeof model=='string'||model instanceof String)) {
		model = await this.db().summon(model);
	};
	await model.preload();
	if (!model.can(this,perm)) {
		throw "Not allowed";
	};
	return true;
};

API.prototype.sendTracking = function (){
	return null;
};

API.prototype.mailchimp = function (){
	var api_key;
	return (this._mailchimp == null) ? (this._mailchimp = (api_key = env.get('MAILCHIMP_API_KEY')) ? (
		new Mailchimp(api_key)
	) : (
		null
	)) : this._mailchimp;
};

API.prototype.filesDir = function (){
	return env.get('FILES_DIR');
};

API.prototype.assetsPath = function (name){
	return API.assetsPath(name);
};

API.prototype.assetsUrl = function (name){
	return API.assetsUrl(name);
};

API.prototype.clientVersion = function (){
	return manifest.version;
};

API.prototype.monacoPath = function (){
	return manifest.monaco;
};

API.prototype.entities = function (){
	return entities;
};

API.prototype.isEmbed = function (){
	return false;
};

API.prototype.isMobile = function (){
	return false;
};

API.prototype.db = function (){
	return DB.instance();
};

API.prototype.knex = function (){
	return db;
};

API.prototype.uid = function (){
	let user = this.user();
	return user && user.id || null;
};

API.prototype.pid = function (){
	return this._peer ? this._peer.id : null;
};

API.prototype.get = function (key){
	var self = this;
	if (key instanceof Array) {
		return key.map(function(id) {
			return self.db().get(id);
		});
	};
	
	return self.db().get(key);
};

API.prototype.load = function (key){
	var self = this;
	if (key instanceof Array) {
		return Promise.all(key.map(function(id) { return self.db().summon(id); }));
	};
	
	return self.db().summon(key);
	
	var item = self.db().get(key);
	if (item.v == -3) {
		return item.fetch();
	};
	return Promise.resolve(item);
};

API.prototype.fetch = function (item){
	return this.db().fetch(item,this);
};

API.prototype.put = function (item){
	let store = this.db().storeForId(item.id);
	return store.put(item,this);
};

API.prototype.ins = function (item,localId){
	let store = this.db().storeForId(item.id || localId);
	return store.ins(item,this);
};


API.prototype.findRaw = async function (query,cursor){
	// console.log "findRaw with secrets",secrets
	if(cursor === undefined) cursor = {};
	let fetcher = new Fetcher(this,query,cursor);
	let ns = (query instanceof Array) ? query[0] : query;
	
	if (fetcher[ns] instanceof Function) {
		await fetcher.run();
		return fetcher.finalize();
	} else {
		console.warn("could not find fetcher",ns);
		return [];
	};
};

API.prototype.find = async function (query,cursor){
	if(cursor === undefined) cursor = {};
	var result = await this.findRaw(query,cursor);
	this.registerPrefetched(JSON.stringify(query),result);
	return (result && result[0]) ? this.db().deserialize(result[0]) : null;
};

API.prototype.getCurrentUser = function (){
	return Promise.resolve(this.user() || null);
};

API.prototype.userLogin = function (user){
	var self = this;
	return new Promise(function(resolve,reject) {
		return self._req.login(user,function(err) {
			if (err) {
				return reject(err);
			} else {
				self._user = self.db().read(user);
				return resolve(self._user);
			};
		});
	});
};

// whenever a user logs in or accesses the site we ensure that the data
// needed to resolve permissions etc is loaded in store
API.prototype.userPreload = async function (){
	if (!(this.uid())) { return };
	// var out = await self.findRaw('status')
	let fetcher = new Fetcher(this,['userdata',this.uid()],{});
	await fetcher.run({raw: true});
	await fetcher.finalize();
	return;
};

API.prototype.subscribeUser = function (user){
	if (!(this.mailchimp())) { return };
	
	var mergeFields = {
		USERNAME: user.username,
		FULLNAME: user.name
	};
	
	return this.mailchimp().subscribe('1475ca4552',user.email,mergeFields).catch(function(err) { return true; });
	
	// TODO: Should we ever log the response?
};

API.prototype.authWithGitHub = async function (gh_user,authToken,refreshToken){
	console.log('gh_user',gh_user);
	
	var ghid = gh_user.id;
	var profile = {};
	
	for (let o = gh_user._json, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];if (k.indexOf('url') >= 0) { continue; };
		profile[k] = v;
	};
	
	var user = await db.table('users').where({username: profile.login}).first();
	// var tok = env.encrypt(authToken,profile:login)
	profile.email = gh_user.emails[0].value;
	
	var fields = {
		// id: user ? user:id : null
		username: profile.login,
		name: profile.name,
		email: profile.email,
		location: profile.location,
		bio: profile.bio,
		github_user_id: profile.id,
		github_profile: profile
	};
	
	if (user) {
		fields.id = user.id;
	};
	
	console.log("try to put in users",user);
	user = await db.put('users',fields);
	this._user = this.db().read(user);
	console.log("udpated user",user);
	
	try {
		await github.syncUser(user,authToken);
	} catch (e) {
		console.log("error when syncing user");
	};
	return user;
};

API.prototype.createCustomer = async function (token,eid,quantity,type){
	return await stripe.createCustomer(token,eid,quantity,type,this.user());
};

API.prototype.updateCard = async function (customerId,token,eid){
	return await stripe.updateCard(customerId,token,eid);
};

API.prototype.cancelSubscription = async function (subscriptionId,customerId,eid){
	return await stripe.cancelSubscription(subscriptionId,customerId,eid);
};

API.prototype.reactivateSubscription = async function (subscriptionId,customerId,eid){
	return await stripe.reactivateSubscription(subscriptionId,customerId,eid);
};

API.prototype.importSlidesFromGoogle = async function (url){
	var res = await googleSlidesImporter.fetch(url);
	
	for (let i = 0, items = iter$(res.slides), len = items.length, slide; i < len; i++) {
		slide = items[i];
		slide.blobId = await this.upsertBlob(slide.body);
		slide.body = null;
	};
	return res;
};

API.prototype.upsertBlob = async function (data){
	if ((typeof data=='string'||data instanceof String)) {
		data = Buffer.from(data,'utf8');
	};
	var shasum = crypto.createHash('sha1');
	shasum.update(data);
	var id = ("sha1:" + shasum.digest('hex'));
	// return Promise.resolve(id)
	var exists = await db.table('blobs').where({id: id}).first('id');
	await (!exists && db.raw('INSERT INTO blobs (id, content, uid) VALUES (?, ?, ?) ON CONFLICT DO NOTHING',[id,data,this.uid()]));
	return id;
};

API.prototype.fileCheckIntegrity = async function (id){
	var file;
	return file = await this.db().fetch(id);
};

API.prototype.fileUploaded = async function (id){
	id = id.replace(/\//g,'');
	var file = await this.fetch(id);
	var src = path.resolve(env.get('FILES_DIR') + '/' + id);
	var updates = {state: 'uploaded'};
	
	if (Imba.indexOf(file.ext(),['webm','ogg']) >= 0) {
		await ffmpeg.finalize(file,updates);
	};
	
	return new Promise(function(resolve,reject) {
		return fs.stat(src,async function(err,stat) {
			console.log("save fileUploaded",stat);
			await file.update({state: 'uploaded',size: stat.size});
			return resolve(file);
		});
	});
};

API.prototype.checkIntegrity = async function (id){
	var $1;
	var item = await this.db().fetch(id);
	var resp = ($1 = item) && $1.checkIntegrity  &&  $1.checkIntegrity();
	return resp || {status: 0};
};

API.prototype.react = async function (eid,type){
	await entities.link(this.uid(),eid,{reaction: type});
	return this.db().entities().get(eid);
};

API.prototype.link = async function (uid,eid,params){
	if (!(uid && this.uid())) { return };
	console.log("link",uid,eid,params);
	await entities.link(uid,eid,params,this.uid());
	return this.db().entities().get(eid);
};


API.prototype.trackingstream = function (sid){
	return Promise.resolve(null);
};

API.prototype.appendToTrackingStream = function (sid,payload){
	return null;
};

API.prototype.entityJoin = function (id){
	throw "not implemented";
	return;
};

API.prototype.entityLeave = function (id){
	throw "not implemented";
	return;
};

API.prototype.entityConnect = async function (id){
	if (!(this.pid())) { return false };
	await this.guardAllowed('read',id);
	
	var entity = await this.db().summon(id);
	
	if (Imba.indexOf(entity.state(),['live','waiting','preparing']) >= 0) {
		return await db.rpc('entities_connect',[id,this.pid()]);
	} else {
		return false;
	};
};

API.prototype.entityDisconnect = async function (id){
	console.log('disconnect from entity',id,this.pid());
	if (!(this.pid())) { return false };
	await db.raw('select api_entities_disconnect(?,?)',[id,this.pid()]);
	return true;
};

API.prototype.entityFollow = async function (id){
	console.log("follow entity!!!",id);
	await db.rpc('entity_follow',[id,this.uid()]);
	return this.db().entities().get(id);
};

API.prototype.entityUnfollow = async function (id){
	await db.rpc('entity_unfollow',[id,this.uid()]);
	return this.db().entities().get(id);
};

API.prototype.entityPublish = async function (id){
	// console.log "join entity!!!",id
	await db.raw('select publish_entity(?,?)',[this.uid(),id]);
	return this.db().entities().get(id);
};

API.prototype.entityInvite = async function (id,o){
	var name;
	await this.guardAllowed('invite',id);
	
	if (name = o.username) {
		// find user
		let user = await github.userFromGitHub({login: name});
		console.log("found user?!?",user);
		await db.rpc('entity_invite',[id,user.id,ROLES.DEVELOPER]);
		return user;
	};
	
	return;
};

API.prototype.topicFollow = async function (id){
	await db.raw('select follow_topic(?,?)',[this.uid(),id]);
	return this.user();
};

API.prototype.topicUnfollow = async function (id){
	await db.raw('select unfollow_topic(?,?)',[this.uid(),id]);
	return this.user();
};

API.prototype.noteSave = async function (id,pars){
	var v_, $1, $2;
	console.log("noteSave",id,pars);
	await this.guardAllowed('update',id);
	
	(((v_ = pars.roles),delete pars.roles, v_));
	((($1 = pars.type),delete pars.type, $1));
	((($2 = pars.uid),delete pars.uid, $2));
	
	pars.id = id;
	
	return await db.put('entities',pars);
};

API.prototype.entityUpdate = async function (id,pars){
	var v_, $1, $2;
	console.log("entityUpdate",id,pars);
	await this.guardAllowed('update',id);
	(((v_ = pars.roles),delete pars.roles, v_));
	((($1 = pars.type),delete pars.type, $1));
	((($2 = pars.uid),delete pars.uid, $2));
	pars.id = id;
	await db.put('entities',pars);
	return this;
};

API.prototype.scrimCreate = async function (pars){
	var origin, v_;
	pars = Object.assign({
		title: "Untitled",
		visibility: ROLES.REPORTER,
		state: 'waiting',
		data: {}
	},pars,{
		type: 'scrim',
		uid: this.uid(),
		pid: this.pid(),
		draft: {}
	});
	
	if (pars.git) {
		if (origin = git.fromUrl(pars.git.origin)) {
			console.log("SCRIM git data",origin);
			pars.up = ("" + (origin.user) + "/" + (origin.project));
		};
	};
	
	if (pars.id) {
		pars.localid = pars.id;
		(((v_ = pars.id),delete pars.id, v_));
	};
	
	var row = await db.put('entities',pars);
	return this.db().entities().read(row);
};

API.prototype.scrimEnd = async function (id){
	if (!(this.pid())) { return false };
	await db.rpc('scrim_end',[id,this.pid()]);
	return true;
};

API.prototype.scrimFetchStream = async function (id,byteOffset){
	await this.guardAllowed('read',id);
	
	var dir = env.get('FILES_DIR');
	var src = path.resolve(dir,id + '.scrim');
	
	if (fs.existsSync(src)) {
		console.log("found file!!");
		let data = fs.readFileSync(src);
		// console.log "fetched content of file",data:length,data:constructor:name
		return Promise.resolve(data);
	} else {
		return Promise.resolve(null);
	};
};

API.prototype.scrimProcess = async function (id){
	await publisher.publish(id,this);
	console.log("was published!!");
	return true;
};

API.prototype.scrimProcessNext = async function (id){
	var res = await db.rpc('scrim_process_next');
	if (res) {
		await publisher.publish(res,this);
		console.log("was published!!");
	};
	return res || null;
};

API.prototype.entitiesCleanup = async function (){
	var res = await db.rpc('entities_cleanup');
	return res;
};

// packet received from the peer that owns this api
API.prototype.onpacket = async function (packet){
	var cmd;
	var id,item;
	var code = packet.CODE;
	var socket = packet.channel();
	var peer = socket.peer(); // change this up
	var pid = peer.id;
	var now = new Date();
	
	console.log("packet",packet.CODE);
	
	if (code == MSG.PING) {
		return packet.resolve([MSG.PONG,1,2,3]);
	} else if (code == MSG.JOIN) {
		console.log("join");
	} else if (code == MSG.LEAVE) {
		console.log("leave");
	} else if (code == MSG.RELAY) {
		// the peer sending this packet is merely trying to relay to a different peer
		let peerId = packet[1];
		let receiver = this.db().peers().get(packet[1]);
		
		// should even work across servers using redis pubsub?
		if (receiver) {
			// include payload?
			receiver.send([MSG.RELAYED,pid,packet[2],packet.payload()]);
		};
	} else if (code == MSG.RTC) {
		console.log("webrtc packet",packet[1],packet[2]);
		let peerId = packet[2];
		let peer = this.db().peers().get(peerId);
		if (peer && peer._socket) {
			console.log("found peer with socket onlye for webrtc");
			peer.send(this.message());
		};
	} else if (code == MSG.FIND) {
		let res = await this.findRaw(packet[1],packet[2]);
		console.log("result from MSG.FIND",packet._ref);
		return packet.reply(res);
	} else if (code >= 50 && code < 100) {
		let remoteId = packet[1];
		let recipient = this.db().peers().get(packet[1]);
		if (recipient) {
			recipient.send([code,peer.id,packet[2],packet[3],packet[4]]);
		};
		return true;
	} else if (code >= 100 && code < 200) {
		id = packet[1];
		item = await this.db().summon(id);
		// outer items might not be loaded?
	};
	
	if (!item || !item.isPersisted()) {
		return false;
	};
	
	switch (packet.CODE) {
		case MSG.GET: {
			// peer.send([MSG.PONG,item])
			packet.resolve([item]);
			break;
		}
		case MSG.SCRIMHOST: {
			let secret = packet[2];
			let privkey = packet[3];
			let currPeer = await item.peer().fetch();
			console.log("SCRIMHOST",secret,privkey); // ,item.pid
			console.log("found peer?!",currPeer && currPeer.id,item._data,item.state());
			if (currPeer && currPeer._secret && currPeer._secret == privkey) {
				if (item.state() == 'waiting') {
					
					// should change user as well?
					let row = await db.put('entities',{
						id: item.id,
						pid: pid,
						state: 'live',
						uid: peer.uid || item.get('uid')
					});
					console.log("update with SCRIMHOST",row.v,item.v);
				};
			};
			break;
		}
		case MSG.SCRIMSTART: {
			let options = Object.assign(packet[2],{state: 'live'});
			await db.table('entities').update(options).where({id: id,pid: pid});
			await item.fetch();
			packet.resolve([item,true]);
			break;
		}
		case MSG.SCRIMSTOP: {
			await db.table('entities').update({state: 'ending'}).where({id: id,pid: pid});
			await item.fetch();
			packet.resolve([item]);
			break;
		}
		case MSG.SCRIMPERSIST: {
			await db.table('entities').update(
				{state: 'ended',
				uid: item.uid() || peer.get('uid'),
				draft: packet[2],
				pid: null}
			).where({id: id,pid: pid});
			await item.fetch();
			packet.resolve([item]);
			break;
		}
		case MSG.SCRIMDISPOSE: {
			await db.table('entities').update({state: 'disposed'}).where({id: id,pid: pid});
			await item.fetch();
			packet.resolve([item]);
			break;
		}
	};
	
	var res = await cmd;
	return true;
};

API.prototype.registerPrefetched = function (slug,result){
	this._cache.found || (this._cache.found = {});
	this._cache.found[slug] = result;
	return this;
};


API.prototype.rpc = async function (name,args,options){
	// make sure relevant data for serializing is loaded in memory
	var self = this;
	if(options === undefined) options = {};
	await self.userPreload();
	
	// TODO only allow certain actions to be public
	var key = JSON.stringify([name,args]);
	var res = self[name].apply(self,args);
	
	if (!res || !res.then) {
		res = Promise.resolve(res);
	};
	
	var serializer = function(data) {
		if (options.type == 'msgpack') {
			return Packet.serialize(data,{scope: self});
		} else {
			return self.db().scoped(self,function() { return self._cache[key] = JSON.parse(JSON.stringify(data)); });
		};
	};
	
	var success = async function(result) {
		if ((typeof result=='number'||result instanceof Number) && result > 199 && result < 600) {
			return result;
		};
		
		if (options.type == 'arraybuffer') {
			return result;
		};
		
		if (result == null) {
			return result || null;
		};
		
		// could drop this?
		
		var packed = serializer(result);
		
		// self.db.scoped(self) do
		//	@cache[key] = JSON.parse(JSON.stringify(result))
		
		if (self.db().pendingResourceIds().length) {
			console.log("pendingResourceIds after serializing");
			await self.db().autosync();
			packed = serializer(result);
		};
		return packed; // @cache[key]
	};
	
	return res.then(success);
};

API.prototype.toJSON = function (){
	var self = this;
	self._cache.user = self.db().users().read(self.user());
	self._cache.manifest = manifest;
	
	var json = self.db().scoped(self,function() {
		return JSON.stringify(self._cache).replace(/\bscript/g,"§§SCRIPT§§");
	});
	
	return json; // will be doubly stringified
};

API.prototype.toScriptContent = function (name){
	if(name === undefined) name = "API_CACHE";
	if (name) {
		return ("" + name + " = ") + JSON.stringify(this);
	};
};

function WorkerAPI(){ return API.apply(this,arguments) };

Imba.subclass(WorkerAPI,API);
exports.WorkerAPI = WorkerAPI; // export class 
WorkerAPI.prototype.guardAllowed = function (perm,model){
	return Promise.resolve(true);
};

function PeerAPI(){ return API.apply(this,arguments) };

Imba.subclass(PeerAPI,API);
exports.PeerAPI = PeerAPI; // export class 
PeerAPI.prototype.user = function (){
	return this._peer ? this._peer.user() : this._user;
};

PeerAPI.prototype.uid = function (){
	return this.user() && this.user().id || null;
};

