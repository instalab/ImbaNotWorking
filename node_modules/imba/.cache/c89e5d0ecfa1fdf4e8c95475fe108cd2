function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};

var Struct = require('./Struct').Struct;
var StreamAction$ = require('./StreamAction'), StreamAction = StreamAction$.StreamAction, RecStart = StreamAction$.RecStart, LockAction = StreamAction$.LockAction;
var StreamBuffer = require('./StreamBuffer').StreamBuffer;
var protocol$ = require('../protocol'), ACTION = protocol$.ACTION, ACTION_MAP = protocol$.ACTION_MAP, MSG = protocol$.MSG, SCON = protocol$.SCON;

var Pointer = require('./Pointer').Pointer;
var List = require('../util/List').List;
var Stash = require('./Stash').Stash;

var msgpack = require('msgpack-lite');

// TODO if user is in a substream branching out from
// an event in this stream, it should force-revert the
// other stream before applying/reverting own events
function Stream(buffer,owner,seed,options){
	var self = this;
	if(options === undefined) options = {};
	self._buffer = buffer;
	self._actions = [];
	self._owner = owner;
	self._options = options;
	self._offset = options.offset || 0; // TODO understand?
	// custom tail-types for each event
	self._stash = new Stash(self);
	self._widgets = {};
	
	self._byteOffset = 0;
	self._localOffset = 0;
	self._lastLocalIndex = -1;
	self._lastActions = {};
	self._lastTimeOffset = 0;
	self._lastBufferShortage = -1;
	self._lastType = null;
	self._state = {
		aid: -5,
		tails: {},
		pointer: new Pointer(self,-5),
		layouts: {}
	};
	
	self._dupes = {};
	self._layouts = {};
	self._agentStates = {
		"-5": self._state
	};
	self._agent = owner.space().agent();
	// keeps a list of recstart events
	self._recordings = new List(self);
	self._audio = new List(self);
	
	self._tail = self._first = StreamAction.seed(self);
	
	self._decoder = new (msgpack.Decoder)({});
	self._decoder.offset = 0;
	
	self._decoder.reserve = function(length) {
		// console.log "reserve",length
		var start = this.offset;
		var end = start + length;
		if ((end > (this.bufferLength || this.buffer.length))) {
			self._lastBufferShortage = this.bufferLength;
			throw new Error("BUFFER_SHORTAGE");
		};
		this.offset = end;
		return start;
	};
	
	if (seed) {
		self._tail._prev = self._seed = seed;
	} else {
		self._seed = self._tail;
	};
	// this is surely wrong
	self.anchorTime();
	
	// bind to buffer
	self._ontrim = function(e) {
		self.api().log('stream','ontrim',e);
		return self.rollbackToAction(self.actionAtByteOffset(e));
	};
	
	self._buffer.on('trim',self._ontrim);
	self;
};


exports.Stream = Stream; // export class 
Stream.prototype.buffer = function(v){ return this._buffer; }
Stream.prototype.setBuffer = function(v){ this._buffer = v; return this; };
Stream.prototype.owner = function(v){ return this._owner; }
Stream.prototype.setOwner = function(v){ this._owner = v; return this; };
Stream.prototype.parent = function(v){ return this._parent; }
Stream.prototype.setParent = function(v){ this._parent = v; return this; };
Stream.prototype.actions = function(v){ return this._actions; }
Stream.prototype.setActions = function(v){ this._actions = v; return this; };
Stream.prototype.realtime = function(v){ return this._realtime; }
Stream.prototype.setRealtime = function(v){ this._realtime = v; return this; };
Stream.prototype.seed = function(v){ return this._seed; }
Stream.prototype.setSeed = function(v){ this._seed = v; return this; };
Stream.prototype.tail = function(v){ return this._tail; }
Stream.prototype.setTail = function(v){ this._tail = v; return this; };
Stream.prototype.stash = function(v){ return this._stash; }
Stream.prototype.setStash = function(v){ this._stash = v; return this; };

Stream.prototype.recordings = function(v){ return this._recordings; }
Stream.prototype.setRecordings = function(v){ this._recordings = v; return this; };
Stream.prototype.recording = function(v){ return this._recording; }
Stream.prototype.setRecording = function(v){ this._recording = v; return this; };
Stream.prototype.__currentLock = {watch: 'currentLockDidSet',name: 'currentLock'};
Stream.prototype.currentLock = function(v){ return this._currentLock; }
Stream.prototype.setCurrentLock = function(v){
	var a = this.currentLock();
	if(v != a) { this._currentLock = v; }
	if(v != a) { this.currentLockDidSet && this.currentLockDidSet(v,a,this.__currentLock) }
	return this;
};
Stream.prototype.agents = function(v){ return this._agents; }
Stream.prototype.setAgents = function(v){ this._agents = v; return this; };
Stream.prototype.lastActions = function(v){ return this._lastActions; }
Stream.prototype.setLastActions = function(v){ this._lastActions = v; return this; };
Stream.prototype.lastTimeOffset = function(v){ return this._lastTimeOffset; }
Stream.prototype.setLastTimeOffset = function(v){ this._lastTimeOffset = v; return this; };
Stream.prototype.state = function(v){ return this._state; }
Stream.prototype.setState = function(v){ this._state = v; return this; };
Stream.prototype.audio = function(v){ return this._audio; }
Stream.prototype.setAudio = function(v){ this._audio = v; return this; };
Stream.prototype.dupes = function(v){ return this._dupes; }
Stream.prototype.setDupes = function(v){ this._dupes = v; return this; };
Stream.prototype.layouts = function(v){ return this._layouts; }
Stream.prototype.setLayouts = function(v){ this._layouts = v; return this; };
Stream.prototype.__currentAgent = {watch: 'currentAgentDidSet',name: 'currentAgent'};
Stream.prototype.currentAgent = function(v){ return this._currentAgent; }
Stream.prototype.setCurrentAgent = function(v){
	var a = this.currentAgent();
	if(v != a) { this._currentAgent = v; }
	if(v != a) { this.currentAgentDidSet && this.currentAgentDidSet(v,a,this.__currentAgent) }
	return this;
};
Stream.prototype.widgets = function(v){ return this._widgets; }
Stream.prototype.setWidgets = function(v){ this._widgets = v; return this; };

Stream.prototype.__clockDelay = {'default': 0,name: 'clockDelay'};
Stream.prototype.clockDelay = function(v){ return this._clockDelay; }
Stream.prototype.setClockDelay = function(v){ this._clockDelay = v; return this; }
Stream.prototype._clockDelay = 0;
Stream.prototype.__clockJitter = {'default': 0,name: 'clockJitter'};
Stream.prototype.clockJitter = function(v){ return this._clockJitter; }
Stream.prototype.setClockJitter = function(v){ this._clockJitter = v; return this; }
Stream.prototype._clockJitter = 0;

Stream.prototype.tails = function (){
	return this._state.tails;
};

Stream.prototype.state = function (agent){
	if (!agent) { return this._state };
	
	if (agent && (agent.id instanceof Function)) { agent = agent.id() };
	
	return this._agentStates[agent] || (this._agentStates[agent] = {
		aid: agent,
		tails: {},
		layouts: {},
		pointer: new Pointer(this,agent)
	});
};

Stream.prototype.media = function (){
	let res = [];
	for (let o = this._widgets, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];if (v.type != 'mediastream') { continue; };
		res.push(v);
	};
	return res;
};

Stream.prototype.dispose = function (){
	this._buffer.un('trim',this._ontrim);
	return this;
};

Stream.prototype.id = function (){
	return this.owner().id();
};

Stream.prototype.space = function (){
	return this.owner().space();
};

Stream.prototype.api = function (){
	return this.space().api();
};

Stream.prototype.log = function (){
	var api_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (api_ = this.api()).log.apply(api_,[].concat(['stream'], [].slice.call(params)));
};

Stream.prototype.pointer = function (){
	return this._pointer || (this._pointer = new Pointer(this));
};

Stream.prototype.anchorTime = function (o){
	if(o === undefined) o = {};
	return this._anchor = {
		ts: o.now || Date.now(),
		offset: o.offset || this._tail.offset() || 0,
		collapsed: !(this.realtime()),
		rate: 1
	};
};

Stream.prototype.currentAgentDidSet = function (agentId,prev){
	// log 'currentAgentDidSet',agentId
	let state = this.state(agentId);
	this._state = state;
	return this;
};

Stream.prototype.currentSID = function (){
	return this.currentLock() ? this.currentLock().sid() : null;
};

// is this used?
Stream.prototype.currentTime = function (){
	return Date.now() - this._anchor.ts;
};

Stream.prototype.lastTimeOffset = function (){
	return this._tail.offset();
};

Stream.prototype.nextTimeOffset = function (){
	return Math.max(this.lastTimeOffset(),this._anchor.offset + (this.now() - this._anchor.ts) * this._anchor.rate);
};

Stream.prototype.now = function (){
	return this._frozenTime || Date.now();
};

Stream.prototype.freezeTime = function (time,block){
	let prev = this._frozenTime;
	this._frozenTime = time || Date.now();
	block();
	this._frozenTime = prev;
	return this;
};

Stream.prototype.byteLength = function (){
	return this._decoder.offset;
};

Stream.prototype.read = function (meta){
	var dec = this._decoder;
	var buf = dec.buffer = this._buffer._buffer;
	var bufSize = this._buffer.size();
	dec.bufferLength = bufSize;
	let chunk;
	
	if (!buf || dec.offset >= bufSize) {
		// we are waiting for more from buffer
		return null;
	};
	
	if (bufSize == this._lastBufferShortage) {
		// console.log "waiting for more of buffer"
		return;
	};
	
	// check
	try {
		// does not fail because buffer is zero-filled
		chunk = dec.fetch();
	} catch (e) {
		// console.log "could not fetch",e
		this._lastBufferShortage = this._buffer.size();
	};
	
	if (bufSize == this._lastBufferShortage) {
		dec.offset = this._lastValidOffset;
		// console.log "the fetch was erroneous!",@lastValidOffset,@lastBufferShortage
		return;
	};
	
	this._lastValidOffset = dec.offset;
	
	// this is an action
	if (typeof chunk == 'number') {
		if (chunk > 0) {
			this._lastTimeOffset += chunk;
		} else if (chunk < -2000 && chunk > -3000) {
			let agentId = (chunk * -1) - 2000;
			// console.log "switched lastAgentId",agentId
			this.setCurrentAgent(agentId);
		} else if (chunk < 0) {
			this._lastType = -chunk;
		};
		return this.read(meta);
	};
	
	
	var typ = this._lastType;
	var kls = ACTION_MAP[typ];
	
	if (!kls) {
		kls = StreamAction;
	};
	
	var nextIndex = this._actions.length;
	var prevOfType = this.tails()[typ];
	
	// log "read",chunk
	var action = kls.decode(chunk,prevOfType ? prevOfType._params : null,this,nextIndex);
	if (meta) { action.LOCAL = meta };
	action.addToStream(this);
	action.commitToStream(this);
	this.stash().merge(action);
	return this._tail = action;
};

Stream.prototype.lock = function (action){
	let agent = action.AGENT || action.agent();
	if (agent) {
		if (agent.id() != this._currentAgent) {
			// otherwise neutral agent?
			// @lastAgentId = agent.id
			// storing agent
			// console.log "add agent id",-2000 - agent.id
			// log 'agent',agent.id
			this.buffer().add(StreamBuffer.encode([-2000 - agent.id()]),this.byteLength());
			return this.sync({});
		} else {
			return true;
		};
	};
	return true;
};

// write to the stream - this is where we compact etc
Stream.prototype.write = function (action,meta){
	if (!this.lock(action)) {
		return false;
	};
	
	var offset = this.nextTimeOffset();
	
	if (meta && meta.timeOffset != null) {
		offset = meta.timeOffset;
		// anchorTime(offset: offset)
	};
	
	// var offset = Math.max(timestamp,@tail.offset)
	var delta = offset - this.lastTimeOffset();
	
	if (delta > 0 && delta < 3) {
		delta = 0;
	};
	
	// if we are not recording - we should not add
	// any offsets between events at all.
	
	// FIX if recording belongs to another branch - we must definitely throw(!)
	if (!(this.space().recording() && this.space().recording().isRecording())) {
		if (!(meta && meta.timeOffset || this.space().option('demo') || this.space().isLive())) { delta = 0 };
		if (this._actions.length == 0) { delta = 0 };
	};
	
	var typ = action._type;
	
	if (!this.canPush(action)) {
		console.warn("not allowed to write to stream!",action);
		return this;
	};
	
	var binary = [];
	
	if (delta > 0) {
		binary.push(delta);
	};
	
	if (typ != this._lastType) {
		binary.push(-typ);
	};
	
	// is the state of the stream updated?
	action.addToStream(this);
	// var prev = prevOfType ? prevOfType.@params : null
	var encoded = action.encode(this);
	binary.push(encoded);
	var packed = StreamBuffer.encode(binary);
	this.buffer().add(packed,this.byteLength());
	this.log.apply(this,[].concat([offset,delta,action.constructor.name], [].slice.call(encoded), [action._params,len$(this.buffer())]));
	this._lastLocalIndex = this._actions.length;
	return this.read(meta);
};

Stream.prototype.canPush = function (action){
	return true;
	// var rec = @recordings.last
	// var res = !rec or !rec.stop or action isa RecStart
	// return res
};

Stream.prototype.encode = function (){
	var encoder = new (msgpack.Encoder)({});
	var type = 0;
	var dt = 0;
	var time = 0;
	for (let i = 0, items = iter$(this.actions()), len = items.length, action; i < len; i++) {
		action = items[i];
		let atime = action.timeOffset();
		if (atime > time) {
			encoder.write(atime - time);
			time = atime;
		};
		if (action._type != type) {
			encoder.write(-action._type);
			type = action._type;
		};
		
		let enc = action.encode(this);
		encoder.write(enc);
	};
	return encoder.read();
};

Stream.prototype.sync = function (meta){
	// for now read as long as possible
	if(meta === undefined) meta = null;
	var len = this._buffer.size();
	var offset = this._decoder.offset;
	
	// already at the end
	if (offset == len) {
		return this;
	};
	
	if (offset > len) {
		console.warn("we are ahead of buffer(?!)");
		// we need to know the last valid 
		return this;
	};
	
	while (this.read(meta)){
		// break if ++k > 1000
		true;
	};
	return this;
};

Stream.prototype.len = function (){
	return this._actions.length;
};

Stream.prototype.toArray = function (){
	return this._actions;
};

Stream.prototype.map = function (cb){
	return this._actions.map(cb);
};

Stream.prototype.duration = function (){
	return this._tail.offset();
};

Stream.prototype.liveDuration = function (){
	return this.nextTimeOffset();
};

// This supports negative indices
Stream.prototype.actionAtIndex = function (index){
	if (index < 0) {
		index = this._actions.length + index;
	};
	return this._actions[index];
};

Stream.prototype.actionAtOffset = function (time){
	this.read();
	
	var cursor = this._lastSearchCursor || this._actions[0];
	if (!cursor) { return null };
	
	var prev = cursor;
	// make sure we read ahead to the offset
	while (time >= this.duration()){
		if (!(this.read())) {
			return this._tail;
		};
	};
	
	if (time < cursor.offset()) {
		while (cursor && time < cursor.offset()){
			cursor = cursor._prev;
		};
		return this._lastSearchCursor = cursor || this._actions[0];
	} else {
		// add some sort of cache here?
		while (cursor && time >= cursor.offset()){
			prev = cursor;
			cursor = cursor._next;
		};
		return this._lastSearchCursor = prev;
	};
};

Stream.prototype.actionAtByteOffset = function (byteOffset){
	var action = this._tail;
	while (action && action._byteEnd > byteOffset){
		action = action._prev;
	};
	return action;
};

Stream.prototype.actionsOfType = function (type){
	return this._actions.filter(function(action) { return action._type == type; });
};

Stream.prototype.rollbackToAction = function (action){
	var dec = this._decoder;
	
	var path = this.space().cursor().compare(this.space().cursor().current(),action);
	// only sync if we are after this
	this.log("rollback-path",path);
	
	if (path.revertTo) {
		this.space().cursor().sync(action);
	};
	
	while (this._tail != action){
		let prev = this._tail._prev;
		this._tail.removeFromStream(this);
		this._tail = prev;
		prev._next = null;
	};
	
	var timeOffset = this._tail.timeOffset();
	
	this._lastType = this._tail.type();
	this._lastTimeOffset = timeOffset;
	this._lastSearchCursor = null;
	this._decoder.offset = this._tail.byteEnd();
	this._actions.slice(0,action.index() + 1);
	
	// remove cached dupes after new offset
	var lastIndex = len$(this._actions) - 1;
	for (let o = this._dupes, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];if (v > lastIndex) {
			this._dupes[k] = undefined;
		};
	};
	
	// should happen from Branch
	var tl = this._owner && this._owner.timeline  &&  this._owner.timeline();
	if (tl && tl.currentOffset() > timeOffset) {
		tl.seek(timeOffset);
	};
	return this;
};

Stream.prototype.rollbackToByteOffset = function (byteEnd){
	var action = this._tail;
	while (action && action.byteEnd() > byteEnd){
		action = action._prev;
	};
	
	// console.log "found action",action
	this.rollbackToAction(action);
	return this;
};
