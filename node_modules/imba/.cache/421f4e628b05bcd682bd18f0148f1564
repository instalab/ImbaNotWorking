function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var self = {};
// import API from "../server/api"
var Space = require('../../app/scrimba/space').Space;

var API_INSTANCE = null;

// Keeps track of a single Space:
// - It has a queue of workers that want to use it
// - It automatically loads it and calls #setup
function Entry(id){
	this._id = id;
	this._queue = [];
	this._loaded = false;
	this.touch();
};

Entry.prototype.id = function(v){ return this._id; }
Entry.prototype.setId = function(v){ this._id = v; return this; };
Entry.prototype.touchedAt = function(v){ return this._touchedAt; }
Entry.prototype.setTouchedAt = function(v){ this._touchedAt = v; return this; };

Entry.prototype.touch = function (){
	return this._touchedAt = Date.now();
};

Entry.prototype.loadSpace = async function (){
	var space = await Space.load(this._id,API_INSTANCE);
	this._space = space;
	
	if (!space) {
		this._loaded = true;
		this.release();
		return;
	};
	
	await space.setup();
	this._loaded = true;
	return this.release(); // this kicks off the initial acquire
};

Entry.prototype.dispose = function (){
	this._space && this._space.dispose  &&  this._space.dispose();
	return this;
};

// Attemts to aquire the space object. You must manually call
// release once you're done with it.
Entry.prototype.acquire = function (cb){
	if (this._loaded && this._queue.length == 0) {
		cb(this._space);
	} else {
		this._queue.push(cb);
		this._spaceLoader || (this._spaceLoader = this.loadSpace());
	};
	return this;
};

Entry.prototype.release = function (){
	var next;
	if (next = this._queue.shift()) {
		return next(this._space);
	};
};

// Wraps acquire/release in a Promise for you:
// 
// fetch do |space|
//   await dosomething(space)
// 
// Returns a promise which resolves to the value of the callback.
// The callback will be called with the `space` and you can return
// a promise to keep holding onto the `space` object.
Entry.prototype.fetch = function (cb){
	var self = this;
	return new Promise(function(resolve,reject) {
		return self.acquire(function(space) {
			var succ = function(val) {
				self.release();
				return resolve(val);
			};
			var fail = function(err) {
				self.release();
				return reject(err);
			};
			var prom = new Promise(function(resolve) {
				return resolve(cb(space));
			});
			return prom.then(succ,fail);
		});
	});
};


function Cache(){
	var self = this;
	self._entries = {};
	self._timeout = 60 * 1000; // [ms]
	self._cleaner = setInterval(function() { return self.cleanup(); },5000);
};

exports.Cache = Cache; // export class 
Cache.prototype.dispose = function (){
	return clearInterval(this._cleaner);
};

Cache.prototype.cleanup = function (){
	var dict, v_;
	var now = Date.now();
	let res = [];
	for (let id in dict = this._entries){
		let entry;
		entry = dict[id];res.push((now - entry.touchedAt() > this._timeout) && (
			entry.dispose(),
			(((v_ = this._entries[id]),delete this._entries[id], v_))
		));
	};
	return res;
};

Cache.prototype.entryFor = function (id){
	var entry = this._entries[id];
	if (entry) {
		entry.touch();
	} else {
		entry = this._entries[id] = new Entry(id);
	};
	return entry;
};

// negative idx => from the end
Cache.prototype.syncSpace = async function (space,idx){
	var action;
	var branch = space.trunk();
	
	if (idx >= 0 && (action = branch.stream().actionAtIndex(idx))) {
		space.cursor().sync(action);
		return true;
	};
	
	var byteOffset = len$(branch.stream().buffer());
	await branch.model().fetchStreamBuffer(null,byteOffset);
	branch.stream().sync();
	
	if (action = branch.stream().actionAtIndex(idx)) {
		space.cursor().sync(action);
		return true;
	} else {
		return false;
	};
};

Cache.prototype.spaceAtIndex = function (id,idx,cb){
	var self = this;
	var entry = self.entryFor(id);
	return entry.fetch(async function(space) {
		if (!space) {
			return null;
		};
		var didSync = await self.syncSpace(space,idx);
		if (didSync) {
			return cb(space);
		} else {
			return null;
		};
	});
};

Cache.prototype.stateForSpaceId = function (id,idx){
	return this.spaceAtIndex(id,idx,function(space) {
		return space.trunk().toSnapshot();
	});
};

var cache = exports.cache = new Cache();

exports.stateForSpaceId = self.stateForSpaceId = function (api,id,idx){
	API_INSTANCE || (API_INSTANCE = api);
	return cache.stateForSpaceId(id,idx);
};

exports.spaceAtIndex = self.spaceAtIndex = function (api,id,idx,cb){
	API_INSTANCE || (API_INSTANCE = api);
	return cache.spaceAtIndex(id,idx,cb);
};
