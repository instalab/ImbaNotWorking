var self = {};
var protocol$ = require('../protocol'), WIDGET = protocol$.WIDGET, SCON = protocol$.SCON, ACTION = protocol$.ACTION, KEYS = protocol$.KEYS;
var SpectatorSet = require('../core/StreamAction').SpectatorSet;

self.isEqual = function (a,b){
	if (a === b) {
		return true;
	};
	
	if ((a instanceof Array) && (b instanceof Array)) {
		var l = a.length;
		if (l == b.length) {
			while (l > 0){
				if (a[--l] != b[l]) { return false };
			};
			return true;
		};
	};
	
	return false;
};

// TODO Finegrained overridable configuration
// to be able to declare whether option should naturally
// clear from locals when new value is same as stream value etc

function Option(){ };

Option.compare = function (a,b){
	return a == b;
};

function WidgetOptions(widget){
	this._widget = widget;
	this._versions = {};
	this._v = 0;
};

exports.WidgetOptions = WidgetOptions; // export class 
WidgetOptions.prototype.widget = function(v){ return this._widget; }
WidgetOptions.prototype.setWidget = function(v){ this._widget = v; return this; };

WidgetOptions.prototype.raw = function (){
	return this._widget._data;
};

WidgetOptions.prototype.schema = function (){
	return this._widget._schema_ || (this._widget._schema_ = {});
};

WidgetOptions.prototype.version = function (key){
	return key ? ((this._versions[key] || 0)) : this._v;
};

WidgetOptions.prototype.api = function (){
	return this._widget.api();
};

WidgetOptions.prototype.space = function (){
	return this._widget.space();
};

WidgetOptions.prototype.touch = function (params){
	this._v++;
	return this;
};

WidgetOptions.prototype.changed = function (key){
	this._versions[key] = (this._versions[key] || 0) + 1;
	this._v++;
	// should also update marks naturally
	let o = this.schema()[key];
	if (o && o.mark) { this.widget().mark_(o.mark) };
	this.space().dirty();
	return this;
};

// def locals
// 	@locals ||= @widget.space.client.optionsForItem(@widget)

WidgetOptions.prototype.get = function (key,agent){
	let o = this.schema()[key];
	let val = undefined;
	
	if (o.subjective) {
		
		agent || (agent = this.space().me());
		
		// possibly fall back to raw value?
		if (agent) {
			val = agent.getLocal(this._widget,key,o.inheritable);
		};
	};
	
	if (val === undefined) { // and !o:subjective
		val = this.raw()[key];
	};
	
	return this.deserializedValueFor(o,val);
};

WidgetOptions.prototype.reset = function (key){
	// if locals[key]
	// 	delete locals[key]
	// 	# space.touch(:locals)
	return this;
};

WidgetOptions.prototype.set = function (key,value,explicitAgent){
	// support multiple
	if (key instanceof Object) {
		for (let v, i = 0, keys = Object.keys(key), l = keys.length, k; i < l; i++){
			k = keys[i];v = key[k];this.set(k,v,explicitAgent);
		};
		return this;
	};
	
	let isSubAction = this.space().isSyncing();
	let agent = explicitAgent || (isSubAction ? this.space().cursor().stack()[0].agent() : this.space().me());
	
	let o = this.schema()[key] || {};
	let type = o.type;
	let equals = type && type.equals || Option.compare;
	var plain = (value && value.valueOf) ? value.valueOf('option') : this.serializedValueFor(this.schema()[key],value);
	var old = this.raw()[key];
	// var local = @locals ? @locals[key] : undefined
	let diff;
	
	let akey = SCON.keyToRef(key);
	
	if (o.subjective && agent) {
		old = agent.getLocal(this.widget(),key);
	};
	
	if (equals(plain,old)) {
		return this;
	};
	
	// can set value for the local agent
	// changed(key)
	
	// to know whether it has changed - we need to check value for said agent
	if (isSubAction) {
		this._widget.push_(ACTION.SET,[this.widget().__uid(),akey,plain]);
		return this;
	};
	
	// possibly set for local viewer without creating action
	if (o.subjective && this.space().isSpectating()) {
		if (o.invalidate == 'backwards') {
			// log "add as sub-action(!)",key,plain
			let action = new SpectatorSet([this.widget().__uid(),key,plain]);
			action._agent = agent;
			this.space().cursor().current().addSubAction(action);
		} else {
			agent.setLocal(this.widget(),key,plain);
			this.changed(key);
		};
		
		return this;
	};
	
	if (type && type.diff) {
		diff = type.diff(old,plain);
		if (!diff) {
			return this;
		};
	};
	
	if (o.action && (plain instanceof Array)) {
		this._widget.push_(o.action,plain);
	} else if (old && diff) {
		this._widget.push_(ACTION.PATCH,[this.widget().__uid(),akey,diff]);
	} else {
		this._widget.push_(ACTION.SET,[this.widget().__uid(),akey,plain]);
		// this should apply the change itself
	};
	return this;
};

WidgetOptions.prototype.proxy = function (key){
	var self = this;
	self._proxies || (self._proxies = {});
	return self._proxies[key] || (self._proxies[key] = {
		name: key,
		schema: self.schema()[key],
		value: function(v) { return self.get(key,v); },
		setValue: function(v) { return self.set(key,v); }
	});
};

WidgetOptions.prototype.serializedValueFor = function (schema,value){
	// console.log 'serialize value',value,schema
	if (schema && schema.type == 'widget') {
		return (value && value.__uid) ? value.__uid() : value;
	} else {
		return value;
	};
};

WidgetOptions.prototype.deserializedValueFor = function (schema,value){
	if (schema && schema.type == 'widget') {
		return this._widget.space().__lookup(value);
	} else if (value === undefined && schema.default != undefined) {
		return schema.default;
	} else {
		return value;
	};
};
