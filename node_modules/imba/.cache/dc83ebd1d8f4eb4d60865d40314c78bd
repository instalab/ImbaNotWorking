var self = {};
exports.delay = self.delay = function (ms){
	if(ms === undefined) ms = 1000;
	return new Promise(function(resolve,reject) {
		return setTimeout(resolve,ms);
	});
};

exports.msToStr = self.msToStr = function (t,includeMs){
	t || (t = 0);
	
	t = Math.round(t);
	
	var neg = t < 0;
	
	if (t < 0) { t = -t };
	
	var s = Math.floor((t % 60000) / 1000);
	var m = Math.floor((t - s * 1000) / 60000);
	
	if (s == 60) {
		s = 0;
		m++;
	};
	
	// m ("0"+m).slice(-2)
	var str = ("" + m + ":" + ("0" + s).slice(-2));
	
	if (includeMs) {
		str = str + '.' + ("000" + (t % 1000)).slice(-3);
	};
	
	if (neg) {
		str = "-" + str;
	};
	return str;
};


exports.refreshPseudoClass = self.refreshPseudoClass = function (flag,new$,old,topflag){
	// remove hover classes upwards
	var root = document.body;
	var added = [];
	
	if (topflag) {
		if (old && old.classList) {
			old.classList.remove(topflag);
		};
		
		if (new$ && new$.classList) {
			new$.classList.add(topflag);
		};
	};
	
	while (old && old != root && (!(new$) || !old.contains(new$))){
		if (old.classList) { old.classList.remove(flag) };
		old = old.parentNode;
	};
	
	while (new$ && new$ != root && root.contains(new$)){
		if (new$.classList) {
			added.push(new$);
			new$.classList.add(flag);
		};
		
		new$ = new$.parentNode;
	};
	
	return added;
};

exports.findClosestWithMethod = self.findClosestWithMethod = function (node,meth){
	if (!node) { return };
	node = node._dom || node;
	while (node){
		if (node._tag && (node._tag[meth] instanceof Function)) {
			return node._tag;
		};
		node = node.parentNode;
	};
	return null;
};

exports.callClosest = self.callClosest = function (node,meth,args){
	if(args === undefined) args = [];
	if (!node) { return };
	
	node = node._dom || node;
	while (node){
		if (node._tag && (node._tag[meth] instanceof Function)) {
			return node._tag[meth].apply(node._tag,args);
		};
		node = node.parentNode;
	};
	return null;
};
