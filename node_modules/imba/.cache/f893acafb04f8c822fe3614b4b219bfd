var Imba = require('imba');
var Widget = require('./widget').Widget;

function EditorWidget(){ return Widget.apply(this,arguments) };

Imba.subclass(EditorWidget,Widget);
exports.EditorWidget = EditorWidget; // export class 
EditorWidget.register('editor');

// option :renderWhitespace, default: no, overridable: yes

// layout related options
EditorWidget.option('left');
EditorWidget.option('top');
EditorWidget.option('width');
EditorWidget.option('height');
EditorWidget.option('contentTop'); // relative to top
EditorWidget.option('contentLeft'); // relative to left
EditorWidget.option('fontSize');
EditorWidget.option('lineHeight');
EditorWidget.option('renderIndentGuides',{'default': false});
EditorWidget.option('renderWhitespace',{'default': false,overridable: true});
EditorWidget.option('wordWrap',{'default': true,overridable: true});
EditorWidget.option('wordWrapColumn',{'default': 100,overridable: true});
EditorWidget.option('wrappingIndent',{'default': 'same',overridable: true});

EditorWidget.prototype.view = function(v){ return this._view; }
EditorWidget.prototype.setView = function(v){ this._view = v; return this; };

EditorWidget.prototype.setup = function (){
	return this;
};

// should at some point store on EditorWidget instead
EditorWidget.prototype.currentFile = function (){
	return this.space().agent().file();
};

EditorWidget.prototype.agentFile = function (){
	return this.space().agent().file(false);
};

EditorWidget.prototype.hasFocus = function (){
	return this.space().agent().focus() == this || this.space().agent().focus(false) == this;
};

EditorWidget.prototype.posToScreen = function (x,y){
	return this.agentToLocalPoint(x,y);
};

// calculate pointer
EditorWidget.prototype.agentToLocalPoint = function (x,y,pars){
	
	// what about using the targetFrame for this?
	
	// get the local point for pointer
	if(pars === undefined) pars = this._data;
	var file = this.currentFile();
	
	// we are not looking at the same target
	if (!file || file != this.agentFile()) {
		return null;
	};
	
	var agentViewTop = pars.top + pars.contentTop;
	var agentViewLeft = pars.left + pars.contentLeft;
	
	var localViewTop = this.view().top() + this.view().contentTop();
	var localViewLeft = this.view().left() + this.view().contentLeft();
	
	// calculate the line,column for agent
	var agentX = x - (pars.left + pars.contentLeft) + (pars.scrollLeft || file.scrollLeft() || 0);
	var agentY = y - (pars.top + pars.contentTop) + (pars.scrollTop || file.scrollTop() || 0);
	
	// var agentScrollTop = file.scrollTop # based on agent
	// var agentScrollLeft = file.scrollLeft # based on agent
	// if fontSize,lineHeight,scrollTop and scrollLeft are the same
	// skip converting
	// need to know if we have the same currentFile(!)
	
	var line = agentX;
	var scaleX = this.view().fontSize() / (pars.fontSize || 14);
	var scaleY = this.view().lineHeight() / (pars.lineHeight || 21);
	
	var localX = agentX * scaleX - this.view().scrollLeft();
	var localY = agentY * scaleY - this.view().scrollTop();
	
	// offset relative to scrollTop and scrollLeft
	// first calculate how many lines down 
	
	if (this.view()) {
		this.view()._agentPointerX = agentX * scaleX;
		this.view()._agentPointerY = agentY * scaleY;
	};
	
	// assuming the same position  round to 0.5?
	var spaceY = Math.round(localViewTop + localY);
	var spaceX = Math.round(localViewLeft + localX);
	
	// log 'agentToLocalPoint',point,pars,agentX,agentY,spaceX - point.x,spaceY - point.y
	
	return [spaceX,spaceY];
};
