function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');

var Widget = require('./widget').Widget;
var protocol$ = require('../protocol'), ACTION = protocol$.ACTION, SCON = protocol$.SCON, FS = protocol$.FS;

var List = require('../util/List').List;

function DirWidget(){ return Widget.apply(this,arguments) };

Imba.subclass(DirWidget,Widget);
exports.DirWidget = DirWidget; // export class 
DirWidget.register('dir');

DirWidget.option('name');
DirWidget.option('parent',{type: 'widget'});
DirWidget.option('oid');

DirWidget.option('expanded',{invalidate: 'backwards',
watch: 'expandedDidSet',
mark: 'fs'});

DirWidget.option('flags',{'default': 0});

DirWidget.prototype.setup = function (){
	return this;
};

DirWidget.prototype.entries = function (){
	return this._entries || (this._entries = new List(this,[]));
};

DirWidget.prototype.toEntry = function (){
	return {
		type: 'dir',
		name: this.name(),
		path: this.path(),
		flags: this.flags()
	};
};

DirWidget.prototype.uri = function (){
	return ("" + (this.space().namespace()) + "/" + this.name());
};

DirWidget.prototype.ext = function (){
	return this.name().substr(this.name().lastIndexOf('.') + 1);
};

// rename to ensureDir?
DirWidget.prototype.mkdir = function (name,opts){
	
	var existing;
	if(opts === undefined) opts = {};
	if (existing = this.entries().find(function(entry) { return entry.name() == name; })) {
		console.log(("dir already exists " + name));
		return existing;
	};
	
	var data = {
		name: name,
		parent: this.id(),
		type: 'dir',
		flags: (opts.flags || 0),
		expanded: opts.expanded || false,
		oid: opts.oid,
		diffs: opts.diffs
	};
	
	var dir = this.space().createWidget(data).widget();
	if (this.space().branch().machine()) {
		this.space().branch().machine().mkdir(dir.toEntry());
	};
	return dir;
};

DirWidget.prototype.mkdirp = function (name){
	// what about the top one?
	var parts = (name instanceof Array) ? name : name.split("/");
	var parent = this;
	for (let i = 0, items = iter$(parts), len = items.length, dir; i < len; i++) {
		dir = items[i];
		if (!dir) { continue; };
		parent = parent.mkdir(dir);
	};
	return parent;
};

DirWidget.prototype.mkfile = function (name,o){
	// TODO check for / in name - throw error
	
	if(o === undefined) o = {};
	var data = {
		name: name,
		parent: this.id(),
		type: 'file',
		body: o.body || '',
		flags: o.flags || 0
	};
	
	for (let v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];data[k] || (data[k] = v);
	};
	
	if (!name || this.entries().any(function(entry) { return entry.name() == name; })) {
		console.log(("file already exists " + name));
		return null;
	};
	
	let file = this.space().createWidget(data).widget();
	
	if (this.space().branch().machine()) {
		this.space().branch().machine().mkfile(file.toEntry());
	};
	return file;
};


DirWidget.prototype.rename = function (name){
	// should check with filesystem(!)
	if (!name || name == this.name() || this.parentDir().entries().any(function(f) { return f.name() == name; })) {
		return this;
	};
	
	return this.push_(ACTION.FS_RENAME,[this.id(),name]);
};

DirWidget.prototype.rm = function (){
	if (len$(this.entries())) {
		this.log("Directory is not empty");
		return this;
	};
	
	return this.push_(ACTION.FS_REMOVE,[this.id()]);
};


DirWidget.prototype.moveTo = function (target){
	// should be separate action, or just change parent?
	this.log("moveTo",target);
	if (target.path().indexOf(this.path()) == 0) {
		this.log("target is inside folder - not allowed");
		return this;
	};
	
	if (this.parent() == target) {
		return this;
	};
	
	this.push_(ACTION.FS_MOVE,[this.id(),target.id()]);
	return this;
};

DirWidget.prototype.mount_ = function (){
	DirWidget.prototype.__super__.mount_.apply(this,arguments);
	if (this.parentDir()) { return this.parentDir().entries().add(this) };
};

DirWidget.prototype.unmount_ = function (){
	DirWidget.prototype.__super__.unmount_.apply(this,arguments);
	if (this.parentDir()) { return this.parentDir().entries().remove(this) };
};

DirWidget.prototype.parentDir = function (){
	return this.parent() || this.space().fs();
};

DirWidget.prototype.path = function (){
	return ("" + (this.parentDir().path()) + "/" + this.name());
};

DirWidget.prototype.flag = function (flag){
	this.setFlags(this.flags() | flag);
	return this;
};

DirWidget.prototype.unflag = function (flag){
	this.setFlags(this.flags() & (~flag));
	return this;
};

DirWidget.prototype.hasFlag = function (flag){
	return this.flags() & flag;
};

DirWidget.prototype.isUnsaved = function (){
	return this.hasFlag(FS.UNSAVED);
};

DirWidget.prototype.isLazy = function (){
	return this.hasFlag(FS.LAZY);
};

DirWidget.prototype.fetch = function (){
	if (!(this.isLazy()) || this._fetcher || !this.space().trunk().machine()) { return };
	this._fetcher = true;
	return this.space().trunk().machine().fetch(this.toEntry(),this);
};


DirWidget.prototype.expandedDidSet = function (bool){
	// console.log "expandedDidSet"
	if (bool) this.fetch();
	return this;
};


function FileSystemWidget(){ return DirWidget.apply(this,arguments) };

Imba.subclass(FileSystemWidget,DirWidget);
exports.FileSystemWidget = FileSystemWidget; // export class 
FileSystemWidget.register('fs');

FileSystemWidget.prototype.name = function (){
	return "project";
};

FileSystemWidget.prototype.path = function (){
	return "";
};

FileSystemWidget.prototype.expanded = function (){
	return true;
};

FileSystemWidget.prototype.rm = function (){
	return this;
};

FileSystemWidget.prototype.parentDir = function (){
	return null;
};

FileSystemWidget.prototype.find = function (path){
	if ((typeof path=='string'||path instanceof String) && path[0] != '/') {
		path = '/' + path;
	};
	
	for (let i = 0, items = iter$(this.space().widgets()), len = items.length, item; i < len; i++) {
		item = items[i];
		if (!(item.TYPE == 'file' || item.TYPE == 'dir')) { continue; };
		if (item.path() == path) {
			return item;
		};
		if ((path instanceof RegExp) && path.test(item.path())) {
			return item;
		};
	};
	
	return null;
};

FileSystemWidget.prototype.nodemap = function (){
	var nodes = {};
	for (let i = 0, items = iter$(this.space().widgets()), len = items.length, item; i < len; i++) {
		item = items[i];
		if (item.TYPE != 'file') { continue; };
		nodes[item.path()] = item.id();
	};
	return nodes;
};
