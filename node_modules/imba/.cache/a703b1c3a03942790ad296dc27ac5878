var Imba = require('imba');

var ROLES = require('../scrimba/protocol').ROLES;
var Resource$ = require('../store/Resource'), Resource = Resource$.Resource, MASK = Resource$.MASK;

var crypto;
if (true) {
	crypto = require('crypto');
};

function User(){ return Resource.apply(this,arguments) };

Imba.subclass(User,Resource);
exports.User = User; // export class 
User._serializer = {
	github_profile: MASK.NEVER,
	github_user_id: MASK.NEVER,
	roles: MASK.OWN,
	email: MASK.NEVER,
	password_hash: MASK.NEVER,
	github_token: MASK.NEVER
// github_scopes: MASK.OWN
};

User.prototype.notifyChannels = function (){
	return this.id;
};

User.prototype.spaces = function (){
	return this.casts();
};

User.prototype.user = function (){
	return this;
};

User.prototype.secrets = function (){
	return this._secrets || (this._secrets = {});
};

// WARN need to move over to using data -- damn
User.prototype.topics_ = function (){
	var self = this;
	let raw = self._data.topics;
	return raw ? ((raw.TOPICS || (raw.TOPICS = raw.map(function(_0) { return self.db().topics().get(_0); })))) : [];
};

User.prototype.links = function (){
	var self = this;
	return self._cache.links || (self._cache.links = self.db().links().sel(function(_0) { return _0.uid == self.id; }));
};

User.prototype.starred = function (){
	return this._cache.starred || (this._cache.starred = this.links().sel(function(_0) { return _0.follow; })); // or ($1:role and $1.entity.isGroup and $1.entity.level == 1)
};

User.prototype.roles = function (){
	return this._cache.roles || (this._cache.roles = this.links().sel(function(_0) { return _0.role; })); // or ($1:role and $1.entity.isGroup and $1.entity.level == 1)
};

User.prototype.entities = function (){
	var self = this;
	return self._cache.entities || (self._cache.entities = self.db().entities().sel(function(_0) { return _0.uid() == self.id; }));
};

User.prototype.scrims = function (){
	return this._cache.scrims || (this._cache.scrims = this.entities().sel({sort: '-crets'},function(_0) { return _0.isScrim(); }));
};

User.prototype.groups = function (){
	return this._cache.groups || (this._cache.groups = this.links().sel(function(_0) { return _0.role && _0.entity().isGroup(); }));
};

User.prototype.hasScope = function (scope){
	return this._data.github_scopes && this._data.github_scopes.indexOf(scope) >= 0;
};

User.prototype.beforeSerialize = function (){
	return this.createGravatarHash();
};

User.prototype.gravatarHash = function (){
	this.createGravatarHash();
	return this.gravatar_hash;
};

User.prototype.createGravatarHash = function (){
	if (true) {
		if (this.email) {
			return this.gravatar_hash || (this.gravatar_hash = crypto.createHash('md5').update(this.email).digest('hex'));
		};
	};
};

User.prototype.url = function (){
	if (this.username) {
		return ("/@" + (this.username));
	} else {
		return ("/" + (this.id));
	};
};

User.prototype.shortName = function (){
	return this.username || this.name;
};

User.prototype.avatarUrl = function (s){
	var gravatar;
	if(s === undefined) s = 64;
	if (!this.username && (gravatar = this.gravatarHash())) {
		return ("https://www.gravatar.com/avatar/" + gravatar + "?s=" + s);
	} else {
		return ("https://avatars.githubusercontent.com/" + (this.username) + "?s=" + s);
	};
};
