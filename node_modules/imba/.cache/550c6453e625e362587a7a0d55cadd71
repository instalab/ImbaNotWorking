function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');
/*

iceStates
"new"	The ICE agent is gathering addresses or is waiting to be given remote candidates through calls to RTCPeerConnection.addIceCandidate() (or both).
"checking"	The ICE agent has been given one or more remote candidates and is checking pairs of local and remote candidates against one another to try to find a compatible match, but has not yet found a pair which will allow the peer connection to be made. It's possible that gathering of candidates is also still underway.
"connected"	A usable pairing of local and remote candidates has been found for all components of the connection, and the connection has been established. It's possible that gathering is still underway, and it's also possible that the ICE agent is still checking candidates against one another looking for a better connection to use.
"completed"	The ICE agent has finished gathering candidates, has checked all pairs against one another, and has found a connection for all components.
"failed"	The ICE candidate has checked all candidates pairs against one another and has failed to find compatible matches for all components of the connection. It is, however, possible that the ICE agent did find compatible connections for some components.
"disconnected"	Checks to ensure that components are still connected failed for at least one component of the RTCPeerConnection. This is a less stringent test than "failed" and may trigger intermittently and resolve just as spontaneously on less reliable networks, or during temporary disconnections. When the problem resolves, the connection may return to the "connected" state.
"closed"

*/


// TODO Use PacketChannel inside DataChannel

var peerConnectionConfig = {
	iceServers: [{'urls': 'stun:stun.services.mozilla.com'},{'urls': 'stun:stun.l.google.com:19302'}]
};

var dataChannelConfig = {
	ordered: false,
	maxRetransmits: 0,
	maxPacketLifeTime: null
};

dataChannelConfig = {ordered: true};

var Packet = require('../scrimba/core/Packet').Packet;
var protocol$ = require('../scrimba/protocol'), SCON = protocol$.SCON, MSG = protocol$.MSG;

function DataChannel(socket,channel){
	this._socket = socket;
	this._variance = []; // {local: [], remote: [], variance: []}
	this._received = [];
	this._unsent = [];
	this.fetch = this.fetch.bind(this);
	this;
};

exports.DataChannel = DataChannel; // export class 
DataChannel.prototype.__rtc = {watch: 'rtcDidSet',name: 'rtc'};
DataChannel.prototype.rtc = function(v){ return this._rtc; }
DataChannel.prototype.setRtc = function(v){
	var a = this.rtc();
	if(v != a) { this._rtc = v; }
	if(v != a) { this.rtcDidSet && this.rtcDidSet(v,a,this.__rtc) }
	return this;
};
DataChannel.prototype.socket = function(v){ return this._socket; }
DataChannel.prototype.setSocket = function(v){ this._socket = v; return this; };

DataChannel.prototype.rtcDidSet = function (rtc,prev){
	// log 'datachannel rtc',rtc,prev
	
	var self = this;
	if (rtc) {
		rtc.binaryType = 'arraybuffer';
		rtc.onopen = function(_0) { return self.onopen(_0,rtc); }; // log 'onopen',$1,@rtc:readyState
		rtc.onclose = function(_0) { return self.onclose(_0,rtc); }; // log 'onclose',$1,@rtc:readyState
		rtc.onmessage = function(_0) { return self.onmessage(_0,rtc); };
		self.flush();
	};
	
	if (prev) {
		prev.onopen = function() { return true; };
		prev.onclose = function() { return true; };
		prev.onmessage = function() { return true; };
	};
	return self;
};

DataChannel.prototype.peer = function (){
	return this._socket.peer();
};

DataChannel.prototype.log = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return this._socket.log.apply(this._socket,params);
};

DataChannel.prototype.api = function (){
	return this._socket.api();
};

DataChannel.prototype.onopen = function (){
	this.log('onopen');
	// log 'onopen'
	this.flush();
	return this;
};

DataChannel.prototype.onclose = function (){
	this.log('onclose');
	// loose connection - should throw peersocket into disconnected state
	// TODO should check if this is the 'current' channel - after reset
	// socket.disconnected
	return this;
};

DataChannel.prototype.state = function (){
	return this._rtc ? this.rtc().readyState : 'closed';
};

DataChannel.prototype.onmessage = function (e){
	var now = Date.now();
	var packet = Packet.deserialize(e.data,this);
	var last = this._lastPacket;
	var jitterRef = this._refPacket;
	
	if (false && Math.random() > 0.98) {
		console.warn("ChaosMonkey grabbed message!!");
		return;
	};
	
	var delay = 0;
	
	packet._remoteTime = packet._ref;
	packet._localTime = packet._adjustedLocalTime = now;
	packet._jitter = 0;
	packet._ref = null;
	
	if (jitterRef) {
		let timeDelta = packet._localTime - packet._remoteTime;
		let remoteTimeDelta = (packet._remoteTime - jitterRef._remoteTime);
		let localTimeDelta = (packet._localTime - jitterRef._localTime);
		let delta = localTimeDelta - remoteTimeDelta;
		packet._jitter = delta;
		packet._adjustedLocalTime = packet._localTime - delta;
		this._variance.push(delta);
		// this means the refPacket had more delay
		
		if (delta < 0) {
			this._refPacket = packet;
		} else {
			true;
		};
	};
	
	if (len$(this._variance) == 50) {
		this.calcVariance();
		this._variance = [];
	};
	
	delay += this.socket().emulatedLatency();
	packet._jitterVariance = this.socket().jitter();
	
	packet._deliveryTime = Math.max(now + delay,this._lastPacket ? this._lastPacket._deliveryTime : 0);
	
	if (delay > 0) {
		this._received.push(packet);
		// log 'add delay',packet.@deliveryTime,now,packet.@deliveryTime - now
		setTimeout(this.fetch,delay);
	} else {
		this.api().onpacket(packet,this._socket.peer());
	};
	
	this._lastPacket = packet;
	this._refPacket || (this._refPacket = packet);
	return this;
};

DataChannel.prototype.flush = function (){
	if (this._unsent.length && this._rtc && this.state() == 'open') {
		for (let i = 0, items = iter$(this._unsent), len = items.length; i < len; i++) {
			this.send(items[i]);
		};
		this._unsent = [];
	};
	return this;
};

DataChannel.prototype.fetch = function (){
	var packet;
	if (packet = this._received.shift()) {
		return this.api().onpacket(packet,this._socket.peer());
	};
};


DataChannel.prototype.calcVariance = function (){
	return;
};

DataChannel.prototype.send = function (msg){
	if (!(this._rtc && this.state() == 'open')) {
		this._unsent.push(msg);
		return;
	};
	let packet = Packet.serialize(msg,{ref: Date.now(),scope: this.api()});
	return this.rtc().send(packet);
};


function UnreliableDataChannel(){ return DataChannel.apply(this,arguments) };

Imba.subclass(UnreliableDataChannel,DataChannel);
exports.UnreliableDataChannel = UnreliableDataChannel; // export class 
UnreliableDataChannel.prototype.calcVariance = function (){
	// TODO should definitely have some sort of moving average
	var Math_, v_;
	var sum = this._variance.reduce(function(a,b) { return a + b; },0);
	var max = Math.max.apply(Math,this._variance);
	var avg = sum / len$(this._variance);
	console.log(max,avg,this._variance);
	var val = Math.min(max,200);
	var prev = this.socket().jitter();
	return (this.socket().setJitter(v_ = Math.min(max,200)),v_);
};

function PeerSocket(peer){
	this._state = 'init';
	this._peer = peer;
	this._connectionNr = 0;
	this._remoteId = this.remoteId();
	this._jitter = 0;
	this._lastNegotiationTime = 0;
	this._channel = new DataChannel(this);
	this._udp = new UnreliableDataChannel(this);
	this;
};

exports.PeerSocket = PeerSocket; // export class 
PeerSocket.prototype.rtc = function(v){ return this._rtc; }
PeerSocket.prototype.setRtc = function(v){ this._rtc = v; return this; };
PeerSocket.prototype.state = function(v){ return this._state; }
PeerSocket.prototype.setState = function(v){ this._state = v; return this; };
PeerSocket.prototype.peer = function(v){ return this._peer; }
PeerSocket.prototype.setPeer = function(v){ this._peer = v; return this; };
PeerSocket.prototype.__jitter = {'default': 0,name: 'jitter'};
PeerSocket.prototype.jitter = function(v){ return this._jitter; }
PeerSocket.prototype.setJitter = function(v){ this._jitter = v; return this; }
PeerSocket.prototype._jitter = 0;
PeerSocket.prototype.__latency = {'default': 0,name: 'latency'};
PeerSocket.prototype.latency = function(v){ return this._latency; }
PeerSocket.prototype.setLatency = function(v){ this._latency = v; return this; }
PeerSocket.prototype._latency = 0;
PeerSocket.prototype.channel = function(v){ return this._channel; }
PeerSocket.prototype.setChannel = function(v){ this._channel = v; return this; };
PeerSocket.prototype.udp = function(v){ return this._udp; }
PeerSocket.prototype.setUdp = function(v){ this._udp = v; return this; };

PeerSocket.prototype.__localMedia = {watch: 'localMediaDidSet',name: 'localMedia'};
PeerSocket.prototype.localMedia = function(v){ return this._localMedia; }
PeerSocket.prototype.setLocalMedia = function(v){
	var a = this.localMedia();
	if(v != a) { this._localMedia = v; }
	if(v != a) { this.localMediaDidSet && this.localMediaDidSet(v,a,this.__localMedia) }
	return this;
};
PeerSocket.prototype.__media = {watch: 'mediaDidSet',name: 'media'};
PeerSocket.prototype.media = function(v){ return this._media; }
PeerSocket.prototype.setMedia = function(v){
	var a = this.media();
	if(v != a) { this._media = v; }
	if(v != a) { this.mediaDidSet && this.mediaDidSet(v,a,this.__media) }
	return this;
};
PeerSocket.prototype.__audio = {watch: 'audioDidSet',name: 'audio'};
PeerSocket.prototype.audio = function(v){ return this._audio; }
PeerSocket.prototype.setAudio = function(v){
	var a = this.audio();
	if(v != a) { this._audio = v; }
	if(v != a) { this.audioDidSet && this.audioDidSet(v,a,this.__audio) }
	return this;
};
PeerSocket.prototype.__video = {watch: 'videoDidSet',name: 'video'};
PeerSocket.prototype.video = function(v){ return this._video; }
PeerSocket.prototype.setVideo = function(v){
	var a = this.video();
	if(v != a) { this._video = v; }
	if(v != a) { this.videoDidSet && this.videoDidSet(v,a,this.__video) }
	return this;
};

PeerSocket.prototype.__emulatedLatency = {'default': 0,watch: 'emulatedLatencyDidSet',name: 'emulatedLatency'};
PeerSocket.prototype.emulatedLatency = function(v){ return this._emulatedLatency; }
PeerSocket.prototype.setEmulatedLatency = function(v){
	var a = this.emulatedLatency();
	if(v != a) { this._emulatedLatency = v; }
	if(v != a) { this.emulatedLatencyDidSet && this.emulatedLatencyDidSet(v,a,this.__emulatedLatency) }
	return this;
}
PeerSocket.prototype._emulatedLatency = 0;
PeerSocket.prototype.__connected = {'default': false,watch: 'connectedDidSet',name: 'connected'};
PeerSocket.prototype.connected = function(v){ return this._connected; }
PeerSocket.prototype.setConnected = function(v){
	var a = this.connected();
	if(v != a) { this._connected = v; }
	if(v != a) { this.connectedDidSet && this.connectedDidSet(v,a,this.__connected) }
	return this;
}
PeerSocket.prototype._connected = false;



PeerSocket.prototype.emulatedLatencyDidSet = function (val){
	return this.log('emulatedLatency',val);
};

PeerSocket.prototype.getAudioStats = async function (){
	var receiver = this._rtc.getReceivers()[0];
	var stats = await receiver.getStats(receiver.track);
	// console.log "received stats",JSON.stringify(stats)
	var audio;
	stats.forEach(function(stat) {
		if (stat.type == "track" && stat.kind == "audio") {
			return audio = stat;
		};
	});
	if (audio) {
		console.log(audio,audio.jitterBufferDelay,audio.totalSamplesReceived);
		console.log(audio.jitterBufferDelay / audio.totalSamplesReceived);
	};
	return audio;
};

PeerSocket.prototype.api = function (){
	return SCRIMBA_API;
};

PeerSocket.prototype.remoteId = function (){
	return this._peer.id;
};

PeerSocket.prototype.localId = function (){
	return this.api().peer().id;
};

PeerSocket.prototype.socket = function (){
	return this;
};

PeerSocket.prototype.user = function (){
	return this.peer().user();
};

PeerSocket.prototype.log = function (){
	var api_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	return (api_ = this.api()).log.apply(api_,[].concat([(this.localId() + '-' + this.remoteId())], [].slice.call(params)));
};

PeerSocket.prototype.state = function (){
	return this._rtc ? this.rtc().signalingState : '';
};

PeerSocket.prototype.iceState = function (){
	return this._rtc ? this.rtc().iceConnectionState : ((this.isMe() ? 'connected' : 'disconnected'));
};

PeerSocket.prototype.connectionState = function (){
	return this._rtc ? this.rtc().connectionState : ((this.isMe() ? 'connected' : 'disconnected'));
};

PeerSocket.prototype.isInitiator = function (){
	// to make things easy, we deterministically decide who should send the initial offer
	// based on the ids of each peer. This way, two peers will never try to actually initiate
	// an rtc connection with each other at the same time. One will ping the other to initiate
	// and the other will always initiate.
	return this.localId() > this.remoteId();
};

PeerSocket.prototype.isSupported = function (){
	return !(this.isMe());
};

PeerSocket.prototype.isConnected = function (){
	return this.iceState() == 'completed' || this.iceState() == 'completed' || this.channel().state() == 'open';
};

PeerSocket.prototype.isMe = function (){
	return this.peer() == this.me();
};

PeerSocket.prototype.me = function (){
	return this.api().peer();
};

PeerSocket.prototype.rtc = function (){
	var self = this;
	if (self._rtc) { return self._rtc };
	if (!(self.isSupported())) { return null };
	
	self._state = 'setup';
	self._rtc = new RTCPeerConnection({iceServers: self.api().socket().iceServers()},{optional: [{googDscp: true}]});
	self._rtc._nr = self._connectionNr++;
	
	if (self.isInitiator()) {
		console.log("is initiator - trying to create channel");
		try {
			self.channel().setRtc(self._rtc.createDataChannel('ordered',{ordered: true}));
			self.udp().setRtc(self._rtc.createDataChannel('unordered',{ordered: false})); // , maxRetransmits: 0, maxPacketLifeTime: null
		} catch (e) {
			console.log("error creating channels",e);
			throw e;
		};
	};
	
	let rtc = self._rtc;
	for (let i = 0, items = ['onicecandidate','ondatachannel','oniceconnectionstatechange','onaddstream','onremovestream','onnegotiationneeded'], len = items.length, ev; i < len; i++) {
		ev = items[i];
		self._rtc[ev] = function(e) {
			if (self._rtc == rtc) {
				self[ev](e,rtc);
				return Imba.commit();
			} else {
				return self.log("old event",e.type,e);
			};
		};
	};
	
	return self._rtc;
};

PeerSocket.prototype.open = async function (ns){
	if (this.isMe()) {
		return;
	};
	
	if (this.isInitiator()) {
		if (this._opening) { return };
		this._opening = true;
		this.reset();
		this.log("initiating",this.remoteId(),this.localId());
		if (this.localMedia() && this.rtc().getLocalStreams().indexOf(this.localMedia()) == -1) {
			this.log('adding media');
			this.rtc().addStream(this.localMedia());
		};
		this._offer = await this.rtc().createOffer({offerToReceiveAudio: true});
		this.setLocalDesc(this._offer);
	} else {
		this.log("the other peer should be the initiator",this.remoteId(),this.localId());
		this.api().socket().send([MSG.CONTACT,this.remoteId(),ns]);
	};
	
	return;
};

PeerSocket.prototype.close = function (){
	this.log('close');
	this.reset();
	return this;
};

PeerSocket.prototype.reset = function (){
	this.log('reset - removing peer');
	// possibly close the previous one
	this._channel.setRtc(null);
	this._udp.setRtc(null);
	if (this._rtc) {
		try {
			this._rtc.close();
			this.setConnected(false);
		} catch (e) {
			console.log("error on rtc reset",e);
		};
	};
	
	this._rtc = null;
	this.api().peers().remove(this.peer());
	return this;
};

// this peer has contacted us - to initiate a webrtc session
PeerSocket.prototype.invite = function (data){
	this._request = data;
	this.open();
	return this.channel().send([MSG.INVITE,this.remoteId(),data]);
};

PeerSocket.prototype.localMediaDidSet = function (media,prev){
	this.log('localMediaDidSet',media,prev);
	if (this.isMe()) {
		this.setMedia(media);
		return;
	};
	
	if (this.isConnected()) {
		return this.setLocalStream(media);
	};
};

PeerSocket.prototype.setLocalStream = async function (stream){
	if (this.isMe()) {
		this.setMedia(stream);
		return;
	};
	
	this.log('setLocalStream',stream);
	var locals = this.rtc().getLocalStreams();
	for (let i = 0, items = iter$(locals), len = items.length; i < len; i++) {
		this.rtc().removeStream(items[i]);
	};
	if (stream) { this.rtc().addStream(stream) };
	// only create new offer if anything has changed
	this._offer = await this.rtc().createOffer();
	return await this.setLocalDesc(this._offer);
};

PeerSocket.prototype.setLocalDesc = async function (desc){
	await this.rtc().setLocalDescription(desc);
	return this.api().socket().send([MSG.SDP,this.remoteId(),SCON.clone(this.rtc().localDescription)]);
};

PeerSocket.prototype.request = function (){
	return this._request;
};

PeerSocket.prototype.oncontact = function (e){
	this.log('oncontact',e);
	return this.open();
};

PeerSocket.prototype.onspdsignal = async function (data){
	this.log(('spd' + data.type),data);
	let sessionDesc = new RTCSessionDescription(data);
	await this.rtc().setRemoteDescription(sessionDesc);
	if (data.type == 'offer') {
		if (this.localMedia() && this.rtc().getLocalStreams().indexOf(this.localMedia()) == -1) {
			this.log('include media in answer');
			this.rtc().addStream(this.localMedia());
		};
		this._answer = await this.rtc().createAnswer();
		return await this.setLocalDesc(this._answer);
	};
};

PeerSocket.prototype.onicesignal = function (data){
	this.log('icesignal');
	return this.rtc().addIceCandidate(new RTCIceCandidate(data));
};

PeerSocket.prototype.oniceconnectionstatechange = function (e,rtc){
	let state = this.iceState();
	this.log('iceconnectionstatechange',state,rtc._nr);
	if (state == 'completed' || state == 'connected') {
		this.api().peers().add(this.peer()); // also remove peers?
		this.setConnected(true);
	} else if (state == 'closed' || state == 'disconnected' || state == 'failed') {
		this.setConnected(false);
	} else if (state == 'checking') {
		this.api().peers().add(this.peer());
	};
	return this;
};

PeerSocket.prototype.onicecandidate = function (e){
	// log 'onicecandidate'
	if (e.candidate != null) {
		return this.api().socket().send([MSG.ICE,this.remoteId(),SCON.clone(e.candidate)]);
	};
};

PeerSocket.prototype.onnegotiationneeded = function (e){
	return this.log('onnegotiationneeded');
};

PeerSocket.prototype.ontrack = function (e){
	return this.log("ontrack",e);
};

PeerSocket.prototype.onaddstream = function (e){
	var v_;
	this.log("onaddstream",e.stream,e);
	return (this.setMedia(v_ = e.stream),v_);
};

PeerSocket.prototype.onremovestream = function (e){
	var v_;
	this.log('onremovestream',e.stream);
	if (this.media() == e.stream) {
		return (this.setMedia(null),null);
	};
};

PeerSocket.prototype.ondatachannel = function (e){
	this.log('ondatachannel',e.channel.ordered);
	if (e.channel.ordered) {
		this.channel().setRtc(e.channel);
	} else {
		this.udp().setRtc(e.channel);
	};
	return this;
};

PeerSocket.prototype.connectedDidSet = function (bool){
	if (!bool) {
		console.log("reset so that we can open again(!)");
		return this._opening = null;
	};
};


PeerSocket.prototype.mediaDidSet = function (media,prev){
	if (media) {
		this.setAudio(media.getAudioTracks()[0]);
		this.setVideo(media.getVideoTracks()[0]);
		media._peer = this.peer();
	} else {
		this.setAudio(null);
		this.setVideo(null);
	};
	
	if (prev) { this.api().emit('mediaRemove',prev) };
	if (media) { this.api().emit('mediaAdd',media) };
	
	if (this.isMe()) {
		// possibly renegotiate with the other peers
		// for peer in api.peers
		// 	peer.rtc.setLocalStream(media)
	} else {
		if (false && this.api().broadcasting()) {
			// move somewhere else?
			if (prev) { this.api().broadcasting().mediaStreams().remove(prev) };
			if (media) { return this.api().broadcasting().mediaStreams().add(media) };
		};
	};
};

PeerSocket.prototype.audioDidSet = async function (audio,prev){
	// not when we are local
	if (this.isMe()) { return };
	this.log('audioDidSet');
	if (prev && this._mediaElement) {
		this.api().media().releaseAudioElement(this._mediaElement);
		this._mediaElement = null;
	};
	
	if (!audio) {
		return;
	};
	
	// should not return element until we have one that we know can play
	var element = await this.api().media().requestAudioElement();
	this._mediaElement = element; // document.createElement('audio')
	this._mediaElement.src = '';
	this._mediaElement.srcObject = this.media();
	// URL.createObjectURL(media)
	return this.api().media().playAudioElement(this._mediaElement);
};

PeerSocket.prototype.send = function (data,o){
	if(o === undefined) o = {};
	if (this.isSupported()) {
		try {
			// fallback to websocket?
			return (o.reliable == false || o.unreliable) ? this.udp().send(data) : this.channel().send(data);
		} catch (e) {
			return console.log("data-channel send error",e);
		};
	};
};
