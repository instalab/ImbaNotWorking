function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };

function Struct(raw){
	this._v = 0;
	this._data = raw;
};

exports.Struct = Struct; // export class 
Struct.diff = function (ref,struct,delta){
	if(delta === undefined) delta = true;
	if (ref == struct) {
		return null;
	};
	
	if (!ref) {
		// if there is no reference, we return
		// a patch where everything is changed
		return [0].concat(struct);
	};
	
	// the struct shouldnt include the mask - doesnt make sense
	
	
	var diff = [0];
	var i = 0;
	var size = ref.length;
	var structSize = struct.length;
	
	if (size < 1) {
		return [0].concat(struct);
	};
	
	if (structSize > size) {
		size = structSize;
	};
	
	// loop through the params and build
	// a diff describing them
	while (i < size){
		let a = ref[i];
		let b = struct[i];
		if (a == b) { // same array counts as well?
			i++;
			continue;
		};
		let v = b;
		
		if (delta) {
			let ta = typeof a;
			let tb = typeof b;
			if (tb == ta && tb == 'number') {
				v = b - (a || 0);
			};
		};
		// add flag for this field nr
		diff[0] = diff[0] | (1 << i);
		diff.push(v);
		i++;
	};
	
	return (diff[0] == 0) ? null : diff;
};

Struct.patch = function (struct,diff,delta){
	if(delta === undefined) delta = true;
	if (!diff) {
		return struct;
	};
	
	// if there is nothing to patch
	// expect that the new struct is in diff
	if (!struct) {
		return diff.slice(1);
	};
	
	var mask = diff[0];
	
	if (mask == 0 && diff.length == 1) {
		// nothing is different
		return struct;
	};
	
	var i = 0;
	var slot = 0;
	var size = struct.length;
	
	while ((i < size) || mask >= (1 << i)){
		// is it set here
		if (mask == 0 || mask & (1 << i)) {
			var val = diff[++slot];
			
			if (delta) {
				var typ = typeof val;
				var ptyp = typeof struct[i];
				if (typ == ptyp && typ == 'number') {
					// NaN is not truthy - so here we are coercing NaN to 0
					val = (struct[i] || 0) + (val || 0);
				};
			};
			
			struct[i] = val;
		};
		i++;
	};
	return struct;
};

Struct.decode = function (ref,diff,delta){
	if(delta === undefined) delta = true;
	return this.patch(ref.slice(),diff,delta);
};

// def self.encode relative, diff, delta = yes


Struct.diffold = function (a,b){
	if (a == b) {
		return null;
	};
	
	if (!a) {
		return b;
	};
	
	var diff = this.encode(a,b);
	
	if (diff.length > 1) {
		return diff;
	};
	
	return null;
};

Struct.desc = function (items){
	this.prototype._map = this._map = items;
	this._defaults = [];
	
	var getter = function(i) {
		return function() { return this._data[i]; };
	};
	
	for (let i = 0, ary = iter$(items), len = ary.length; i < len; i++) {
		this._defaults.push(0);
		this.prototype[ary[i]] = getter(i);
	};
	return this;
};

Struct.build = function (obj,arr){
	if(arr === undefined) arr = null;
	if (obj instanceof this) {
		return obj;
	};
	
	if (obj instanceof Array) {
		return new this(obj);
	} else if (obj instanceof Object) {
		// console.log "update data!",obj
		return new this(this._defaults.slice()).set(obj);
	} else {
		return new this(this._defaults.slice());
	};
};

Struct.fromObject = function (obj){
	return this;
};

Struct.equals = function (a,b){
	return a === b || JSON.stringify(a && a._data || a) == JSON.stringify(b && b._data || b);
};

Struct.prototype.wrap = function (raw){
	if (raw instanceof this.constructor) {
		raw = raw._data;
	};
	
	if (this._data != raw) {
		this._data = raw;
		this._v++;
	};
	
	return this;
};

Struct.prototype.clone = function (){
	return new this.constructor(this._data.slice());
};

Struct.prototype.equals = function (other){
	return this.constructor.equals(this,other);
};

Struct.prototype.set = function (key,val){
	if (key instanceof Object) {
		for (let v, i = 0, keys = Object.keys(key), l = keys.length, k; i < l; i++){
			k = keys[i];v = key[k];this.set(k,v);
		};
		return this;
	};
	
	let idx = this._map.indexOf(key);
	if (idx >= 0) {
		this._data[idx] = val;
	};
	
	return this;
};

Struct.prototype.toObject = function (){
	var obj = {};
	for (let i = 0, items = iter$(this._map), len = items.length; i < len; i++) {
		obj[items[i]] = this._data[i];
	};
	return obj;
};

Struct.prototype.toArray = function (){
	return this._data;
};

Struct.prototype.valueOf = function (){
	return this._data;
};
