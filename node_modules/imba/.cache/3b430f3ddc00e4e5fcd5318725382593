var self = {};
var db$ = require('../server/db'), db = db$.db, rdb = db$.rdb;

var ffmpeg = require('./ffmpeg');
var util = require('../util');
var path = require('path');
var fs = require('fs');

var DB = require('../store/db').DB;
var sdb = DB.instance();

var env = require('../env');
var ROOT = env.get("FILES_DIR");

var TimelineCues = require('../scrimba/util/TimelineCues').TimelineCues;
var StreamBuffer = require('../scrimba/core/StreamBuffer').StreamBuffer;

var SCON = require('../scrimba/protocol').SCON;
var crypto = require('crypto');

function Publisher(aid){
	this._aid = aid;
	if (aid instanceof Object) {
		this._job = this._aid;
	};
	this;
};

exports.Publisher = Publisher; // export class 
Publisher.prototype.aid = function(v){ return this._aid; }
Publisher.prototype.setAid = function(v){ this._aid = v; return this; };

Publisher.prototype.load = async function (){
	if (this._loaded) { return Promise.resolve(this) };
	this._loaded = true;
	this._job = await (this._job || sdb.fetch(this._aid));
	this._cast = await sdb.fetch(this._job.cid);
	this._params = this._job.params;
	this._draft = this._params.draft;
	this._cues = new TimelineCues(this._draft);
	this._pub = SCON.clone(this._draft);
	return this;
};

Publisher.prototype.publish = async function (){
	await this.load();
	await this.generateAudio();
	await this.generateStreamFile();
	return await this.finish();
};

Publisher.prototype.generateAudio = async function (){
	// skip if we have no audio!
	var fid = await ffmpeg.audioForCues(this._draft);
	this._pub.audio = fid;
	return this;
};

Publisher.prototype.generateStreamFile = async function (){
	var stream = await rdb.getBuffer(("" + (this._job.cid) + ":stream3"));
	console.log("received stream",stream && stream.length);
	var hash = crypto.createHash('md5','binary').update(stream).digest('hex');
	var destname = ("" + (this._cast.id) + "." + hash + ".stream");
	var dest = path.resolve(ROOT,destname);
	
	// should be async?
	fs.writeFileSync(dest,stream);
	
	try {
		// json
		var json = StreamBuffer.decode(stream);
		fs.writeFileSync(dest + '.json',JSON.stringify(json));
	} catch (e) { };
	
	this._pub.actions = destname;
	return this;
};

Publisher.prototype.finish = async function (){
	// need to support transactions no?
	var item;
	await this._job.update(
		{state: 'success',
		result: this._pub}
	);
	
	var upd = {
		pub: this._pub,
		duration: this._cues.duration()
	};
	
	if (this._params.set) {
		for (let o = this._params.set, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
			k = keys[i];v = o[k];upd[k] = v;
		};
	};
	
	upd.id = this._params.id;
	
	if (this._cast.published_at) {
		upd.republished_at = new Date();
	} else {
		upd.published_at = new Date();
	};
	
	if ((upd.privacy || this._cast.privacy) == 'public') {
		upd.s = 1;
	};
	
	return item = await sdb.put(upd);
};

exports.publish = self.publish = function (vid){
	var job = new Publisher(vid);
	return job.publish();
};

// var job = Publisher.new('cv-6')
// await job.publish
// console.log "done!"