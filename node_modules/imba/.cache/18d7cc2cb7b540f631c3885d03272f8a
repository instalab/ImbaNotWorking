function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');
var WaveformData = require('waveform-data');
var WaveformWebAudioBuilder = require('waveform-data/webaudio');
var WaveformAudioDecoder = require('waveform-data/lib/builders/audiodecoder');

function AudioManager(){
	this._loaders = {};
	this._buffers = {};
	this._waveforms = {};
	this._volume = 1;
	this._muted = false;
	this._media = [];
	this;
};

exports.AudioManager = AudioManager; // export class 
AudioManager.instance = function (){
	return this._instance || (this._instance = new this());
};

AudioManager.prototype.__outputLatency = {'default': 0,name: 'outputLatency'};
AudioManager.prototype.outputLatency = function(v){ return this._outputLatency; }
AudioManager.prototype.setOutputLatency = function(v){ this._outputLatency = v; return this; }
AudioManager.prototype._outputLatency = 0;

AudioManager.prototype.enumerateDevices = function (){
	var self = this;
	return self._enumerator || (self._enumerator = window.navigator.mediaDevices.enumerateDevices().then(function(devices) {
		self._devices = devices.filter(function(device) {
			return device.kind == 'audioinput';
		});
		self._enumerator = null;
		return Imba.Scheduler.event(self);
	}));
};

AudioManager.prototype.devices = function (){
	var self = this;
	if (!self._devices) {
		self._devices = [];
		window.navigator.mediaDevices.ondevicechange = function(e) { return self.enumerateDevices(); };
		self.enumerateDevices();
	};
	return self._devices;
};

AudioManager.prototype.canRecordAudio = function (){
	return window.navigator.mediaDevices && window.navigator.mediaDevices.getUserMedia && window.MediaRecorder;
};

AudioManager.prototype.mute = function (){
	this._muted = true;
	return this.updateGain();
};

AudioManager.prototype.unmute = function (){
	this._muted = false;
	this.updateGain();
	return this;
};

AudioManager.prototype.getMuted = function (){
	return this._muted;
};

AudioManager.prototype.getVolume = function (){
	return this._volume;
};

AudioManager.prototype.setVolume = function (volume){
	this._volume = volume;
	return this.updateGain();
};

AudioManager.prototype.getRealVolume = function (){
	return this.getMuted() ? 0 : this.getVolume();
};

AudioManager.prototype.updateGain = function (){
	var volume = this.getRealVolume();
	
	// no need to setup a webaudio directly
	if (this._context) {
		this.gainNode().gain.value = volume;
	};
	
	for (let i = 0, items = iter$(this._media), len = items.length; i < len; i++) {
		items[i].volume = volume;
	};
	return this;
};

AudioManager.prototype.urlForId = function (id){
	let el = this._audioElement || (this._audioElement = document.createElement('audio'));
	let path = "/cdn/" + id;
	let postfix = "";
	
	if (el.canPlayType('audio/ogg;codecs="opus"')) { // and /Chrome/.test(ua)
		return ("" + path.replace('.ogg','') + ".ogg" + postfix);
	} else if (el.canPlayType('audio/webm;codecs="opus"')) { // and /Chrome/.test(ua)
		return ("" + path.replace('.webm','') + ".webm" + postfix);
	} else if (el.canPlayType('audio/mp4')) {
		return ("" + path + ".m4a" + postfix);
	} else {
		return ("" + path + ".mp3" + postfix);
	};
};

AudioManager.prototype.loadBufferForId = function (id){
	var self = this;
	return self._loaders[id] || (self._loaders[id] = new Promise(async function(resolve) {
		var file = SDB.get(id);
		// console.log "load buffer for id",id,file
		
		// check if file exists locally?
		var buf = await file.fetchAsArrayBuffer(self.urlForId(id));
		
		var err = function(e) {
			console.log("error from decodeAudioData",e);
			// @buffers[id] = e
			return resolve(null);
		};
		
		self.context().decodeAudioData(buf,function(buffer) {
			self._buffers[id] = buffer;
			return resolve(buffer);
		},err);
		return;
	}));
};

AudioManager.prototype.waveformForAudioBuffer = function (buffer){
	return new Promise(function(resolve) {
		var cb = function(err,wf,audio) {
			// console.log "waveform cb",arguments
			return resolve(wf);
		};
		
		var fn = WaveformAudioDecoder({scale: 512,amplitude_scale: 1.0},cb);
		return fn(buffer);
	});
};

AudioManager.prototype.waveformForId = function (id){
	var self = this;
	var key = id + ".dat";
	return self._loaders[key] || (self._loaders[key] = new Promise(async function(resolve) {
		// console.log "fetch waveformForId",id
		// look in local cache
		// try to fetch from cache first
		
		var cached = await SDB.cacheGet(key);
		CCA = cached && cached.body;
		
		if (cached) {
			// console.time 'waveFormCreate'
			resolve(WaveformData.create(cached.body));
			// console.timeEnd 'waveFormCreate'
			return;
		};
		
		var buf = await self.loadBufferForId(id);
		
		if (!buf || (buf instanceof Error)) {
			return resolve(null);
		};
		// console.time 'waveFormGen'
		var wf = await self.waveformForAudioBuffer(buf);
		// console.timeEnd 'waveFormGen'
		var dat = wf.adapter.data.buffer; // .byteLength
		await SDB.cacheSet(key,{body: dat});
		return resolve(wf);
	}));
};

AudioManager.prototype.durationForBlob = function (blob,expectedDuration){
	if(expectedDuration === undefined) expectedDuration = 3600000;
	return new Promise(function(resolve) {
		var audio = new Audio();
		var resolved = false;
		var check = function() {
			var dur = audio.duration;
			console.log("checkDuration",dur);
			if (dur != Infinity && !resolved) {
				audio.ondurationchange = null;
				audio.onloadeddata = null;
				resolved = true;
				return resolve(dur * 1000);
			};
		};
		
		audio.ondurationchange = check;
		audio.onloadeddata = check;
		audio.src = URL.createObjectURL(blob);
		audio.load();
		audio.currentTime = (expectedDuration / 1000) * 1.5;
		
		// TODO add onerror
		audio.onerror = function(e) {
			console.log("error!",e);
			if (!resolved) {
				resolved = true;
				return resolve(0);
			};
		};
		return;
	});
};

AudioManager.prototype.audioBufferFromBlob = function (blob){
	var self = this;
	return new Promise(function(resolve,reject) {
		var fileReader = new FileReader();
		fileReader.onload = function() {
			let data = this.result;
			return self.context().decodeAudioData(data,resolve,reject);
		};
		
		return fileReader.readAsArrayBuffer(blob);
	});
};

AudioManager.prototype.durationForAudioElement = function (audio,expectedDuration){
	if(expectedDuration === undefined) expectedDuration = 3600000;
	return new Promise(function(resolve) {
		var resolved = false;
		var check = function() {
			var dur = audio.duration;
			console.log("checkDuration",dur);
			if (dur != Infinity && !Number.isNaN(dur) && !resolved) {
				resolved = true;
				audio.ondurationchange = null;
				audio.onloadeddata = null;
				audio.currentTime = 0;
				return resolve(dur * 1000);
			};
		};
		
		audio.ondurationchange = check;
		audio.onloadeddata = check;
		audio.onerror = function(e) {
			console.log("error!",e);
			if (!resolved) {
				resolved = true;
				return resolve(0);
			};
		};
		// audio:src = URL.createObjectURL(blob)
		audio.load();
		audio.currentTime = (expectedDuration / 1000) * 1.5;
		check();
		// TODO add onerror
		
		return;
	});
};


AudioManager.prototype.context = function (){
	return this._context || (this._context = new (window.AudioContext || window.webkitAudioContext)());
};

AudioManager.prototype.output = function (){
	return this.context().destination;
};

AudioManager.prototype.gainNode = function (){
	if (!this._gainNode) {
		this._gainNode = this.context().createGain();
		this._gainNode.connect(this.output());
		this._gainNode.gain.value = this.getRealVolume();
	};
	return this._gainNode;
};

AudioManager.prototype.sourceForMedia = function (media){
	return media._mediaSource || (media._mediaSource = this.context().createMediaElementSource(media));
};

AudioManager.prototype.registerMedia = function (media){
	media.volume = this.getRealVolume();
	if (this._media.indexOf(media) < 0) {
		this._media.push(media);
	};
	return this;
};

AudioManager.prototype.deregisterMedia = function (media){
	var idx = this._media.indexOf(media);
	if (idx >= 0) {
		this._media.splice(idx,1);
	};
	return this;
};

AudioManager.prototype.scheduleClips = function (clips,startTime,playbackRate){
	if(startTime === undefined) startTime = 0;
	if(playbackRate === undefined) playbackRate = 1;
	var ctxTime = this.context().currentTime * 1000;
	// console.log "scheduleClips",startTime,clips
	
	if (this.outputLatency()) {
		startTime += this.outputLatency();
	};
	
	for (let i = 0, items = iter$(clips), len = items.length, item; i < len; i++) {
		item = items[i];
		var buffer = item.buffer || this._buffers[item.fid];
		
		if (!buffer) {
			// console.log 'cannot find audiobuffer'
			continue;
		};
		
		var startAt = (item.t0 - startTime) + ctxTime;
		var dur = (item.t1 - item.t0);
		var skip = item.skip;
		// remove popping -- popping should no longer exist
		// if skip == 0
		// 	skip = 150
		// 	startAt += 150
		// 	# change duration?
		// 	dur -= 150
		
		if (ctxTime > (startAt + dur)) {
			continue;
		};
		
		// make sure we dont start before
		if (startAt < ctxTime) {
			skip += (ctxTime - startAt);
			dur -= (ctxTime - startAt);
			startAt = ctxTime;
		};
		
		if (dur < 200) {
			continue;
		};
		
		var bufDur = buffer.duration * 1000;
		// console.log("buffer duration",{bdur: bufDur,skip: skip, clipdur: dur})
		
		if ((bufDur - skip) < 100) {
			continue;
		};
		
		// console.log "start clip at",startAt - ctxTime,skip,dur
		var src = item.node = this.context().createBufferSource();
		src.buffer = buffer;
		
		// unless playbackRate == 1
		// 	src:playbackRate:value = playbackRate
		let pbrStartAt = ((startAt - ctxTime) / playbackRate) + ctxTime;
		// console.log "start clip at",pbrStartAt,startAt,ctxTime,skip,dur,playbackRate
		startAt = pbrStartAt;
		
		src.connect(this.gainNode());
		src.start(startAt / 1000,skip / 1000,dur / 1000);
		if (playbackRate != 1) {
			src.playbackRate.value = playbackRate;
		};
	};
	
	return clips;
};

AudioManager.prototype.unscheduleClips = function (clips){
	for (let i = 0, items = iter$(clips), len = items.length, item; i < len; i++) {
		item = items[i];
		if (item.node) { item.node.stop() };
	};
	return this;
};
