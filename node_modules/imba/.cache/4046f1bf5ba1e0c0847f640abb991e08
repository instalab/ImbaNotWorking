var self = {};
var env = require('../env');
var knex = require("knex");
var pg = require('pg');

var Redis = require('./redis').Redis;

var uri = ("postgres://" + env.get('PG_URI'));

var db = exports.db = knex({client: 'pg',connection: uri,debug: false});
// export var rdb = Redis.new(port: env.get('REDIS_PORT'))

if (env.get('DEBUG')) {
	db.on('query',function(q) { return console.log("knex:query",q.sql); });
};

db.put = async function (table,data){
	var v_, $1;
	var row;
	
	(((v_ = data.CODE),delete data.CODE, v_));
	((($1 = data.v),delete data.v, $1));
	
	if (data.id) {
		row = await db.table(table).where({id: data.id}).first();
	};
	if (row) {
		row = await db.table(table).update(data).returning('*').where({id: row.id});
	} else {
		row = await db.table(table).insert(data).returning('*');
	};
	
	return row[0] || row;
};

db.rpc = async function (name,args){
	if(args === undefined) args = [];
	var qs = args.map(function() { return '?'; }).join(',');
	var res = await this.raw(("SELECT api_" + name + "(" + qs + ") as resp"),args);
	return res.rows[0].resp;
};

db.syncStores = async function (stores,filters){
	
	if(filters === undefined) filters = {};
	var getSeq = function(name) {
		return db.table(("" + name + "_v_seq")).select('last_value').first();
	};
	
	var models = [];
	
	var promises = stores.map(async function(req) {
		var name = req[0];
		var type = req[1];
		var v = req[2] || 0;
		// var v = state:v or 0
		var seq = await getSeq(name);
		
		var v1 = parseInt(seq && seq.last_value);
		var q = db.table(name).where('v','>',v).orderBy('v','desc');
		
		return q.then(function(res) {
			if (filters[name]) {
				res = res.filter(filters[name]);
			};
			
			models.push.apply(models,res);
			return v1;
			
			// SELECT sequence_name, last_value FROM table_v_seq;
			// [name,type,v1,res]
			// {store: name, data: res, state: {v0: v, v: v1}}
		});
	});
	
	var res = await Promise.all(promises);
	return [models,res];
};

exports.pgconnect = self.pgconnect = function (cb){
	return pg.connect(uri,cb);
};
