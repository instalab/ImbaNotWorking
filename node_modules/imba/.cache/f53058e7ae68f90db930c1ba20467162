function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');
var protocol$ = require('../protocol'), ACTION = protocol$.ACTION, POINTERMASK = protocol$.POINTERMASK;
var PointerUpdate = require('../core/StreamAction').PointerUpdate;
var pointUtil = require('./Point');
function PointerTracker(space){
	var self = this;
	self._space = space;
	self._handler = function(e) { return self.onevent(e); };
	self._intercept = ['mousemove','mousedown','mouseup','mouseout'];
	self._last = Date.now();
	self._captures = false;
	self._evoptions = {passive: true,capture: false};
	self._mask = 0;
	self._hover = null;
	space.on('browserevent',function(e) { return self.onbrowserevent(e); });
	self._keydown = function(e) { return self.onkeydown(e); };
	self._windowhide = function() { return (self.setHidden(true),true); };
	self._windowout = function(e) {
		// console.log "mouseout window",e:relatedTarget
		if (e.relatedTarget == null) {
			// console.log "hide mouse!!"
			return (self.setHidden(true),true);
		};
	};
	self;
};

exports.PointerTracker = PointerTracker; // export class 
PointerTracker.prototype.space = function(v){ return this._space; }
PointerTracker.prototype.setSpace = function(v){ this._space = v; return this; };
PointerTracker.prototype.hover = function(v){ return this._hover; }
PointerTracker.prototype.setHover = function(v){ this._hover = v; return this; };

PointerTracker.prototype.lockedOnTarget = function(v){ return this._lockedOnTarget; }
PointerTracker.prototype.setLockedOnTarget = function(v){ this._lockedOnTarget = v; return this; };
PointerTracker.prototype.__hidden = {watch: 'hiddenDidSet',name: 'hidden'};
PointerTracker.prototype.hidden = function(v){ return this._hidden; }
PointerTracker.prototype.setHidden = function(v){
	var a = this.hidden();
	if(v != a) { this._hidden = v; }
	if(v != a) { this.hiddenDidSet && this.hiddenDidSet(v,a,this.__hidden) }
	return this;
};

PointerTracker.prototype.agent = function (){
	return this.space().me();
};


PointerTracker.prototype.isActive = function (){
	return this._active;
};

PointerTracker.prototype.start = function (){
	if (this._active) { return };
	for (let i = 0, items = iter$(this._intercept), len = items.length; i < len; i++) {
		this.space().view().dom().addEventListener(items[i],this._handler,this._evoptions);
	};
	window.addEventListener('keydown',this._keydown,{passive: true,capture: true});
	this.space().api().on('hide',this._windowhide);
	window.addEventListener('blur',this._windowhide);
	window.addEventListener('mouseout',this._windowout);
	this._active = this._ts = Date.now();
	return this;
};

PointerTracker.prototype.stop = function (){
	if (!this._active) { return };
	for (let i = 0, items = iter$(this._intercept), len = items.length; i < len; i++) {
		this.space().view().dom().removeEventListener(items[i],this._handler,this._evoptions);
	};
	window.removeEventListener('keydown',this._keydown,{passive: true,capture: true});
	window.removeEventListener('blur',this._windowhide);
	window.removeEventListener('mouseout',this._windowout);
	this.space().api().un('hide',this._windowhide);
	this._active = false;
	return this;
};

PointerTracker.prototype.targetForElement = function (el){
	var hover = null;
	var isInside = false;
	var origTarget = el;
	// if simulator is front and center - the pointer should
	// stay with it. Hardcoded exception - should generalize?
	// if sim and (e:simX != undefined or sim.node.shouldCapturePointer)
	//	targetNode = sim.node
	while (el){
		if (el._tag && el._tag.targetForPointer) {
			if (hover = el._tag.targetForPointer(origTarget)) {
				break;
			};
		};
		el = el.parentNode;
	};
	return hover;
};

PointerTracker.prototype.onbrowserevent = function (e){
	var browser = this.space().browser()._node;
	
	var layout = this.space().view().layoutForNode(browser);
	
	var data = {
		type: e.type,
		buttons: e.buttons,
		spaceX: layout[1] + e.clientX * (layout[2] / e.windowWidth), // browser.dom:offsetLeft
		spaceY: layout[0] + e.clientY * (layout[3] / e.windowHeight), // browser.dom:offsetTop
		spaceTarget: browser,
		shiftKey: e.shiftKey
	};
	return this.onevent(data);
};

PointerTracker.prototype.onkeydown = function (e){
	// console.log 'onkeydown',e:key
	if (Imba.indexOf(e.key,["Shift","Meta","Alt","Control"]) >= 0) { return };
	this.setHidden(true);
	return this;
};

PointerTracker.prototype.onevent = function (e){
	var rec = this.space().recording();
	
	// if !rec or rec.state != 'started'
	// 	# only track when recording
	// 	return
	
	if (!this._active || !(this.canPush())) {
		return;
	};
	
	if (e.type == 'mouseout') {
		let rel = (e.relatedTarget || e.toElement);
		if (!rel || !this.space().view().dom().contains(rel)) { (this.setHidden(true),true) };
		// console.log 'mouseout',e,e:target,e:relatedTarget,e:toElement
		return;
	};
	
	
	var now = Date.now();
	var elapsed = now - this._last;
	
	var vp = this.space().view().box();
	
	var x = (e.spaceX != null) ? ((e.spaceX)) : ((e.clientX - vp.left));
	var y = (e.spaceY != null) ? ((e.spaceY)) : ((e.clientY - vp.top));
	var hover = this.lockedOnTarget() || e.spaceTarget || this.targetForElement(e.target);
	var btn = e.button;
	
	if (this.space().option('disableLayoutOptimizations') && false) {
		var pt = pointUtil.convertPointFromPageToNode(this.space().view().dom().parentNode,e.pageX,e.pageY);
		// console.log "PointerTracker.{e:type}",e,x,y,vp
		var x2 = e.layerX; // offsetX # 
		var y2 = e.layerY; // offsetY # 
		let root = this.space().view()._viewport.dom();
		let offsetEl = e.target.offsetParent;
		// what about scrolling?
		while (root != offsetEl && root.contains(offsetEl)){
			x2 += offsetEl.offsetLeft;
			y2 += offsetEl.offsetTop;
			offsetEl = offsetEl.offsetParent;
		};
		console.log(e,x,y,x2,y2,e.target.className,pt);
		x = x2;
		y = y2;
	};
	
	
	x = Math.round(x);
	y = Math.round(y);
	
	var trigger = (x != this._x || y != this._y);
	
	if (e.type != 'mousemove') {
		// space.api.log :mouse, e:type, e
		trigger = true;
	};
	
	this._mask = e.buttons || 0;
	
	if (e.buttons == undefined && typeof btn == 'number') {
		this._mask = e.which || 0;
		if (e.type == 'mouseup') {
			this._mask = 0;
		};
	};
	
	if (hover != this._hover) {
		this.setHover(hover);
		trigger = true;
	};
	
	if (trigger) {
		this.setHidden(false);
		this._x = x;
		this._y = y;
		this.stamp();
		return this._last = now;
	};
	// @last = now
};

PointerTracker.prototype.stamp = function (){
	var frame = {
		x: this._x,
		y: this._y,
		flags: this._mask,
		hover: (this._hover ? this._hover.sref() : null)
	};
	this.push(frame,this._hover);
	return this;
};

PointerTracker.prototype.canPush = function (){
	return this.space().isLive() && !this.space().isSpectating() && (this.space().stream().recording() || len$(this.space().peers()) > 1 || this.space().option('demo'));
};

PointerTracker.prototype.hiddenDidSet = function (hidden,prev){
	if (hidden) {
		// console.log "pointer autohide",hidden
		if (this.canPush()) {
			return this.space().branch().push_(ACTION.POINTER_HIDE,[]);
		};
	};
	// else
	//	console.log "pointer autoshow"
};


PointerTracker.prototype.push = function (frame,target){
	if (this.space().isLive() && !this.space().isSpectating()) {
		if (target) {
			this.space().view().pushNodeLayout(target);
		};
		
		var action = PointerUpdate.build(frame);
		action._branch = this.space().branch();
		action._agent = this.space().me();
		// why are we bypassing space.__push?
		this.space().branch().addLocalEvent(action);
		// space.view.@pointer.keyframe = action
		// space.view.@pointer.render
		// agent.push_(ACTION.POINTER,null,frame)
	};
	return this;
};

PointerTracker.prototype.tick = function (){
	return this;
};
