function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba');


function Queue(owner,parent){
	this._parent = parent;
	this._owner = owner;
	this._commit = owner.commit;
	this._pending = [];
	this._errors = [];
	this._state = 'idle';
	this;
};

exports.Queue = Queue; // export class 
Queue.prototype.error = function(v){ return this._error; }
Queue.prototype.setError = function(v){ this._error = v; return this; };
Queue.prototype.errors = function(v){ return this._errors; }
Queue.prototype.setErrors = function(v){ this._errors = v; return this; };
Queue.prototype.__state = {watch: 'stateDidSet',name: 'state'};
Queue.prototype.state = function(v){ return this._state; }
Queue.prototype.setState = function(v){
	var a = this.state();
	if(v != a) { this._state = v; }
	if(v != a) { this.stateDidSet && this.stateDidSet(v,a,this.__state) }
	return this;
};

Queue.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};

Queue.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

Queue.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

Queue.prototype.map = function (cb){
	return this._pending.map(cb);
};

Queue.prototype.len = function (){
	return this._pending.length;
};

Queue.prototype.busy = function (){
	return len$(this) > 0;
};

Queue.prototype.idle = function (){
	return len$(this) == 0;
};

Queue.prototype.failed = function (){
	return len$(this._errors);
};

Queue.prototype.reset = function (){
	this._errors = [];
	return this;
};

Queue.prototype.error = function (){
	return this._errors[0] && this._errors[0]._uxa.error;
};

Queue.prototype.add = function (o,callback){
	// return self if failed
	// incr
	
	var self = this;
	if(callback==undefined && typeof o == 'function') callback = o,o = {};
	if(o==undefined) o = {};
	if ((typeof o=='number'||o instanceof Number)) {
		o = {duration: o};
	};
	
	o.duration || (o.duration = 1000);
	o.startAt = Date.now();
	o.state = 'pending';
	
	if (o.duration) {
		o.endAt = o.startAt + o.duration;
	};
	
	var res = callback;
	if (res instanceof Function) {
		res = res();
	};
	
	if (res && res.then) {
		res._uxa = o;
		self.incr(res);
		return res.then(function(ok) { return self.decr(res,ok); },function(err) { return self.fail(res,err); });
	};
	
	return self;
};


Queue.prototype.incr = function (promise){
	this._pending.push(promise);
	
	if (len$(this._pending) == 1) {
		this.setState('busy');
	};
	Imba.emit(this,'incr',[this,promise]);
	if (this._parent) { return this._parent.incr(promise) };
};

Queue.prototype.decr = function (promise,res){
	var idx = this._pending.indexOf(promise);
	
	if (idx >= 0) {
		// should we remove immediately?
		this._pending.splice(idx,1);
		promise._uxa.endedAt = Date.now();
		
		// how do we deal with errors?
		if (promise._uxa.error) {
			this._errors.push(promise);
		};
		
		Imba.emit(this,'decr',[this,promise]);
		
		if (len$(this._pending) == 0) {
			this.setState('idle');
		};
		
		if (this._parent) { return this._parent.decr(promise,res) };
	};
};

Queue.prototype.fail = function (promise,err){
	// console.log "promise.fail",WP =promise
	promise._uxa.error = err;
	return this.decr(promise);
};

Queue.prototype.stateDidSet = function (state,prev){
	// console.log "Queue {prev} -> {state}"
	
	if (state == 'busy') {
		this._owner && this._owner.trigger  &&  this._owner.trigger('uxa:busy');
	} else if (state == 'idle') {
		this._owner && this._owner.trigger  &&  this._owner.trigger('uxa:idle');
		this._owner && this._owner.commit  &&  this._owner.commit(); // really?
	};
	
	return Imba.emit(this,state,[]);
};

Queue.prototype.then = function (cb){
	if (this.state() == 'idle') {
		return cb();
	} else {
		return Imba.once(this,'idle',cb);
	};
};
