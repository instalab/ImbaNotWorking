function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var Imba = require('imba'), _1 = Imba.createElement;
var Widget = require('./widget').Widget;
var SlideWidget = require('./SlideWidget').SlideWidget;
var SlidesView = require('../views/SlidesView').SlidesView;

// import fetchFromGoogleSlides from '../util/SlidesImporter'

function SlidesWidget(){ return Widget.apply(this,arguments) };

Imba.subclass(SlidesWidget,Widget);
exports.SlidesWidget = SlidesWidget; // export class 
SlidesWidget.option('url');
SlidesWidget.option('visible',{'default': false,overridable: true});
SlidesWidget.option('currentSlide');
SlidesWidget.option('currentIndex',{'default': 0});

// list of widget-ids referring to the slides to use
SlidesWidget.option('items');
SlidesWidget.option('width');
SlidesWidget.option('height');

// slides -- ids with order

SlidesWidget.prototype.setup = function (){
	return this;
};

SlidesWidget.prototype.node = function (){
	return this._node || (this._node = (_1(SlidesView)).setData(this).end());
};

SlidesWidget.prototype.stepForward = function (keyframesOnly){
	// possibly step forward within current slide
	if(keyframesOnly === undefined) keyframesOnly = false;
	let curr = this.currentSlide();
	if (curr && curr.steps() && curr.steps()[curr.currentStep() + 1]) {
		if (keyframesOnly) {
			curr.setCurrentStep(len$(curr.steps()) - 1);
		} else {
			curr.setCurrentStep(curr.currentStep() + 1);
		};
		return this;
	};
	// jump to next slide and reset currentStep to -1
	// currentIndex = (currentIndex + 1) % items:length
	this.setCurrentIndex(Math.min(this.currentIndex() + 1,this.items().length - 1));
	
	if (keyframesOnly) {
		this.currentSlide().setCurrentStep(len$((this.currentSlide().steps() || [])) - 1);
	} else {
		this.currentSlide().setCurrentStep(-1);
	};
	return this;
};

SlidesWidget.prototype.stepBackward = function (keyframesOnly){
	if(keyframesOnly === undefined) keyframesOnly = false;
	let curr = this.currentSlide();
	if (curr && !keyframesOnly) {
		if (curr.currentStep() >= 0) {
			curr.setCurrentStep(curr.currentStep() - 1);
			return this;
		};
	};
	
	// jump to previous and go to the last step of previous
	if (this.currentIndex() > 0) {
		this.setCurrentIndex((this.currentIndex() || this.items().length) - 1);
	};
	
	this.currentSlide().setCurrentStep(len$((this.currentSlide().steps() || [])) - 1);
	return this;
};

SlidesWidget.prototype.currentSlideId = function (){
	return this.items() ? this.items()[this.currentIndex()] : null;
};

SlidesWidget.prototype.currentSlide = function (){
	return this.slides()[this.currentIndex()];
};

SlidesWidget.prototype.nextSlide = function (){
	return this.slides()[this.currentIndex() + 1];
};

SlidesWidget.prototype.prevSlide = function (){
	return this.slides()[this.currentIndex() - 1];
};

SlidesWidget.prototype.slides = function (){
	var self = this, items_;
	return self.items() ? (((items_ = self.items()).SLIDES || (items_.SLIDES = self.items().map(function(id) { return self.space().widgets().get(id); })))) : [];
};

SlidesWidget.prototype.importFromGoogleSlides = async function (url){
	try {
		var res = await this.api().rpc('importSlidesFromGoogle',[url]);
		// var res = await fetchFromGoogleSlides(url)
		console.log(res);
		
		var existing = {};
		for (let i = 0, items = iter$(this.space().widgets()), len = items.length, widget; i < len; i++) {
			widget = items[i];
			if (widget instanceof SlideWidget) {
				existing[widget.name()] = widget;
			};
		};
		
		var ids = [];
		// var uploads = []
		// for slide,i in res:slides
		// 	uploads.push(space.api.uploadBlob(slide:body, name: slide:name))
		// really? could do quick local hash check
		// var blobs = await Promise.all(uploads)
		
		// go through importing
		for (let i = 0, items = iter$(res.slides), len = items.length, slide; i < len; i++) {
			slide = items[i];
			let orig = existing[slide.name];
			// let blob = blobs[i]
			
			if (orig) {
				orig.setTitle(slide.title);
				orig.setWidth(slide.width);
				orig.setHeight(slide.height);
				orig.setBlobId(slide.blobId);
				orig.setSteps(slide.steps);
				orig.setBody(null);
			};
			
			let widget = orig || this.space().createWidget({
				type: 'slide',
				name: slide.name,
				title: slide.title,
				width: slide.width,
				height: slide.height,
				blobId: slide.blobId,
				steps: slide.steps
			}).widget();
			
			ids.push(widget.id());
		};
		
		if (String(this.items()) != String(ids)) {
			this.setItems(ids);
		};
		
		this.setWidth(res.width);
		this.setHeight(res.height);
		this.setUrl(res.url);
		this.space().view().uxa().flash(("Imported " + (len$(ids)) + " slides"));
	} catch (e) {
		this.space().view().uxa().flash("Could not import slides");
		console.log("something went wrong during import",e);
	};
	return this;
};
