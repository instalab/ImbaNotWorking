function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba');
// externs;

var Widget = require('./widget').Widget;
var PaneWidget = require('./PaneWidget').PaneWidget;

var protocol$ = require('../protocol'), WIDGET = protocol$.WIDGET, SCON = protocol$.SCON, ACTION = protocol$.ACTION, FS = protocol$.FS, MSG = protocol$.MSG, LCRange = protocol$.LCRange;

var List = require('../util/List').List;
var TextModel = require('../util/TextModel').TextModel;

var editor;
if (false) {};
var monacoBridge = editor;
var strutil = require('../../util/strings');

var Dimensions = require('../core/Dimensions').Dimensions;

var tracking = require('../../scrimba/tracking');

// wrapper around monaco editor and model
function FileModel(file){
	this._file = file;
	this._batch = [];
	this._batchState = {};
	this._changes = [];
	this._raw = new TextModel(this._file.initialBody() || "");
	this._versions = {selections: -1};
	this._selections = [];
	this._agentSelections = [];
	this.model();
	this;
};

FileModel.prototype.file = function(v){ return this._file; }
FileModel.prototype.setFile = function(v){ this._file = v; return this; };
FileModel.prototype.model = function(v){ return this._model; }
FileModel.prototype.setModel = function(v){ this._model = v; return this; };
FileModel.prototype.raw = function(v){ return this._raw; }
FileModel.prototype.setRaw = function(v){ this._raw = v; return this; };

FileModel.prototype.monacoModel = function (){
	return this._model;
};

FileModel.prototype.widget = function (){
	return this._file;
};

FileModel.prototype.changed = function (key){
	let v = (this.widget().options().version(key) + this.space().version(key));
	if (this._versions[key] != v) {
		this._versions[key] = v;
		return true;
	};
	return false;
};

FileModel.prototype.id = function (){
	return this.file().__uid();
};

FileModel.prototype.space = function (){
	return this.file().space();
};

FileModel.prototype.body = function (){
	return this._raw.getValue();
};

FileModel.prototype.logLine = function (nr){
	var ret;
	var raw = this._raw._lines[nr];
	var monaco = this._model._lines[nr];
	return ret = [raw,monaco._text,raw.length,monaco._text.length];
};

FileModel.prototype.applyEdits = function (edit,silent){
	if(silent === undefined) silent = false;
	if (!edit.MONACO) {
		let res = [];
		for (let i = 0, items = iter$(edit), len = items.length, item; i < len; i++) {
			item = items[i];
			res.push({range: editor.arrayToRange(item[0]),text: item[1]});
		};
		edit.MONACO = res;
	};
	return this._applyEditsRaw.call(this._model,edit.MONACO);
};

FileModel.prototype.alterRange = function (sel,type){
	sel = monacoBridge.opToSelections(sel);
	let config = SE._getCursorConfiguration();
	let del = monaco.DeleteOperations;
	let word = monaco.WordOperations;
	let res;
	
	this.flushChanges();
	
	if (del[type]) {
		console.log("found op");
		
		res = del[type](null,config,this.monacoModel(),sel);
		console.log("result is",res);
		return res[1].map(function(item) {
			return monacoBridge.rangeToArray(item._range);
		});
	} else if (word[type]) {
		console.log("found word op",type,sel);
		let sep = new (monaco.WordCharacterClassifier)(config.wordSeparators);
		let res1 = [];
		for (let i = 0, items = iter$(sel), len = items.length; i < len; i++) {
			let r = word[type](sep,this.monacoModel(),items[i],true,0);
			res1.push(monacoBridge.rangeToArray(r));
		};
		res = res1;
		console.log("word op altered!!",res);
		return res;
	};
};

FileModel.prototype.isSyncing = function (){
	return this._syncing || this.space().isSyncing();
};

FileModel.prototype.model = function (){
	if (false) {};
	return this._model;
};

FileModel.prototype.setupMonaco = function (){
	var self = this;
	if (!false || self._model || self._initing || !window.monaco) { return };
	
	self._initing = true;
	
	self._uri = monaco.Uri.parse(self.file().uri());
	// console.warn "setup file",file,file.uri,body,@queue
	self._changes = [];
	
	let existing = monaco.editor.getModel(self._uri);
	
	if (existing) {
		// console.log "model already exists!!!",existing
		existing.FILE_MODEL.dispose();
	};
	
	self._model = monaco.editor.createModel(self._raw.getValue(),null,self._uri); // 'text'
	self._initing = false;
	self._model.FILE_MODEL = self;
	
	var opts = {
		trimAutoWhitespace: false
	};
	
	if (self._file.useTabs()) {
		opts.insertSpaces = false;
		opts.tabSize = 4;
	};
	
	self._model.updateOptions(opts);
	
	
	var applyEditsRaw = self._applyEditsRaw = self._model.applyEdits;
	
	self._model.applyEdits = function(operations) {
		var rev = applyEditsRaw.call(self._model,operations);
		if (!(self.isSyncing())) {
			// console.log "model.applyEdits",operations
			// actual edits performed live
			// if there are other agents here we want to 
			
			var editor = self._file._editor;
			var sel = editor && editor.getSelections();
			var agentSel = self.file().selections();
			// console.log "selection before applyEdits",sel,agentSel
			
			if (!agentSel) {
				if (self.file().space().isSpectating()) {
					self.file().setSelections(sel);
				} else {
					// console.log "first push selection!!",sel
					self.pushEvent(ACTION.LCSELECTION,[self.id()].concat(sel),{sel: undefined,source: "init"});
					self.flushEvents();
				};
			};
			
			self._batchState.significant = true;
			self._batchState.preapplied = true;
			self._batchState.reverseOperations = rev;
			
			var scrimbaOps = [];
			var count = len$(operations);
			// workaround for our version of monaco where backspace-deleting
			// an emoji would return an incorrect range
			for (let i = 0, items = iter$(operations), len = items.length, op; i < len; i++) {
				op = items[i];
				if (rev[i] && strutil.containsEmoji(rev[i].text)) {
					op.range.startColumn = rev[i].range.startColumn;
				};
				
				let range = monacoBridge.rangeToArray(op.range);
				
				if (op.text) {
					scrimbaOps.push([range,op.text]);
				} else {
					scrimbaOps.push([range]);
				};
				
				// single inserts from collaped range
				if (count == 1) {
					if (op.text && range.length == 2) {
						// console.log "LCINSERT",range,op:text
						self.pushEvent(ACTION.LCINSERT,[self.id(),range[0],range[1],op.text],{sel: sel});
						return rev;
					} else if (!op.text) {
						// range[0],range[1],range[2],range[3]
						self.pushEvent(ACTION.LCDELETE,[self.id()].concat(range),{sel: sel});
						return rev;
					};
				};
			};
			
			// console.log "LCEDIT",id,scrimbaOps
			self.pushEvent(ACTION.LCEDIT,[self.id(),scrimbaOps],{sel: sel});
		};
		return rev;
	};
	
	return self;
};

FileModel.prototype.onDidChangeCursorSelection = function (event){
	var ary, items;
	if (!(this.isSyncing())) {
		var preSel = this.file().selections();
		var sel = editor.selectionToArray(event.selection);
		var msel = [sel];
		
		for (let i = 0, items = iter$(event.secondarySelections), len = items.length; i < len; i++) {
			sel = null;
			msel.push(editor.selectionToArray(items[i]));
		};
		
		let last = this._batch[len$(this._batch) - 1] || {};
		
		if (last.TYPE == ACTION.LCINSERT) {
			// console.log "cursor selection after LCINSERT?"
			var ary = iter$(last);let tid = ary[0],tline = ary[1],tcol = ary[2],tins = ary[3];
			if (tins.indexOf('\n') >= 0 || !sel || sel[0] != tline || (sel[1] - (tcol + tins.length)) != 0) {
				last.push(sel || msel);
			};
		} else if (last.TYPE == ACTION.LCDELETE) {
			last.META.source = event.source;
			last.META.reason = event.reason;
			
			var items = iter$(last);let tid = items[0],l0 = items[1],c0 = items[2];
			if (!sel || sel[0] != l0 || sel[1] != c0 || sel.length > 2) {
				last[5] = sel || msel;
			};
		} else if (last.TYPE == ACTION.LCEDIT) {
			last.push(sel || msel);
		} else if (this.file().space().isSpectating()) {
			// just set selections directly
			this.file().setSelections(sel || msel);
		} else {
			this.pushEvent(ACTION.LCSELECTION,[this.id()].concat(sel || msel),{sel: this.file().selections(),source: event.source});
		};
		// cursorSelection will always be the last event we want in a batch
		// so we should force flush the batch immediately
		this.flushEvents();
	};
	return this;
};

FileModel.prototype.pushEvent = function (type,params,meta){
	var self = this;
	params.TYPE = type;
	params.META = meta || {};
	self._batch.push(params);
	setTimeout(function() { return self.flushEvents(); },0);
	return self;
};

FileModel.prototype.flushEvents = function (){
	if (len$(this._batch)) {
		var items = this._batch.slice(0);
		var state = this._batchState;
		this._batch = [];
		this._batchState = {};
		this._flushing = true;
		
		let carets = [];
		
		let edits = items.some(function(item) { return Imba.indexOf(item.TYPE,[ACTION.LCINSERT,ACTION.LCDELETE,ACTION.LCEDIT]) >= 0; });
		
		// if edits
		// 	# calculate the new selections
		if (edits) {
			this.file().flag(FS.UNSAVED);
			if (false) {};
			
			// if spectator has local selection - possibly reset it?
		};
		
		if (len$(items) == 1) {
			this.file().push_(items[0].TYPE,items[0],state);
		} else {
			let batched;
			let res = [];
			for (let i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
				item = ary[i];
				res.push([item.TYPE,item]);
			};
			batched = res;
			this.file().batch_(batched,state);
		};
		
		this._flushing = false;
		this.redecorate();
	};
	return this;
};

FileModel.prototype.apply = function (edits,isLocal){
	// set ranges
	if(isLocal === undefined) isLocal = false;
	let markers = {};
	let agentMarkers = [];
	for (let i = 0, items = iter$(this.space().agents()), len = items.length, agent; i < len; i++) {
		agent = items[i];
		let sel = this.file().selections(agent);
		if (sel) {
			agentMarkers.push([agent.id(),sel]);
			if (sel) { markers[agent.id()] = sel };
		};
	};
	
	this._raw.setMarkers(markers);
	// console.log "before apply",JSON.stringify(agentMarkers)
	var res = this._raw.apply(edits);
	// console.log "apply",edits,@raw.markers,JSON.stringify(@raw.markers)
	
	let selSync = [];
	// now update the markers
	for (let i = 0, len = agentMarkers.length, sels; i < len; i++) {
		sels = agentMarkers[i];
		let mark = markers[sels[0]];
		if (!LCRange.equals(sels[1],mark)) {
			selSync.push(sels[0],mark);
		};
	};
	
	// console.log "selSync",JSON.stringify(selSync)
	if (!isLocal || !isLocal.preapplied) {
		this._changes.push(edits);
	};
	
	this.file().push_(ACTION.LCSELECTIONSYNC,[this.file().id(),selSync],{local: true});
	return this;
};

FileModel.prototype.undo = function (edits){
	this._raw.apply(edits.UNDO,-1);
	// console.log "undo",edits
	for (let i = 0, items = iter$(edits.UNDO), len = items.length; i < len; i++) {
		this._changes.push([items[i]]);
	};
	return this;
};

FileModel.prototype.discard = function (batch){
	if (batch.reverseOperations && !batch.reversed) {
		batch.reversed = true;
		this._syncing = true;
		this._applyEditsRaw.call(this._model,batch.reverseOperations);
		this._syncing = false;
	};
	return;
};

FileModel.prototype.flushChanges = function (){
	var self = this;
	if (!self._model) { return };
	
	var editor = self._file._editor;
	var ops = self._changes;
	var now = Date.now();
	
	if (len$(ops) == 0) {
		self.redecorate();
		return self;
	};
	
	self._changes = [];
	self._syncing = true;
	
	// just update the body directly
	if (len$(ops) > 3) {
		console.log("batching changes");
		self._changeDiff = {
			model: self._model.getValue(),
			raw: self._raw.getValue()
		};
		// @lastOps = ops
		var diff = self._raw.getDiff(self._model._lines);
		
		self._changeDiff.diff = diff;
		
		if (diff && diff[0][0] == 1) {
			self._model.setValue(self._raw.getValue());
		} else if (diff) {
			self.applyEdits([diff]);
			// @applyEditsRaw.call(@model,[patch])
		};
		// console.log "applied patch",diff
	} else if (editor) {
		editor.batchEdits(function() {
			let res = [];
			for (let i = 0, items = iter$(ops), len = items.length; i < len; i++) {
				res.push(self.applyEdits(items[i]));
			};
			return res;
		});
	} else {
		// how do we make sure that local selection is not updated?
		for (let i = 0, items = iter$(ops), len = items.length; i < len; i++) {
			self.applyEdits(items[i]);
		};
	};
	
	// var selAfter = @selections.map do @model.getDecorationRange($1)
	// console.log JSON.stringify(selBefore),JSON.stringify(selAfter)
	// console.log 'flushChanges',ops.len,Date.now - now
	self.redecorate();
	self._syncing = false;
	self._file.async('modified');
	return self;
};

FileModel.prototype.enable = function (){
	this._enabled = true;
	return this;
};

FileModel.prototype.disable = function (){
	this._enabled = false;
	return this;
};

FileModel.prototype.dispose = function (){
	this._model && this._model.dispose  &&  this._model.dispose();
	this._model = null;
	return this;
};

// ensure that decorations are in sync with monaco model
FileModel.prototype.redecorate = function (){
	let syncing = this._syncing;
	this._syncing = true;
	this.syncSelections();
	this._syncing = syncing;
	return this;
};

FileModel.prototype.syncSelections = function (){
	if (len$(this._batch) || this._flushing) { return };
	
	let editor = this._file._editor;
	// or if agents have changed?!
	if (this.changed('selections')) {
		// console.log "syncSelections"
		var decorations = [];
		this._agentSelections = {};
		for (let i = 0, items = iter$(this.space().agents()), len = items.length, agent; i < len; i++) {
			agent = items[i];
			if (!(agent.isActive() && !agent.offline())) { continue; };
			let sel = this.file().selections(agent);
			
			if (sel && agent == this.space().me() && editor) {
				if (!SCON.compare(editor.getSelections(),sel)) {
					editor.setSelections(sel);
				};
			};
			
			if (sel == undefined || (agent == this.space().me())) { continue; };
			
			let cls = ("sel agent-" + (agent.color()));
			if (!this.file().agentIsFocused(agent)) { cls += " inactive" };
			if (agent == this.space().me()) { cls += " local" };
			
			let dec = monacoBridge.arrayToSelDecoration(sel,{name: cls});
			
			// what about when it is no more?
			// need to take multi-selection into account(!)
			this._agentSelections[agent.id()] = {
				agent: agent,
				index: (decorations.length) * 2,
				range: dec[0].range
			};
			
			decorations.push(dec);
		};
		
		decorations = decorations.reduce(function(a,b) { return a.concat(b); },[]);
		// only when we KNOW that the selections have changed
		this._selections = this._model.deltaDecorations(this._selections,decorations);
	};
	
	return this;
};

function FileWidget(){ return PaneWidget.apply(this,arguments) };

Imba.subclass(FileWidget,PaneWidget);
exports.FileWidget = FileWidget; // export class 
FileWidget.register('file');

// attr name
FileWidget.prototype.body = function(v){ return this.getAttribute('body'); }
FileWidget.prototype.setBody = function(v){ this.setAttribute('body',v); return this; };
FileWidget.prototype.lang = function(v){ return this.getAttribute('lang'); }
FileWidget.prototype.setLang = function(v){ this.setAttribute('lang',v); return this; };
FileWidget.prototype.blobId = function(v){ return this.getAttribute('blobId'); }
FileWidget.prototype.setBlobId = function(v){ this.setAttribute('blobId',v); return this; };

FileWidget.prototype.buffer = function(v){ return this._buffer; }
FileWidget.prototype.setBuffer = function(v){ this._buffer = v; return this; };
FileWidget.prototype.diff = function(v){ return this._diff; }
FileWidget.prototype.setDiff = function(v){ this._diff = v; return this; };
FileWidget.prototype.stream = function(v){ return this._stream; }
FileWidget.prototype.setStream = function(v){ this._stream = v; return this; };
FileWidget.prototype.editor = function(v){ return this._editor; }
FileWidget.prototype.setEditor = function(v){ this._editor = v; return this; };

FileWidget.prototype.scrollState = function(v){ return this._scrollState; }
FileWidget.prototype.setScrollState = function(v){ this._scrollState = v; return this; };
FileWidget.prototype.localScroll = function(v){ return this._localScroll; }
FileWidget.prototype.setLocalScroll = function(v){ this._localScroll = v; return this; };

FileWidget.option('name',{mark: ['fs']});
FileWidget.option('parent',{type: 'widget',mark: ['fs']});
FileWidget.option('flags',{'default': 0,mark: ['fs']});
FileWidget.option('oid'); // git object id

// only for text-files. Should probably be stored on the editor-widget instead
// or on a subwidget of file representing the actual ViewModel
FileWidget.option('scrollTop',{subjective: true,inheritable: true,mark: ['pointer']});
FileWidget.option('scrollLeft',{subjective: true,inheritable: true,mark: ['pointer']});
FileWidget.option('selections',{subjective: true});

FileWidget.prototype.setup = function (){
	this._localScroll = false;
	this._stream = [];
	this._edits = 0;
	this._initialBody = this.data().body;
	this._decorations = {};
	// @decorations = List.new(self)
	return this;
};

FileWidget.prototype.posToScreen = function (agent,x,y,sl,cl){
	if (this._editor) {
		let layout = this.agentLayout();
		let pars = {
			top: layout.top(),
			left: layout.left(),
			contentTop: 0,
			contentLeft: 0,
			scrollTop: layout.scrollTop(),
			scrollLeft: layout.scrollLeft(),
			fontSize: layout.scaleX(),
			lineHeight: layout.scaleY()
		};
		
		return this.space().primaryEditor().agentToLocalPoint(agent,x,y,pars);
	};
	
	return null;
};

FileWidget.prototype.model = function (){
	return this._model || (this._model = new FileModel(this));
};

FileWidget.prototype.localLayout = function (){
	return this._editor ? this.clientLayout() : null;
};

FileWidget.prototype.uri = function (){
	return ("" + (this.space().namespace()) + this.path());
};

FileWidget.prototype.ext = function (){
	let idx = this.name().lastIndexOf('.');
	return (idx > 0) ? this.name().substr(idx + 1) : '';
};

FileWidget.prototype.lang = function (){
	return this.data().lang || this.ext() || 'text';
};

FileWidget.prototype.title = function (){
	return this.name();
};

FileWidget.prototype.commitAdd = function (){
	FileWidget.prototype.__super__.commitAdd.apply(this,arguments);
	// space.files.add(self,id)
	this._initialBody = this.data().body; // really?
	return this;
};

FileWidget.prototype.flag = function (flag){
	this.setFlags(this.flags() | flag);
	return this;
};

FileWidget.prototype.unflag = function (flag){
	this.setFlags(this.flags() & (~flag));
	return this;
};

FileWidget.prototype.hasFlag = function (flag){
	return this.flags() & flag;
};

FileWidget.prototype.isUnsaved = function (){
	return this.hasFlag(FS.UNSAVED);
};

FileWidget.prototype.isLazy = function (){
	return this.hasFlag(FS.LAZY);
};

FileWidget.prototype.mount_ = function (){
	FileWidget.prototype.__super__.mount_.apply(this,arguments);
	this.space().files().add(this,this.id());
	return this.parentDir().entries().add(this);
};

FileWidget.prototype.unmount_ = function (){
	FileWidget.prototype.__super__.unmount_.apply(this,arguments);
	// what if parentDir no longer exists?
	this.space().files().remove(this,this.id());
	return this.parentDir().entries().remove(this);
};

FileWidget.prototype.parentDir = function (){
	return this.parent() || this.space().fs();
};

FileWidget.prototype.replaceBody = function (newBody,hard){
	if(hard === undefined) hard = false;
	var prev = this.body();
	var diff = new TextModel(newBody).getDiff(this.model().body());
	
	if (hard) {
		var range = this.model()._raw.expandedRange([1,1],prev);
		diff = [range,newBody];
	};
	
	this.log("replacBody",diff);
	if (diff) {
		this.push_(ACTION.LCEDIT,[this.id(),[diff]]);
	};
	return this;
};

FileWidget.prototype.syncEntry = function (entry){
	this.replaceBody(entry.body);
	if (this.isLazy() && !(entry.flags & FS.LAZY)) {
		// set fully body(!)
		this.unflag(FS.LAZY);
	};
	return this;
};


FileWidget.prototype.deltaDecorations = function (ns,decorations){
	var range_;
	if (true) { return };
	// what if monaco is not already loaded?
	for (let i = 0, items = iter$(decorations), len = items.length, item; i < len; i++) {
		item = items[i];
		if ((typeof (range_ = item.range)=='string'||range_ instanceof String)) {
			item.range = editor.stringToRange(item.range);
		} else if (item.range instanceof Array) {
			item.range = editor.arrayToRange(item.range);
		};
	};
	
	this.log("deltaDecorations",decorations);
	
	return this._decorations[ns] = this.model().model().deltaDecorations(this._decorations[ns] || [],decorations);
	// @decorations = model.model.deltaDecorations(@decorations,decorations)
};

FileWidget.prototype.initialBody = function (){
	return (this._initialBody == null) ? (this._initialBody = this.data().body) : this._initialBody;
};

FileWidget.prototype.currentBody = function (){
	return this._model ? this.model().body() : this.data().body;
};

FileWidget.prototype.fetch = function (){
	if (!(this.isLazy()) || this._fetcher || !this.space().trunk().machine() || this._data.size > 500000) { return };
	this._fetcher = true;
	console.log("fetch file body!!");
	let machine = this.space().trunk().machine();
	machine.fetch(this.toEntry(),this);
	
	return this;
};

FileWidget.prototype.buffer = function (){
	return this.data().buffer || this.data().body;
};

FileWidget.prototype.toString = function (){
	return this.currentBody();
};

FileWidget.prototype.toEntry = function (){
	return {
		type: 'file',
		name: this.name(),
		path: this.path(),
		flags: this.flags(),
		body: this._model ? this.currentBody() : null
	};
};

FileWidget.prototype.persist_ = function (){
	this._data.body = this.currentBody();
	return this;
};

FileWidget.prototype.modified = function (){
	this.emit('modified',this);
	return this;
};

FileWidget.prototype.nodeForLayout = function (){
	return this.space().view().editor();
};

FileWidget.prototype.flushChanges = function (){
	return this._model && this._model.flushChanges  &&  this._model.flushChanges();
};

FileWidget.prototype.pointer = function (){
	// TODO deprecated - remove?
	return this._editor && this._editor.pointer();
};

FileWidget.prototype.node = function (){
	return this._editor;
};

FileWidget.prototype.agentIsShowing = function (agent){
	return this.space().primaryEditor().file(agent) == this;
	// space.agent.options.get('file',no) == self
};

FileWidget.prototype.agentIsFocused = function (agent){
	return agent.focus() == this.space().primaryEditor() && this.agentIsShowing(agent);
};

FileWidget.prototype.clientIsShowing = function (){
	return this.space().primaryEditor().file() == this;
};

FileWidget.prototype.isBinary = function (){
	return !(!(this.blobId()));
};

FileWidget.prototype.useTabs = function (){
	return this.lang() == 'imba';
};

FileWidget.prototype.quicksave = function (){
	// log 'saving file',path,"are we editing?"
	var cli;
	if (cli = this.space().branch().machine()) {
		cli.pushEntry(this.toEntry());
	} else if (this.space().me().isActive() && !this.space().me().isHost()) {
		// console.log "ask host to save"
		// TODO nicer specific interface for this -- just using space.me?
		return this.space().host().send([MSG.AGENTSAVE,this.space().branch().id(),this.id()]);
	};
	
	this.unflag(FS.UNSAVED);
	// space.emit('quicksave',self)
	return this;
};

FileWidget.prototype.dispose = function (){
	this._editor = null;
	return this._model && this._model.dispose  &&  this._model.dispose();
};

FileWidget.prototype.rename = function (name){
	// should check with filesystem(!)
	if (!name || name == this.name() || this.parentDir().entries().any(function(f) { return f.name() == name; })) {
		return this;
	};
	
	return this.push_(ACTION.FS_RENAME,[this.id(),name]);
};

FileWidget.prototype.moveTo = function (target){
	// should be separate action, or just change parent?
	this.log("moveTo",target);
	if (this.parent() != target) {
		this.push_(ACTION.FS_MOVE,[this.id(),target.id()]);
		return this;
	};
};

FileWidget.prototype.path = function (){
	return ("" + (this.parentDir().path()) + "/" + this.name());
};

FileWidget.prototype.rm = function (){
	// should ask to confirm
	// check if we are currently in focus?
	if (this.space().agent().file() == this) {
		// let idx = space.files.indexOf(self)
		// let rel = space.files.at(idx - 1) or space.files.at(idx + 1)
		// TODO multiple agents - how will it work?
		// should happen automatically from FS_REMOVE event?
		this.space().agent().setFocus(null);
		this.space().agent().setFile(null);
	};
	
	return this.push_(ACTION.FS_REMOVE,[this.id()]);
};


