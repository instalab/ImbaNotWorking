var Imba = require('imba');
var Resource = require('../store/Resource').Resource;

function Topic(){ return Resource.apply(this,arguments) };

Imba.subclass(Topic,Resource);
exports.Topic = Topic; // export class 
Topic.prototype.flag = function (){
	return ("topic-" + this.id.replace(/[^\w\-]/g,''));
};

Topic.prototype.toString = function (){
	return this.id.slice(1);
};

Topic.prototype.url = function (){
	return ("/t/" + this.id.slice(1));
};

Topic.prototype.title = function (){
	return this.name || this.id;
};

Topic.prototype.type = function (){
	return 'topic';
};

Topic.prototype.groups = function (){
	var self = this;
	return self._cache.questions || (self._cache.questions = self.db().groups().sel({sort: '-created_at'},function(c) { return c.isTagged(self.id); }));
};

Topic.prototype.spaces = function (){
	var self = this;
	return self._cache.spaces || (self._cache.spaces = self.db().spaces().sel({sort: '-created_at'},function(c) { return c.isTagged(self.id); }));
};

Topic.prototype.notes = function (){
	var self = this;
	return self._cache.notes || (self._cache.notes = self.db().notes().sel({sort: '-cretime'},function(c) { return c.isTagged(self.id) && c.nid == null; }));
};

Topic.prototype.entities = function (){
	// filter through all entities -- this should be possible to do when indexing the entities
	// TODO use some sort of smart index
	var self = this;
	return self._cache.entities || (self._cache.entities = self.db().entities().sel(function(e) { return e.topics().indexOf(self) >= 0; }));
};

Topic.prototype.rpc = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return App.api().rpc(name,[this.id].concat(params));
};

Topic.prototype.follow = function (){
	return this.rpc('topicFollow');
};

Topic.prototype.unfollow = function (){
	return this.rpc('topicUnfollow');
};
