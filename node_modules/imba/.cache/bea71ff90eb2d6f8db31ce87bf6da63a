function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _2 = Imba.createTagCache, _1 = Imba.createElement;

var protocol$ = require('../protocol'), FILE = protocol$.FILE, SCON = protocol$.SCON, DIRTY = protocol$.DIRTY, LAYOUTMASK = protocol$.LAYOUTMASK;

var Delay = require('../../util/Delay').Delay;

var Dimensions = require('../core/Dimensions').Dimensions;
var MonacoView = require('./MonacoView').MonacoView;

// externs;

var tracking = require('../tracking');

if (false) {};

var imbaActions = require('../monaco/imbaActions');
var BASE_TOP_PADDING = 10;

var CodePreview = Imba.defineTag('CodePreview', function(tag){
	tag.prototype.file = function(v){ return this._file; }
	tag.prototype.setFile = function(v){ this._file = v; return this; };
	tag.prototype.__value = {watch: 'valueDidSet',name: 'value'};
	tag.prototype.value = function(v){ return this._value; }
	tag.prototype.setValue = function(v){
		var a = this.value();
		if(v != a) { this._value = v; }
		if(v != a) { this.valueDidSet && this.valueDidSet(v,a,this.__value) }
		return this;
	};
	
	tag.prototype.build = function (){
		var $ = ($_ = this.$).$build$ || ($_.$build$ = _2(this));
		return this.$open('build0').setChildren(this._code = this._code||_1('pre',this).flag('code'),2).synced();
	};
	
	tag.prototype.valueDidSet = function (value){
		return this._code.dom().innerText = value;
	};
	
	tag.prototype.render = function (){
		if (!(this.file())) { return };
		this.setValue(this.file().currentBody());
		return this;
	};
	
	tag.prototype.setScrollPosition = function (pos){
		if (pos.scrollLeft != undefined) {
			this.dom().scrollLeft = this._scrollLeft = pos.scrollLeft;
		};
		
		if (pos.scrollTop != undefined) {
			this.dom().scrollTop = this._scrollTop = pos.scrollTop;
		};
		return this;
	};
	
	tag.prototype.getScrollTop = function (){
		return this.dom().scrollTop;
	};
	
	tag.prototype.getScrollLeft = function (){
		return this.dom().scrollLeft;
	};
	
	tag.prototype.getScrollWidth = function (){
		return 0;
	};
	
	tag.prototype.getScrollHeight = function (){
		return 0;
	};
});

var EditorView = Imba.defineTag('EditorView', MonacoView, function(tag){
	
	tag.prototype.layout = function(v){ return this._layout; }
	tag.prototype.setLayout = function(v){ this._layout = v; return this; };
	tag.prototype.__file = {watch: 'fileDidSet',name: 'file'};
	tag.prototype.file = function(v){ return this._file; }
	tag.prototype.setFile = function(v){
		var a = this.file();
		if(v != a) { this._file = v; }
		if(v != a) { this.fileDidSet && this.fileDidSet(v,a,this.__file) }
		return this;
	};
	tag.prototype.__fontSize = {watch: 'fontSizeDidSet',name: 'fontSize'};
	tag.prototype.fontSize = function(v){ return this._fontSize; }
	tag.prototype.setFontSize = function(v){
		var a = this.fontSize();
		if(v != a) { this._fontSize = v; }
		if(v != a) { this.fontSizeDidSet && this.fontSizeDidSet(v,a,this.__fontSize) }
		return this;
	};
	tag.prototype.__scrollState = {watch: 'scrollStateDidSet',name: 'scrollState'};
	tag.prototype.scrollState = function(v){ return this._scrollState; }
	tag.prototype.setScrollState = function(v){
		var a = this.scrollState();
		if(v != a) { this._scrollState = v; }
		if(v != a) { this.scrollStateDidSet && this.scrollStateDidSet(v,a,this.__scrollState) }
		return this;
	};
	tag.prototype.__streamLayout = {watch: 'streamLayoutDidSet',name: 'streamLayout'};
	tag.prototype.streamLayout = function(v){ return this._streamLayout; }
	tag.prototype.setStreamLayout = function(v){
		var a = this.streamLayout();
		if(v != a) { this._streamLayout = v; }
		if(v != a) { this.streamLayoutDidSet && this.streamLayoutDidSet(v,a,this.__streamLayout) }
		return this;
	};
	tag.prototype.__autoScroll = {'default': true,watch: 'autoScrollDidSet',name: 'autoScroll'};
	tag.prototype.autoScroll = function(v){ return this._autoScroll; }
	tag.prototype.setAutoScroll = function(v){
		var a = this.autoScroll();
		if(v != a) { this._autoScroll = v; }
		if(v != a) { this.autoScrollDidSet && this.autoScrollDidSet(v,a,this.__autoScroll) }
		return this;
	}
	tag.prototype._autoScroll = true;
	tag.prototype.__readOnly = {watch: 'readOnlyDidSet',name: 'readOnly'};
	tag.prototype.readOnly = function(v){ return this._readOnly; }
	tag.prototype.setReadOnly = function(v){
		var a = this.readOnly();
		if(v != a) { this._readOnly = v; }
		if(v != a) { this.readOnlyDidSet && this.readOnlyDidSet(v,a,this.__readOnly) }
		return this;
	};
	
	tag.prototype.space = function (){
		return this.data().space();
	};
	
	tag.prototype.build = function (){
		this._syncing = false;
		this._dirty = {};
		this._bridge = this._preview = (_1(CodePreview)).end();
		this._layoutInfo = {};
		this._layouter = new Delay(this,'relayout');
		this._scrollTarget = {};
		
		this.dom().appendChild(this._preview.dom());
		this.dom().appendChild(((_1('div').flag('left-shadow'))).dom());
		this.dom().appendChild(((_1('div').flag('top-shadow'))).dom());
		return this;
	};
	
	tag.prototype.setup = function (){
		var self = this;
		self.data().setView(self);
		self.setSref(self.data().id());
		self.layoutCodePreview();
		self.space().once('dispose',function() { return self.dispose(); });
		self._v = self.data().options()._v;
		
		self.space().on('reflow',function(dirty) {
			// log "space.reflow",dirty
			self._top = self._left = self._width = self._height = 0;
			return self.relayout(true);
		});
		
		self.space().on('watch',function() {
			self.log('Space:watch');
			return (self.setAutoScroll(true),true);
		});
		
		self.space().on('playing',function() {
			self.log("Space:playing",self.autoScroll());
			self.setAutoScroll(true);
			return self.space().agent().options().reset('file');
		});
		
		self.space().on('refocus',function(target) {
			if (target == self.data()) {
				if (!(self._editor && self._editor.domElement.contains(document.activeElement))) { return self.focus() };
			};
		});
		return self;
	};
	
	tag.prototype.layoutMask = function (){
		return LAYOUTMASK.STICKY;
	};
	
	tag.prototype.isScrollable = function (){
		return this.space().view().dom().contains(document.activeElement);
	};
	
	tag.prototype.posToScreen = function (agent,x,y){
		return this.data().agentToLocalPoint(agent,x,y);
	};
	
	tag.prototype.batch = function (blk){
		var sync = this._syncing;
		this._syncing = true;
		blk();
		this._syncing = sync;
		return this;
	};
	
	tag.prototype.mount = function (){
		var self = this;
		self._mounted = true;
		self.load();
		self.render();
		setTimeout(function() { return self.relayout(); },20);
		return self;
	};
	
	tag.prototype.unmount = function (){
		return this;
	};
	
	tag.prototype.onfocus = function (e){
		if (e.event().target == this && this._editor) {
			// log 'editor onfocus'
			// log "onfocus",e.event:target
			return this._editor.focus();
		};
	};
	
	tag.prototype.autoScrollDidSet = function (bool){
		if (bool) { return this.unsyncScroll() };
	};
	
	tag.prototype.getDynamicOptions = function (){
		var opts;
		var fontSize = this.space().view().fontSize(); // what about api.fontSize?
		var pub = this.space().model().pub;
		
		return opts = {
			renderWhitespace: this.data().renderWhitespace() ? 'boundary' : 'none',
			renderIndentGuides: this.data().renderIndentGuides(),
			fontSize: (this._fontSize = fontSize),
			lineHeight: this._lineHeight = Math.ceil(this._fontSize * 1.5),
			lineDecorationsWidth: fontSize + 4,
			wordWrapColumn: this.data().wordWrapColumn(),
			wordWrap: (this.data().wordWrap() && (!pub || !pub.noWordWrap)) ? 'wordWrapColumn' : 'off',
			wrappingIndent: this.data().wrappingIndent(),
			suggestFontSize: this._fontSize
		};
	};
	
	// LAYOUT
	tag.prototype.leftPadding = function (){
		var o = this.getDynamicOptions();
		// should get fontSize directly
		return Math.round(o.fontSize * 0.6 * 5) + o.lineDecorationsWidth;
	};
	
	// ef top do @top ||= dom:offsetTop
	// ef left do @left ||= dom:offsetLeft
	// ef width do @layout:width or @width
	// ef height do @layout:height or @height
	tag.prototype.contentTop = function (){
		return this._editor ? this._editor.getTopForLineNumber(1) : BASE_TOP_PADDING;
	};
	tag.prototype.contentLeft = function (){
		return this._layoutInfo.contentLeft || this.leftPadding();
	}; // + 4
	tag.prototype.scrollTop = function (){
		return this._bridge.getScrollTop();
	};
	tag.prototype.scrollLeft = function (){
		return this._bridge.getScrollLeft();
	};
	tag.prototype.lineHeight = function (){
		return Math.ceil(this._fontSize * 1.5);
	};
	
	tag.prototype.setScrollPosition = function (pos){
		let target = this._scrollTarget;
		if (pos.scrollTop != target.scrollTop || pos.scrollLeft != target.scrollLeft) {
			target.scrollTop = pos.scrollTop;
			target.scrollLeft = pos.scrollLeft;
			this._bridge.setScrollPosition(pos);
		};
		return this;
	};
	
	tag.prototype.setSelections = function (sel){
		if (this._editor) {
			this._monacoSel = this.monacoBridge().opToSelections(sel);
			return this._editor.setSelections(this._monacoSel);
		};
	};
	
	tag.prototype.layoutCodePreview = function (){
		return this._preview.css(
			{left: this.contentLeft() + 'px',
			paddingTop: BASE_TOP_PADDING + 'px',
			fontSize: this.fontSize() + 'px',
			lineHeight: this.lineHeight() + 'px'}
		);
	};
	
	tag.prototype.currentCodeAnchor = function (){
		if (!(this._editor && this._file)) {
			return;
		};
		
		var sel = this._editor.getSelection();
		var ev = this.space().cursor().current();
		var uri = ("scrimba://" + (ev.branch().id()) + "@" + (ev.index()) + "." + (ev.offset()));
		var data = {};
		
		if (this.file() && sel) {
			let l0 = sel.startLineNumber;
			let c0 = sel.startColumn;
			let l1 = sel.endLineNumber;
			let c1 = sel.endColumn;
			
			data.l0 = l0;
			
			uri += ("" + (this.file().path()) + "#");
			
			// should be possible to show without a particular selection?
			
			uri += ("L" + l0);
			
			if (c0 == 1 && c1 == 1) {
				if ((l1 - 1) > l0) {
					uri += ("-" + (l1 - 1));
				};
			} else {
				uri += (":" + c0);
				
				// single marker
				if (l0 == l1 && c0 == c1) {
					true;
				} else if (c1 == 1) {
					l1 = l1 - 1;
					// c1 = @editor:model.getLineMaxColumn(l1)
					uri += ("-" + l1);
					if (c0 != 1) {
						uri += (":" + this._editor.model.getLineMaxColumn(l1));
					};
				} else {
					uri += ("-" + l1 + ":" + c1);
				};
			};
		};
		
		data.uri = uri;
		data.text = this._editor.model.getValueInRange(sel);
		
		return data;
	};
	
	tag.prototype.batchEdits = function (blk){
		var self = this;
		if (!self._editor) {
			return self.batch(blk);
		};
		
		self.batch(function() {
			var cursor = self._editor.cursor;
			if (cursor) {
				cursor._isHandling = true;
			};
			blk(); // @editor.blockRendering(blk)
			if (cursor) {
				cursor._isHandling = false;
			};
			return self._editor.render();
		});
		return self;
	};
	
	
	tag.prototype.render = function (){
		var self = this;
		if (!self._mounted) { return };
		
		self.batch(function() {
			self.setFile(self.data().file());
			if (!(self.file())) { return };
			
			if (!self._editor) {
				self._preview.render();
			};
			
			self.syncScroll();
			
			// use space.changed + marks for this
			if (self.data().options()._v != self._v && self._editor) {
				// sure?
				self._v = self.data().options()._v;
				self._editor.updateOptions(self.getDynamicOptions());
			};
			
			// setting model as well!?
			// probably not needed after fixing font-loader
			if (self._editor) {
				self.setReadOnly(!(self.space().me() && self.space().me().canCode()));
				self.file().flushChanges();
				self._editor.render();
			};
			// try to update layout on every render
			// ensures that layout does not end up out of sync
			return self.pushLayout();
		});
		
		return self;
	};
	
	tag.prototype.pushLayout = function (){
		if (!this._editor) { return };
		
		this.data().setLeft(this.left());
		this.data().setTop(this.top());
		this.data().setWidth(this.width());
		this.data().setHeight(this.height());
		this.data().setContentLeft(this.contentLeft());
		this.data().setContentTop(this.contentTop());
		this.data().setFontSize(this.fontSize());
		this.data().setLineHeight(this.lineHeight());
		
		if (this.file()) {
			this.file().setScrollTop(this.scrollTop()); // @editor.getScrollTop
			this.file().setScrollLeft(this.scrollLeft()); // @editor.getScrollLeft
		};
		return this;
	};
	
	/*
		see if file-scroll has changed - sync the view accordingly
		should probably take selection, pointer etc into account to
		intelligently decide what should be visible if the viewport
		is smaller than the agent's.
		*/
	
	tag.prototype.syncScroll = function (){
		if (this.space().isEditing() || !(this.autoScroll())) { return };
		
		// happens inside editor
		// TODO we must base this on the user we do follow
		var follow = this.space().me().follows();
		
		var agentLineHeight = this.data().lineHeight(follow) || 21;
		var agentScrollTop = (this.file().scrollTop(follow) || 0) - (this.data().contentTop(follow) - this.contentTop());
		var agentScrollLeft = this.file().scrollLeft(follow) || 0;
		
		let agentLineCount = this.data().height() / agentLineHeight;
		var sel = (this._monacoSel && this._monacoSel[0]);
		var updates = null;
		
		let target = {};
		let lineCount = this.height() / this.lineHeight();
		let heightRatio = lineCount / agentLineCount;
		let scrollTop = target.scrollTop = Math.round(agentScrollTop * (this.lineHeight() / agentLineHeight));
		let scrollLeft = target.scrollLeft = Math.round(agentScrollLeft * (this.fontSize() / (this.data().fontSize() || 14)));
		
		let pointerX = this._agentPointerX;
		let pointerY = this._agentPointerY;
		
		// only if our viewport is smaller than recorder?
		let prev = this._scrollTarget;
		
		// look at where the selection is
		if (sel && heightRatio < 1) {
			let selTop = this._editor.getTopForLineNumber(sel.startLineNumber);
			let selBottom = this._editor.getTopForLineNumber(sel.endLineNumber);
			let selCaret = this._editor.getTopForLineNumber(sel.positionLineNumber);
			
			// converting relative to caret for now
			// calculating that position for agent
			let agentCaret = (selCaret / this.lineHeight()) * agentLineHeight;
			let agentRelCaret = (agentCaret - agentScrollTop) / this.data().height();
			let relCaret = (selCaret - scrollTop) / this.height();
			let relScrollTop = Math.round(selCaret - this.height() * agentRelCaret);
			// console.log "relCaret",agentRelCaret,relScrollTop
			
			let padBottom = (1 - relCaret) * this.height();
			let padTop = relCaret * this.height();
			
			// if agent has not scrolled and selCaret is still pretty far up - dont 
			// if there is more than x amount of pixels available below or above in the original scroll-position
			// go with that one.
			if (padBottom > this.lineHeight()) {
				true;
			} else {
				target.scrollTop = relScrollTop;
			};
			
			if (pointerY < target.scrollTop) {
				target.scrollTop = Math.round(pointerY - this.lineHeight());
			};
		};
		
		this.setScrollPosition(target);
		
		if (agentScrollTop != this._agentScrollTop) {
			this._agentScrollTop = agentScrollTop;
		};
		
		if (agentScrollLeft != this._agentScrollLeft) {
			this._agentScrollLeft = agentScrollLeft;
		};
		return this;
	};
	
	tag.prototype.unsyncScroll = function (){
		return this._agentScrollLeft = this._agentScrollTop = -1;
	};
	
	tag.prototype.modelDidSet = function (model,prev){
		var $1, $2;
		if (prev) { ($1 = prev) && $1.willDetach  &&  $1.willDetach(this) };
		this._editor.setModel(model ? model.monacoModel() : null);
		if (model) { return ($2 = model) && $2.didAttach  &&  $2.didAttach(this) };
		// @editor.render
	};
	
	tag.prototype.readOnlyDidSet = function (readOnly){
		if (this._editor) {
			return this._editor.updateOptions({readOnly: readOnly});
		};
	};
	
	tag.prototype.fileDidSet = function (file,old){
		var v_, sel;
		this.flag('hasFile',!!file);
		if (old) { (old.setEditor(null),null) };
		this._preview.setFile(file);
		if (file) { (file.setEditor(this),this) };
		this._dirty.file = true;
		
		this.flag('binary-file',file && file.isBinary());
		
		if (!this._editor) { return };
		
		// editor is not supposed to deal with binary file at all
		if (file && file.isBinary()) {
			file = null;
		};
		
		if (this.space().isPlaying() || this.space().isWatching()) { (this.setAutoScroll(true),true) };
		this.unsyncScroll();
		
		var hadFocus = false;
		if (this._bridge.isFocused()) {
			hadFocus = true;
		};
		
		this.setModel((file ? file.model() : null));
		
		if (file) {
			this._editor.FILE = file;
			
			try {
				// Big hack
				this._editor.viewModel.viewLayout._linesLayout.insertWhitespace(0,0,BASE_TOP_PADDING);
			} catch (e) { };
			
			// sync scrollPosition back to previous one
			if (this.space().isEditing()) {
				this.setScrollPosition(
					{scrollTop: file.scrollTop() || 0,
					scrollLeft: file.scrollLeft() || 0}
				);
				// no need to relayout here - is it?
				this.relayout(); // only if editing?
			} else if (!(this.autoScroll()) && file._lastScrollPosition) {
				// log "restore local scrollPosition!"
				this.setScrollPosition(
					{scrollTop: file._lastScrollPosition.scrollTop,
					scrollLeft: file._lastScrollPosition.scrollLeft}
				);
			};
			
			if (sel = file.selections(this.space().me())) {
				// console.log "restore selections",sel
				this.setSelections(sel); // local user?
			};
		};
		
		if (hadFocus) {
			return this._editor.focus();
		};
	};
	
	tag.prototype.focusWidgetForNode = function (){
		return this.data();
	};
	
	tag.prototype.oncopy = function (e){
		// did copy
		var sel = this.monacoBridge().selectionToArray(this._editor.getSelection());
		this.api().sendTracking(tracking.TYPES.COPY,[this.space().timeline().currentOffset(),this.file().id(),sel]);
		var data = e.event().clipboardData;
		var anchor = this.currentCodeAnchor();
		var json = Object.assign({
			body: anchor.text.replace(/\n$/,''), // body should instead be just code
			filename: this.file().path(),
			firstLine: anchor.l0,
			language: this.file().lang(),
			type: 'code',
			uri: anchor.uri
		},{});
		
		// data.setData("text/plain","```{file.lang}\n\{anchor:text}\n```")
		data.setData("scrimba/block",JSON.stringify(json));
		// console.log "oncopy",json
		return;
	};
	
	tag.prototype.oncut = function (e){
		return this.oncopy(e);
	};
	
	tag.prototype.loaded = function (){
		return this;
	};
	
	tag.prototype.onDidChangeCursorSelection = function (e){
		if (this.file() && !this.space().isSyncing() && !this._syncing) {
			// console.log 'cursorChange',e
			this.file().model().onDidChangeCursorSelection(e);
			return Imba.commit(e);
		};
	};
	
	tag.prototype.onDidScrollChange = function (e){
		// console.log "onDidScrollChange",e
		var v_;
		if (!(this._file && (e.scrollTopChanged || e.scrollLeftChanged))) { return };
		
		// keep the last scrollObject on file
		this.file()._lastScrollPosition = e;
		// console.log 'scrollChange',e,$0
		// space.touch(:locals) # should be touch scroll
		// no need to register anything if we are currently syncing
		if (this._syncing || this.space().cursor().syncing()) {
			return;
		};
		
		this.setAutoScroll(false);
		this.file().setScrollTop(e.scrollTop);
		this.file().setScrollLeft(e.scrollLeft);
		return (this.data().setContentTop(v_ = this.contentTop()),v_);
		
		
		// if scrolling is caused by user we want to
		// update the scrollLeft and scrollTop attributes
		// if space.isEditing
		// 	# sync scroll
		// 	file.scrollTop = e:scrollTop
		// 	file.scrollLeft = e:scrollLeft
	};
	
	/*
		Method for loading monaco
		*/
	
	tag.prototype.load = async function (){
		var self = this;
		if (self._editor || self._loading) {
			return self;
		};
		
		self._loading = true;
		
		await self.monacoBridge().load();
		
		var opts = SCON.clone(window.MonacoEnvironment.defaults);
		
		for (let o = self.getDynamicOptions(), v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
			k = keys[i];v = o[k];opts[k] = v;
		};
		
		// TODO should happen in editor.imba
		let ts = monaco.languages.typescript.typescriptDefaults;
		ts.setEagerModelSync(true);
		ts.setCompilerOptions({experimentalDecorators: true});
		
		self._editor = monaco.editor.create(self.dom(),opts,{logService: console});
		self.monacoBridge().patchEditor(self._editor);
		
		// delegate cursor-change to FileModel
		// now this should only happen for live user
		self.disposables().push(self._editor.onDidChangeCursorSelection(self.onDidChangeCursorSelection.bind(self)));
		self.disposables().push(self._editor.onDidScrollChange(self.onDidScrollChange.bind(self)));
		self.disposables().push(self._editor.onDidLayoutChange(self.onDidLayoutChange.bind(self)));
		self.disposables().push(self._editor.onDidFocusEditor(self.onDidFocusEditor.bind(self)));
		self.disposables().push(self._editor.onDidBlurEditor(self.onDidBlurEditor.bind(self)));
		
		self._bridge = self._editor;
		self._layoutInfo = self._editor.getLayoutInfo();
		
		if (!self._file) {
			self._editor.setModel(null);
		};
		
		// Doing this to make sure monaco has info about all the files in project
		// Does not happen for files created after editor is created
		for (let i = 0, items = iter$(self.space().files()), len = items.length, file; i < len; i++) {
			// Preload models
			file = items[i];
			if (file.initialBody() == null) { continue; };
			file.model().model();
		};
		
		// notify others that monaco has loaded
		self.space().emit('monaco:loaded');
		
		self.batch(function() {
			self._agentScrollTop = self._agentScrollLeft = -1;
			self._scrollTarget = {};
			if (self._file) { return self.fileDidSet(self._file) };
		});
		
		self.flag('loaded');
		self.render();
		
		self._dom.addEventListener('wheel',function(e) {
			// console.log 'window-wheel',isScrollable
			if (!(self.isScrollable())) {
				return e.stopPropagation();
			} else {
				return e.preventDefault();
			};
		},true);
		
		// @editor:domElement.addEventListener('wheel',&,yes) do |e|
		//	yes
		// bind to editor scroll - need to cleanup?
		// @editor:domElement.addEventListener('mousewheel',&,yes) do |e|
		//	yes
		
		if (window.performance) {
			console.log("editor loaded",window.performance.now());
		};
		
		if (document.activeElement == self.dom()) {
			self._editor.focus();
		};
		return self;
	};
	
	tag.prototype.dispose = function (){
		this.setFile(null);
		this._data.setView(null);
		window.SE = null;
		return tag.prototype.__super__.dispose.apply(this,arguments);
	};
})
exports.EditorView = EditorView;
