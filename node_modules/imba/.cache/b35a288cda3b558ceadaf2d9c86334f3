function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Imba = require('imba'), _1 = Imba.createElement;

var util = require('../util');

var protocol$ = require('./protocol'), ACTION = protocol$.ACTION, CAST = protocol$.CAST, WIDGET = protocol$.WIDGET, SCON = protocol$.SCON, MSG = protocol$.MSG, AGENT = protocol$.AGENT;

var List = require('./util/List').List;
var Branch$ = require('./Branch'), Branch = Branch$.Branch, Trunk = Branch$.Trunk;
var Widget = require('./widgets/index').Widget;
var Widgets = require('./widgets/widgets').Widgets;
var SpaceView = require('./views/SpaceView').SpaceView;
var Action$ = require('./util/Action'), Action = Action$.Action, ActionManager = Action$.ActionManager;
var Client = require('./core/Client').Client;

var AudioManager = require('./util/AudioManager').AudioManager;
var Cursor = require('./core/Cursor').Cursor;
var Dimensions = require('./core/Dimensions').Dimensions;
var Disposer = require('../util/Disposer').Disposer;

var PointerTracker = require('./util/PointerTracker').PointerTracker;
var MediaRecording = require('./util/MediaRecording').MediaRecording;


var AgentWidget$ = require('./widgets/AgentWidget'), Agent = AgentWidget$.Agent, Spectator = AgentWidget$.Spectator;
var FileSystemWidget = require('./widgets/DirWidget').FileSystemWidget;
var SlidesWidget = require('./widgets/SlidesWidget').SlidesWidget;
var EditorWidget = require('./widgets/EditorWidget').EditorWidget;

var SidebarWidget = require('./widgets/SidebarWidget').SidebarWidget;
var TerminalWidget = require('./widgets/TerminalWidget').TerminalWidget;
var TerminalSessionWidget = require('./widgets/TerminalSessionWidget').TerminalSessionWidget;
var ExplorerPanel = require('./widgets/ExplorerPanel').ExplorerPanel;
var DependenciesPanel = require('./widgets/DependenciesPanel').DependenciesPanel;

var tracking = require('./tracking');

require('./actions');

// Should be moved elsewhere
Imba.extendTag('element', function(tag){
	
	tag.prototype.sref = function (){
		return this._sref || (this._sref = this.dataset('sref'));
	};
	
	tag.prototype.setSref = function (ref){
		if (this._sref != ref) {
			this.dataset('sref',this._sref = ref);
		};
		return this;
		return this;
	};
});

/*

A space is stored and constructed from a single list of sequential
events. At any point in time it might have multiple active participants,
multiple files etc, but only the stream of events will ever be saved.

The state at any specific time can always be constructed by applying
all events up until that point in the stream.

*/


var SpaceOptions = {
	sidebar: 'auto', // visible | hidden | auto
	fontSize: 'auto',
	deviceType: 'auto', // desktop | tablet | phone
	disableLayoutOptimizations: false,
	scale: 1,
	inlineTrack: false
};

var SpaceInstanceCounter = 0;

function Space(data,options){
	var self = this;
	if(options === undefined) options = {};
	if (false) {};
	
	self._disposer = new Disposer();
	self._data = {};
	self._model = data; // should be certain that this is correct already
	self._id = self._model.id;
	self._promises = {};
	self._manager = options.manager;
	self._options = Object.assign({},SpaceOptions,options);
	self._playlist = options.playlist; // or @model.playlist
	self._namespace = ("sp" + (SpaceInstanceCounter++));
	self._randomIncr = 0;
	self._stats = {viewers: 0};
	self._counters = {ticks: 0};
	self._marked = {any: 0};
	self._client = new Client(self);
	self._toucher = function() { return self.dirty(); };
	self._peers = new List(self);
	self._mediaStreams = new List(self);
	self._cache = {};
	
	if (false) {};
	
	self.setReadyState('init');
	self;
};

exports.Space = Space; // export class 
Space.prototype.options = function(v){ return this._options; }
Space.prototype.setOptions = function(v){ this._options = v; return this; };
Space.prototype.playlist = function(v){ return this._playlist; }
Space.prototype.setPlaylist = function(v){ this._playlist = v; return this; };
Space.prototype.stats = function(v){ return this._stats; }
Space.prototype.setStats = function(v){ this._stats = v; return this; };
Space.prototype.offset = function(v){ return this._offset; }
Space.prototype.setOffset = function(v){ this._offset = v; return this; };

Space.prototype.trunk = function(v){ return this._trunk; }
Space.prototype.setTrunk = function(v){ this._trunk = v; return this; };
Space.prototype.branch = function(v){ return this._branch; }
Space.prototype.setBranch = function(v){ this._branch = v; return this; };

// the branch we are currently scoped into
Space.prototype.cursor = function(v){ return this._cursor; }
Space.prototype.setCursor = function(v){ this._cursor = v; return this; };

Space.prototype.__agent = {watch: 'agentDidSet',name: 'agent'};
Space.prototype.agent = function(v){ return this._agent; }
Space.prototype.setAgent = function(v){
	var a = this.agent();
	if(v != a) { this._agent = v; }
	if(v != a) { this.agentDidSet && this.agentDidSet(v,a,this.__agent) }
	return this;
};

// the main timeline in focus
Space.prototype.__timeline = {watch: 'timelineDidSet',name: 'timeline'};
Space.prototype.timeline = function(v){ return this._timeline; }
Space.prototype.setTimeline = function(v){
	var a = this.timeline();
	if(v != a) { this._timeline = v; }
	if(v != a) { this.timelineDidSet && this.timelineDidSet(v,a,this.__timeline) }
	return this;
};
Space.prototype.__annotation = {watch: 'annotationDidSet',name: 'annotation'};
Space.prototype.annotation = function(v){ return this._annotation; }
Space.prototype.setAnnotation = function(v){
	var a = this.annotation();
	if(v != a) { this._annotation = v; }
	if(v != a) { this.annotationDidSet && this.annotationDidSet(v,a,this.__annotation) }
	return this;
};

Space.prototype.widgets = function(v){ return this._widgets; }
Space.prototype.setWidgets = function(v){ this._widgets = v; return this; };
Space.prototype.files = function(v){ return this._files; }
Space.prototype.setFiles = function(v){ this._files = v; return this; };
Space.prototype.recording = function(v){ return this._recording; }
Space.prototype.setRecording = function(v){ this._recording = v; return this; };
Space.prototype.manager = function(v){ return this._manager; }
Space.prototype.setManager = function(v){ this._manager = v; return this; };
Space.prototype.agents = function(v){ return this._agents; }
Space.prototype.setAgents = function(v){ this._agents = v; return this; };

// the agent-widget representing me(!)
Space.prototype.__me = {watch: 'meDidSet',name: 'me'};
Space.prototype.me = function(v){ return this._me; }
Space.prototype.setMe = function(v){
	var a = this.me();
	if(v != a) { this._me = v; }
	if(v != a) { this.meDidSet && this.meDidSet(v,a,this.__me) }
	return this;
};
Space.prototype.spectator = function(v){ return this._spectator; }
Space.prototype.setSpectator = function(v){ this._spectator = v; return this; };
Space.prototype.__userMedia = {watch: 'userMediaDidSet',name: 'userMedia'};
Space.prototype.userMedia = function(v){ return this._userMedia; }
Space.prototype.setUserMedia = function(v){
	var a = this.userMedia();
	if(v != a) { this._userMedia = v; }
	if(v != a) { this.userMediaDidSet && this.userMediaDidSet(v,a,this.__userMedia) }
	return this;
};
Space.prototype.mediaStreams = function(v){ return this._mediaStreams; }
Space.prototype.setMediaStreams = function(v){ this._mediaStreams = v; return this; };

// default singleton widgets
Space.prototype.fs = function(v){ return this._fs; }
Space.prototype.setFs = function(v){ this._fs = v; return this; };
Space.prototype.layout = function(v){ return this._layout; }
Space.prototype.setLayout = function(v){ this._layout = v; return this; };
Space.prototype.console = function(v){ return this._console; }
Space.prototype.setConsole = function(v){ this._console = v; return this; };
Space.prototype.simulator = function(v){ return this._simulator; }
Space.prototype.setSimulator = function(v){ this._simulator = v; return this; };
Space.prototype.inspector = function(v){ return this._inspector; }
Space.prototype.setInspector = function(v){ this._inspector = v; return this; };
Space.prototype.browser = function(v){ return this._browser; }
Space.prototype.setBrowser = function(v){ this._browser = v; return this; };
Space.prototype.pointerTracker = function(v){ return this._pointerTracker; }
Space.prototype.setPointerTracker = function(v){ this._pointerTracker = v; return this; };
Space.prototype.primaryEditor = function(v){ return this._primaryEditor; }
Space.prototype.setPrimaryEditor = function(v){ this._primaryEditor = v; return this; };
Space.prototype.terminal = function(v){ return this._terminal; }
Space.prototype.setTerminal = function(v){ this._terminal = v; return this; };
Space.prototype.explorerPanel = function(v){ return this._explorerPanel; }
Space.prototype.setExplorerPanel = function(v){ this._explorerPanel = v; return this; };
Space.prototype.dependenciesPanel = function(v){ return this._dependenciesPanel; }
Space.prototype.setDependenciesPanel = function(v){ this._dependenciesPanel = v; return this; };
Space.prototype.slides = function(v){ return this._slides; }
Space.prototype.setSlides = function(v){ this._slides = v; return this; };
Space.prototype.sidebar = function(v){ return this._sidebar; }
Space.prototype.setSidebar = function(v){ this._sidebar = v; return this; };
Space.prototype.readyState = function(v){ return this._readyState; }
Space.prototype.setReadyState = function(v){ this._readyState = v; return this; };
Space.prototype.client = function(v){ return this._client; }
Space.prototype.setClient = function(v){ this._client = v; return this; };
Space.prototype.peers = function(v){ return this._peers; }
Space.prototype.setPeers = function(v){ this._peers = v; return this; };
Space.prototype.cache = function(v){ return this._cache; }
Space.prototype.setCache = function(v){ this._cache = v; return this; };

Space.load = async function (id,api){
	// rewriting legacy int-ids
	if (("" + id).match(/^\d+$/)) { id = ("cast-" + id) };
	
	var data = await api.load(id);
	// make sure we have pub or draft - should always be included though?
	await (data.pub || data.draft || data.fetch());
	if (!data || data.CODE == 404) {
		return null;
	};
	return new this(data,{api: api});
};

Space.prototype.agentForPid = function (pid){
	var $1;
	return this._cache[$1 = pid + '-agent'] || (this._cache[$1] = this.agents().first(function(agent) { return agent.pid() == pid; }));
};

Space.prototype.onmodel = function (event,params){
	var dict;
	this.log("Space.onmodel",event,params);
	var items = [];
	for (let pid in dict = this.model()._data.peers){
		let status;
		status = dict[pid];if (status) { items.push(this.api().db().get(pid)) };
	};
	this.log("peers we have",items);
	return this._peers.update(items);
};

Space.prototype.recordMediaStream = function (media){
	media._recording || (media._recording = new MediaRecording(
		{stream: media,
		branch: this.branch(),
		space: this,
		owner: this,
		data: {
			pid: media._peer.id
		}}
	));
	return media._recording.start();
};

Space.prototype.userMediaDidSet = function (media,prev){
	// set media for peers(?)
	// set media for own peer?
	// start/stop mediarecordings
	for (let i = 0, items = iter$(this._peers), len = items.length, peer; i < len; i++) {
		peer = items[i];
		console.log(("setting local media for peer " + (peer.id)));
		peer.rtc().setLocalMedia(media);
	};
	
	if (prev) { this._mediaStreams.remove(prev) };
	if (media) { this._mediaStreams.add(media) };
	
	if (prev) {
		for (let i = 0, items = iter$(prev.getAudioTracks()), len = items.length; i < len; i++) {
			items[i].stop();
		};
	};
	return this;
};

Space.prototype.option = function (key,value){
	if (value != undefined) {
		this._options[key] = value;
	};
	return this._options[key];
};

Space.prototype.id = function (){
	return this._model.id;
};
Space.prototype.model = function (){
	return this._model;
};
Space.prototype.data = function (){
	return this._data;
};
Space.prototype.namespace = function (){
	return this._namespace;
};
Space.prototype.state = function (){
	return this.model().state();
};
Space.prototype.type = function (){
	return this.model().type();
};

Space.prototype.touch = function (type){
	var num = this._counters[type] || (this._counters[type] = 0);
	this._counters[type] += 1;
	this._dirty = true;
	return this;
};

Space.prototype.counter = function (type){
	this.log('deprecated space.counter',type);
	return this._counters[type] || 0;
};

Space.prototype.isEditing = function (){
	return this.branch().isEditing();
};

Space.prototype.actions = function (){
	return this._actions || (this._actions = new ActionManager(this));
};

Space.prototype.api = function (){
	return this._options.api;
};

Space.prototype.socket = function (){
	return this.api().socket();
};

Space.prototype.audio = function (){
	return AudioManager.instance();
};

Space.prototype.space = function (){
	return this;
};

Space.prototype.branch = function (){
	return this._cursor ? this.cursor().branch() : null;
};

Space.prototype.stream = function (){
	return this.branch() ? this.branch().stream() : null;
};

Space.prototype.buffer = function (){
	return this.stream() ? this.stream().buffer() : null;
};

Space.prototype.emit = function (name){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.emit(this,name,params);
};
Space.prototype.on = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.listen.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
Space.prototype.once = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.once.apply(Imba,[].concat([this,name], [].slice.call(params)));
};
Space.prototype.un = function (name){
	var Imba_;
	var $0 = arguments, i = $0.length;
	var params = new Array(i>1 ? i-1 : 0);
	while(i>1) params[--i - 1] = $0[i];
	return Imba.unlisten.apply(Imba,[].concat([this,name], [].slice.call(params)));
};

Space.prototype.log = function (){
	var $0 = arguments, i = $0.length;
	var params = new Array(i>0 ? i : 0);
	while(i>0) params[i-1] = $0[--i];
	if (false) {};
};

Space.prototype.async = function (name){
	var self = this;
	self._asyncTriggers || (self._asyncTriggers = {});
	var fn = self._asyncTriggers[name] || (self._asyncTriggers[name] = function() { return self[name](); });
	Imba.TICKER.add(fn);
	return self;
};

Space.prototype.generateRandomId = function (){
	var start = this._randomIncr++;
	return start + "" + util.uuid().substr(0,8);
};

Space.prototype.timelineDidSet = function (new$,old){
	var $1, $2;
	($1 = old) && $1.deactivate  &&  $1.deactivate();
	($2 = new$) && $2.activate  &&  $2.activate();
	return this.dirty();
};

Space.prototype.meDidSet = function (new$,old){
	var $1, $2;
	this.log('meDidSet',new$,old);
	($1 = old) && $1.deactivate  &&  $1.deactivate();
	return ($2 = new$) && $2.activate  &&  $2.activate();
};

Space.prototype.jumpTo = function (ref){
	var self = this, offset_;
	if ((typeof ref=='string'||ref instanceof String)) { ref = SCON.decodeURI(ref) };
	
	// see if we are in correct cast
	if ((typeof (offset_ = ref.offset)=='number'||offset_ instanceof Number)) {
		self.timeline().pause();
		self.timeline().seek(ref.offset);
		self.tick();
	};
	
	if (ref.path && ref.selection) {
		let file = self.space().fs().find(ref.path);
		// TODO use primaryEditor instead?
		// Could we expect that we are at the correct file?
		self.primaryEditor().setFile(file);
		// agent.file = file
		
		var decoration = {
			range: ref.selection,
			options: {
				className: 'question',
				stickiness: 1,
				isWholeLine: !(!ref.selection[4]),
				hoverMessage: {value: "Referenced"},
				glyphMarginClassName: 'question',
				linesDecorationsClassName: 'question',
				marginClassName: 'question'
			}
		};
		
		file.deltaDecorations('ref',[decoration]);
		self.cursor().once('sync:start',function() {
			// unset the local agent-file
			file.deltaDecorations('ref',[]);
			return self.agent().options().reset('file');
		});
	};
	return self;
};

Space.prototype.annotationDidSet = async function (new$,old){
	var self = this, file_, offset_;
	self.log("annotationDidSet",new$);
	
	var seed = self._preAnnotationAnchor;
	
	self._preAnnotationAnchor = {
		branch: self.branch(),
		offset: self.timeline().currentOffset()
	};
	
	// remove decorations from previous annotations no matter what?
	// BUG if you toggle petween
	if (old) {
		(file_ = self.agent().file()) && file_.deltaDecorations  &&  file_.deltaDecorations(old.id,[]);
	};
	
	// find the correct branch
	if (!(new$)) { return };
	
	await self.navigateTo(new$.cast());
	
	if (new$) {
		// should rather be solved by setting the uri in hash
		var anchor = new$.anchor || {};
		let ref = SCON.decodeURI(anchor.uri);
		
		if ((typeof (offset_ = new$.offset)=='number'||offset_ instanceof Number)) {
			self.timeline().pause();
			self.timeline().seek(new$.offset);
			self.tick();
		};
		
		// disable annotation immediately if we are resyncing
		// let curr = cursor.current
		
		if (ref && ref.path && ref.selection) {
			// throw if wrong event-index?
			// get file at this path(!)
			let file = self.space().fs().find(ref.path);
			self.agent().setFile(file);
			// log "setting range!",anchor,file
			
			var decoration = {
				range: ref.selection,
				options: {
					className: 'question',
					stickiness: 1, // no stickiness
					isWholeLine: !(!ref.selection[4]),
					hoverMessage: {value: new$.body || "Hlelo"},
					glyphMarginClassName: 'question',
					linesDecorationsClassName: 'question',
					marginClassName: 'question'
				}
			};
			
			file.deltaDecorations(new$.id,[decoration]);
		};
		
		self.cursor().once('sync:start',function() {
			var $1, v_;
			($1 = self.agent().file()) && $1.deltaDecorations  &&  $1.deltaDecorations(new$.id,[]);
			if (self.annotation() == new$) {
				return (self.setAnnotation(null),null);
			};
		});
	};
	return self;
};


Space.prototype.clone = function (o){
	if(o === undefined) o = {};
	this.log("clone",o);
	
	// var confirm = window.confirm("Are you sure you want to create a copy of this cast, at the current offset?")
	// return unless confirm
	
	var data = Branch.modelDataFromEvent(this.cursor().current());
	var snap = this.cursor().branch().toSnapshot();
	
	data.title = this.model().title;
	data.state = 'draft'; // not possible to follow live?
	data.privacy = 'public';
	data.type = 'lab';
	data.parent_id = this.branch().model().id;
	data.snapshot = snap;
	
	return data;
};


Space.prototype.fork = async function (o){
	var self = this;
	if(o === undefined) o = {};
	var user = await self.api().tryLogin();
	
	if (!user) {
		return window.alert("Not allowed to fork without logging in");
	};
	
	self.navigateTo(self.trunk());
	
	return self.trunk().upsertResponse().then(function(fork) {
		return self.navigateTo(fork);
	});
	return self;
};

Space.prototype.simulator = function (){
	return this.__lookup(CAST.SIMULATOR);
};

Space.prototype.setup = function (){
	var self = this;
	return self._promises.setup || (self._promises.setup = new Promise(function(resolve,reject) {
		self.setReadyState('setup');
		// return same promise every time?
		
		self._offset = 0;
		self._widgets = new Widgets(self);
		self._files = new List(self);
		self._agents = new List(self);
		
		self._trunk = new Trunk(self,null,self.model());
		self._cursor = new Cursor(self);
		
		if (false) {};
		
		// setting up default widgets
		self._widgets.on('add',function() { return self.mark_('widget'); });
		self._widgets.on('remove',function() { return self.mark_('widget'); });
		
		// setting up the default widgets before loading stream
		self.setLayout(self.widgets().add(self.widgets().create('layout',{id: CAST.WORKSPACE})));
		// self.simulator = widgets.add widgets.create(:simulator, id: CAST.SIMULATOR)
		self.setInspector(self.widgets().add(self.widgets().create('inspector',{id: CAST.INSPECTOR})));
		self.setAgent(self.widgets().add(self.widgets().create('agent',{id: CAST.AGENT,color: 'blue'})));
		self.setFs(self.widgets().add(new FileSystemWidget(self,{id: CAST.FS,expanded: true})));
		self.setSidebar(self.widgets().add(new SidebarWidget(self,{id: CAST.SIDEBAR})));
		
		self.setConsole(self.widgets().add(self.widgets().create('console',{id: CAST.CONSOLE})));
		self.setPrimaryEditor(self.widgets().add(new EditorWidget(self,{id: CAST.PRIMARY_EDITOR})));
		self.setTerminal(self.widgets().add(new TerminalWidget(self,{id: CAST.PRIMARY_TERMINAL})));
		
		self.setExplorerPanel(self.widgets().add(new ExplorerPanel(self,{id: CAST.EXPLORER_PANEL})));
		self.setDependenciesPanel(self.widgets().add(new DependenciesPanel(self,{id: CAST.DEPENDENCIES_PANEL})));
		self.setSlides(self.widgets().add(new SlidesWidget(self,{id: CAST.SLIDES})));
		
		// default layout for browser - weird place?
		var dims = Dimensions.build(
			{left: (1024 - 300 - 40),
			top: Math.round((768 - 300) * 0.3),
			width: 300,
			height: 300,
			vw: 1024,
			vh: 768,
			scaleX: 100,
			scaleY: 100,
			targetRef: CAST.BROWSER}
		).round();
		
		self.setBrowser(self.widgets().add(self.widgets().create('browser',{
			id: CAST.BROWSER,
			layout: dims._data,
			url: self.model().cli() ? "http://localhost:3000" : "index.html"
		})));
		
		self._spectator = self._me = new Spectator(self,{type: 'agent',follows: CAST.AGENT},{branch: function() { return null; }});
		
		// set initial browser-layout?
		self.setTimeline(self.trunk().timeline());
		self.view().render();
		if (false) {};
		return resolve(self);
	}));
};


/*
	Called with the whole stream etc
	*/

Space.prototype.load = function (){
	var self = this;
	return self._promises.load || (self._promises.load = new Promise(async function(resolve) {
		// if $web$
		//	var time = api.analytics.time(:app,"loadCast",id)
		await self.setup();
		await self.trunk().load();
		// not if this is an embed?
		if (false && !self.option('demo')) {
			self.api().socket().join(self.id());
			self.model().connect();
		};
		
		self.view().render();
		self.setReadyState('complete');
		// now set the timeline
		if (false) {};
		Imba.listen(Imba,'commit',self._toucher);
		
		
		if (false) {};
		return resolve(self);
	}));
};

// proxying to branch
Space.prototype.isEditing = function (){
	return this.branch().isEditing();
};
Space.prototype.isRecording = function (){
	return this.branch().isRecording();
};
Space.prototype.isHosting = function (){
	return this.branch().isHosting();
};
Space.prototype.isWatching = function (){
	return this.branch().isWatching();
};
Space.prototype.isPlaying = function (){
	return this.branch().isPlaying();
};
Space.prototype.isLive = function (){
	return this.branch().isLive();
};
Space.prototype.isPaused = function (){
	return this.branch().isPaused();
};
Space.prototype.isAnnotating = function (){
	return this.branch().isAnnotating();
};

Space.prototype.isSpectating = function (){
	return this.me() == this.spectator();
};

Space.prototype.host = function (){
	return this.trunk().host();
};

/*
	This should ideally first find the whole tree
	of ascendants - and then walk inwards - fetching and loading
	branches along the way
	*/

Space.prototype.resolveBranchForModel = function (model){
	var root = this._trunk.model();
	
	if (model == root) {
		return Promise.resolve(this._trunk);
	};
	
	if (model.parent_id == root.id) {
		return this._trunk.loadChildBranch(model);
	};
};

// centralized method to switch branch
Space.prototype.navigateTo = function (branch,mode){
	throw "Not implemented";
};

Space.prototype.sendStats = function (){
	return this;
};

// method for parsing/handing an event.
// takes care of bringing the local state
// of the space up-to-date with supplied event

Space.prototype.apply = function (action){
	return;
};

Space.prototype.revert = function (action){
	return;
};

Space.prototype.reset = function (snapshot){
	this.deserialize(snapshot,{});
	return this;
};

Space.prototype.synced_ = function (){
	return this;
};

Space.prototype.createWidget = function (pkg,extra){
	if(extra === undefined) extra = {};
	pkg.id || (pkg.id = this.widgets().getNextId());
	let action = this.branch().push_(ACTION.WIDGET_CREATE,[0,pkg],extra);
	return (action && action.ACTION) ? action.ACTION : action;
};

Space.prototype.createAgent = function (data,extra){
	// check if agent already exists
	if(extra === undefined) extra = {};
	var existing = this.agents().find(function(_0) { return _0.pid() == data.pid; });
	if (existing) {
		for (let v, i = 0, keys = Object.keys(data), l = keys.length, k; i < l; i++){
			k = keys[i];v = data[k];existing.options().set(k,v);
		};
		return existing;
	};
	
	var taken = this.agents().map(function(_0) { return _0.color(); });
	var color = AGENT.COLORS.find(function(_0) { return taken.indexOf(_0) == -1; });
	data.type = 'agent';
	data.color || (data.color = color);
	data.pid || (data.pid = this.api().pid());
	
	// by default, it should follow the root agent
	// if data:follows == 'auto'
	//	data:follows = agent.id
	
	if (data.pid) {
		let peer = this.api().db().get(data.pid);
		data.uid = peer.uid;
		data.name || (data.name = peer.name());
	};
	
	console.log("create agent",data);
	var agent = this.createWidget(data,extra).widget();
	// if me.isActive
	// 	agent.followed = yes
	// 	# make sure the other agent is following us as well?
	// 	# I should start following this, and vica versa
	return agent;
};


Space.prototype.onpacket = function (packet){
	return console.log("space onpacket",packet);
};


/*
	Method for adding new events to the stream
	*/

Space.prototype.__push = function (action,o){
	var current;
	if(o === undefined) o = {};
	/*
			if we are currently processing an event, this will
			be appended as a temporary subevent. It will also
			be automatically reverted when the parent event is reverted.
			*/
	
	if (current = this.cursor().stack()[0]) {
		return current.addSubAction(action,this.cursor());
	};
	
	// console.log "Space.__push",action
	action.LOCAL = o;
	
	if (this._localBranch) {
		return this._localBranch.addLocalEvent(action,o);
	};
	
	/*
			If we are not currently at the end of the stream (mode == live)
			AND allowed to edit - we should automatically enter fork-mode
			*/
	
	
	let currBranch = this.cursor().branch();
	
	// console.log "canPush",action,currBranch
	
	if (!this.cursor().canPush(action)) {
		// log "cursor cannot push",action,branch.mode,cursor.current,cursor.current.@next
		// is this when you are not hosting?
		// if currBranch.isWatching and currBranch.canContribute and currBranch.canEdit
		// 	#  and !cursor.current.@next
		// 	log "could be able to contribute??",action
		// 	# show alert here? stack up the changes?
		// 	currBranch.addLocalEvent(action,o)
		// 	return action
		
		var branch = this._localBranch = Branch.branchFromEvent(this.cursor().current());
		
		// api.analytics.castBranch(id)
		// console.log "created branch!",branch
		branch.populate();
		if (branch.head()) { this.cursor().sync(branch.head()) };
		// client.flushLocals # really though? - these events will be added to the fork?
		// is it not here we should really pick this up?
		branch.addLocalEvent(action,o);
		// api.sendTracking(tracking.TYPES.BRANCH, [branch.id])
		// console.log "pushed the triggering event",event
		this._localBranch = null;
		return action;
	};
	
	// should push to the current branch
	if (this.cursor().canPush(action)) {
		// if $verbose$
		// 	console.log "push",action
		this.cursor().branch().addLocalEvent(action,o);
		this._dirty = true;
	} else {
		action.discard();
		this.log("CANNOT __push",action);
	};
	return action;
};

Space.prototype.__lookup = function (ref,idx){
	if(idx === undefined) idx = 0;
	var item;
	if (ref instanceof Array) {
		item = this.widgets().get(ref[idx++]);
		return (idx == ref.length) ? item : item.__lookup(ref,idx);
	};
	return this.widgets().get(ref);
};

Space.prototype.mark_ = function (val){
	// log 'mark_',val
	if (val instanceof Array) {
		for (let i = 0, items = iter$(val), len = items.length; i < len; i++) {
			this.mark_(items[i]);
		};
		return;
	};
	this._marked[val] = (this._marked[val] || 0) + 1;
	this._dirty = true;
	return this;
};

Space.prototype.version = function (key){
	return this._marked[key] || 0;
};

Space.prototype.changed = function (key,viewpoint){
	var self = this;
	if (key instanceof Array) {
		return key.some(function(k) { return self.changed(k,viewpoint); });
	};
	
	let v = self._marked[key] || 0;
	if (viewpoint) {
		let map = viewpoint._versions || (viewpoint._versions = {});
		if ((!map[key] && v) || map[key] != v) {
			map[key] = v;
			return true;
		};
	};
	return false;
};


Space.prototype.record = function (o){
	this.log("start recording!",o);
	this.cursor().branch().record(o);
	return this;
};

// method for serializing
Space.prototype.serialize = function (o){
	if(o === undefined) o = {};
	var snapshot = {
		id: this.id(),
		index: this.stream().index()
	};
	
	var widgets = this.widgets().map(function(item) {
		if (!(o.exclude && Imba.indexOf(item.TYPE,o.exclude) >= 0)) {
			return item.serialize(o,snapshot);
		};
	});
	
	snapshot.widgets = widgets.filter(function(item) { return item; });
	return snapshot;
};

Space.prototype.deserialize = function (o,e){
	this._deserialized = true;
	o = SCON.clone(o);
	// should extract into Serializer and Deserializer
	var state = {
		event: e,
		items: [],
		created: [],
		stack: [this]
	};
	
	// e.SNAPSHOT = yes
	for (let i = 0, items = iter$(o.widgets), len = items.length, item; i < len; i++) {
		// hardcoded workaround
		item = items[i];
		if (item.type == 'audio') { continue; };
		let exists = !(!this.widgets().get(item.id));
		Widget.load(this,item,e).deserialize(item,state,exists);
	};
	
	for (let i = 0, items = iter$(state.items), len = items.length; i < len; i++) {
		items[i].deserialized(state);
	};
	return this;
};

Space.prototype.isDeserialized = function (){
	return !!this._deserialized;
};

Space.prototype.dirty = function (){
	return this._dirty = true;
};

Space.prototype.toRunStaticSnapshot = function (){
	var browser_, $1, $2;
	var files = [];
	
	for (let i = 0, items = iter$(this.files()), len = items.length, file; i < len; i++) {
		file = items[i];
		files.push(
			{path: file.path(),
			body: file.body(),
			blobId: file.blobId()}
		);
	};
	
	return {
		files: files,
		npmPackages: (browser_ = this.space().browser()) && browser_.npmPackages  &&  browser_.npmPackages(),
		rootPath: ($1 = this.space().browser()) && $1.rootPath  &&  $1.rootPath(),
		catchallPath: ($2 = this.space().browser()) && $2.catchallPath  &&  $2.catchallPath()
	};
};


/* tick

	*/

Space.prototype.tick = function (){
	var timeline_, branch_, pointerTracker_;
	if (this.readyState() == 'disposing') {
		return;
	};
	
	this._counters.ticks++;
	
	// let the current timeline tick.
	// it might set a new targetEvent
	// what if we have already asked for a new timeline?
	(timeline_ = this.timeline()) && timeline_.tick  &&  timeline_.tick();
	(branch_ = this.branch()) && branch_.tick  &&  branch_.tick();
	(pointerTracker_ = this.pointerTracker()) && pointerTracker_.tick  &&  pointerTracker_.tick();
	
	// synced offset now
	var offset = this._offset = this.timeline().currentOffset();
	var last = this._currentEvent;
	// console.log "currentOffset",@offset,cursor.@target
	
	this.cursor().sync(this.cursor()._target,0);
	
	// check if are at a different event than before
	if (last != this.cursor().current()) {
		this._currentEvent = this.cursor().current();
		this._dirty = true;
	};
	
	if (offset != this._lastOffset) {
		this._lastOffset = offset;
		this._dirty = true;
	};
	
	if (this.api()._touches != this._lastApiTouches) {
		this._lastApiTouches = this.api()._touches;
		this._dirty = true;
	};
	
	// this should happen in the view directly
	var mode = this.branch().mode();
	var modeDirty = false;
	
	if (mode != this._mode) {
		let prev = this._mode;
		modeDirty = true;
		this._mode = mode;
		this._dirty = true;
		this.log(("changed mode " + prev + " -> " + mode));
		this.emit('viewmode',mode,prev);
		// make sure me is set
	};
	
	if (false) {};
	
	if (this._dirty || this.timeline().isPlaying()) { // or recording
		this._dirty = false;
		this.view().render();
	};
	
	this.emit('ticked',offset);
	
	if (false) {};
	return this;
};

// terminate should be called before disposing space
// ideally this should return false if not allowed to terminate?
Space.prototype.terminate = function (){
	var timeline_;
	if (this._terminated) { return };
	this._terminated = true;
	this.model().un('all',this);
	
	if (false) {};
	
	(timeline_ = this.timeline()) && timeline_.pause  &&  timeline_.pause();
	return this;
};

/*
	Should teardown and free the memory of everything related to this cast
	*/

Space.prototype.dispose = function (){
	if (this.isDisposing()) {
		return this;
	};
	
	this.setReadyState('disposing');
	this.emit('dispose');
	Imba.unlisten(Imba,'commit',this._toucher);
	// @socket?.close
	this._disposer.dispose();
	
	this.tick = function() { return; };
	
	for (let i = 0, items = iter$(this.widgets()), len = items.length; i < len; i++) {
		items[i].dispose();
	};
	
	this._trunk && this._trunk.dispose  &&  this._trunk.dispose();
	this._view && this._view.dispose  &&  this._view.dispose();
	this._actions && this._actions.dispose  &&  this._actions.dispose();
	this._widgets = null;
	this._cache = {};
	
	this.emit('disposed');
	
	this.__listeners__ = null;
	
	if (false) {};
	return this;
};

Space.prototype.isDisposing = function (){
	return this.readyState() == 'disposing';
};

Space.prototype.isSyncing = function (){
	return this.cursor().syncing();
};

Space.prototype.view = function (){
	let $ = this.$$ || (this.$$ = {});
	return this._view || (this._view = this._view||_1(SpaceView,this).flag('view')).setData(this).setManager(this.manager()).setOptions(this._options).end();
};

Space.prototype.pointer = function (){
	return this._view ? this._view._pointer : null;
};

Space.prototype.vw = function (){
	return this.view().box().width;
};

Space.prototype.vh = function (){
	return this.view().box().height;
};
