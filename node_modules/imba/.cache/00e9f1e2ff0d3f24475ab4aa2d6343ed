function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
function len$(a){
	return a && (a.len instanceof Function ? a.len() : a.length) || 0;
};
var self = {};
var db = require('../server/db').db;

var ffmpeg = require('./ffmpeg');
var util = require('../util');
var path = require('path');
var fs = require('fs');

var DB = require('../store/db').DB;
var sdb = DB.instance();

var env = require('../env');
var ROOT = env.get("FILES_DIR");

// import API from "../server/api"

var TimelineCues = require('../scrimba/util/TimelineCues').TimelineCues;
var StreamBuffer = require('../scrimba/core/StreamBuffer').StreamBuffer;

var SCON = require('../scrimba/protocol').SCON;
var crypto = require('crypto');
ffmpeg = require('./ffmpeg');

var Space = require('../scrimba/space').Space;

function Publisher(id,api){
	this._api = api;
	this._eid = id;
	this;
};

exports.Publisher = Publisher; // export class 
Publisher.prototype.eid = function(v){ return this._eid; }
Publisher.prototype.setEid = function(v){ this._eid = v; return this; };
Publisher.prototype.aid = function(v){ return this._aid; }
Publisher.prototype.setAid = function(v){ this._aid = v; return this; };
Publisher.prototype.space = function(v){ return this._space; }
Publisher.prototype.setSpace = function(v){ this._space = v; return this; };
Publisher.prototype.branch = function(v){ return this._branch; }
Publisher.prototype.setBranch = function(v){ this._branch = v; return this; };
Publisher.prototype.stream = function(v){ return this._stream; }
Publisher.prototype.setStream = function(v){ this._stream = v; return this; };
Publisher.prototype.media = function(v){ return this._media; }
Publisher.prototype.setMedia = function(v){ this._media = v; return this; };

Publisher.prototype.process = async function (){
	var scrim = await sdb.entities().summon(this.eid());
	this._data = Object.assign({},scrim._data.data);
	
	// fetch stream
	var buf = await scrim.fetchStreamBuffer(this._api,0);
	
	if (len$(buf) == 0) {
		console.log("has no buffer!!!");
		await this.dispose();
		return this;
	};
	
	this._space = new Space(scrim,{api: this._api});
	this._draft = {cues: [],audio: [],start: 0};
	this._pub = {};
	await this._space.load();
	
	this._branch = this.space().trunk();
	this._stream = this.branch().stream();
	
	// console.log @space.trunk.stream.buffer.len
	this.setMedia(this._stream.media());
	
	await this.processAudioDurations();
	
	// create cues outside of the periods with audio / recording?
	var duration = this.stream().duration();
	this._draft.end = duration;
	this._data.end = duration;
	
	var ms = 0;
	var cues = [];
	var clips = [];
	for (let i = 0, items = iter$(this.stream().recordings()), len = items.length, rec; i < len; i++) {
		rec = items[i];
		let start = rec.timeOffset();
		let span = start - ms;
		
		let cue = [0,ms,span,Math.min(span * 0.2 * Math.min(i,1),1000)];
		cues.push(cue);
		ms = rec._duration ? ((start + rec._duration)) : duration;
	};
	
	for (let i = 0, items = iter$(this.media()), len = items.length, audioclip; i < len; i++) {
		audioclip = items[i];
		let clip = [1,audioclip.offset,audioclip.duration,audioclip.fid];
		clips.push(clip);
	};
	
	this._draft.cues = cues;
	this._draft.audio = clips;
	this._pub.cues = this._draft.cues;
	this._cues = new TimelineCues(SCON.clone(this._draft));
	this._data.duration = this._cues.duration();
	
	await this.generateAudio();
	
	this._data.cues = this._pub.cues;
	
	return await this.finish();
};


Publisher.prototype.processAudioDurations = async function (){
	for (let i = 0, items = iter$(this.media()), len = items.length, clip; i < len; i++) {
		clip = items[i];
		var file = await sdb.files().summon(clip.fid);
		await ffmpeg.finalize(file);
		clip.meta = file.metadata; // await ffmpeg.probe(clip:fid)
		clip.duration = clip.meta.duration;
	};
	return this;
};

Publisher.prototype.generateAudio = async function (){
	if (!(this.media() && len$(this.media()))) { return this };
	// skip if we have no audio!
	var fid = await ffmpeg.mixAudio(this._cues);
	this._pub.audio = fid;
	this._data.audio = fid;
	return this;
};

Publisher.prototype.dispose = async function (){
	await db.table('entities').update({state: 'disposed'}).where({id: this._eid});
	return this;
};

Publisher.prototype.finish = async function (){
	await db.table('entities').update({data: this._data,state: 'ended'}).where({id: this._eid});
	return this;
};

exports.publish = self.publish = function (vid,api){
	var job = new Publisher(vid,api);
	return job.process();
};

// var job = Publisher.new('cv-6')
// await job.publish
// console.log "done!"