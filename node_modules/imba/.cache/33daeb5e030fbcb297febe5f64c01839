function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
var Packet = require('./Packet').Packet;

/*

*/


function Request(packet){
	this._sent = Date.now();
	this._packet = packet;
	this;
};

Request.prototype.response = function(v){ return this._response; }
Request.prototype.setResponse = function(v){ this._response = v; return this; };

Request.prototype.resolve = function (value){
	this._resolved = value;
	for (let i = 0, items = iter$(this._listeners), len = items.length; i < len; i++) {
		items[i](value);
	};
	this._listeners = [];
	return this;
};

Request.prototype.reject = function (value){
	return this;
};

Request.prototype.then = function (cb){
	if (this._resolved != undefined) {
		cb(this._resolved);
	} else {
		this._listeners || (this._listeners = []);
		this._listeners.push(cb);
	};
	return;
};

// Wrapper for DataChannel and other sockets, unifying the API
// Why not just wrap the actual socket. It should be a one-to-one
function PacketChannel(owner){
	this._counter = -1;
	this._owner = owner;
	this._requests = {};
	
	this.send = this.send.bind(this);
	this.request = this.request.bind(this);
	
	this._owner.send || (this._owner.send = this.send);
	this._owner.request || (this._owner.request = this.request);
	this;
};

exports.PacketChannel = PacketChannel; // export class 
PacketChannel.prototype.queue = function(v){ return this._queue; }
PacketChannel.prototype.setQueue = function(v){ this._queue = v; return this; };
PacketChannel.prototype.owner = function(v){ return this._owner; }
PacketChannel.prototype.setOwner = function(v){ this._owner = v; return this; };

PacketChannel.prototype.api = function (){
	return this._owner.api();
};

PacketChannel.prototype.peer = function (){
	return this._owner.peer();
};

// sending data 
PacketChannel.prototype.send = function (params){
	var payload = Packet.serialize(params,{scope: this.api()});
	this._owner.sendPacket(payload);
	return this;
};

// sending packet that expects reply
// returns a promise
PacketChannel.prototype.request = function (params){
	var ref = this._counter--;
	var req = new Request(ref);
	var payload = Packet.serialize(params,{ref: ref,scope: this.api()});
	this._requests[ref] = req;
	this._owner.sendPacket(payload);
	return req;
};

PacketChannel.prototype.respond = function (ref,params){
	var payload = Packet.serialize(params,{ref: -ref,scope: this.api()});
	return this._owner.sendPacket(payload);
};

PacketChannel.prototype.receive = function (raw){
	var packet = Packet.deserialize(raw,this,{scope: this.api()});
	var code = packet.CODE;
	var ref = packet.ref();
	// emit raw message here?
	// console.log "received packet",code,ref
	// this is a response to previously sent packet
	if (ref > 0) {
		let req = this._requests[-ref];
		if (!req) {
			throw "Received response to unknown request";
		};
		req.resolve(packet);
	} else {
		this.handle(packet);
	};
	return this;
};

PacketChannel.prototype.handle = function (packet){
	return this._owner.onpacket(packet);
};
